<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重置 Windows 10 开始菜单布局]]></title>
    <url>%2F2018%2F04%2F05%2Freset-your-start-menu-layout-in-Windows-10-1709%2F</url>
    <content type="text"><![CDATA[中文版Windows 10 从很久以前就开始有这个问题，升级或者全新安装以后开始菜单磁贴无法正常工作。拖动一下就会卡死，或者修改布局并重新登录以后就会重置成以前的样子。 此问题影响至少 1709 和 1803 版本，并且能在全新安装的系统上复现。 搜遍谷歌，找到一种解决方法，是删除注册表中对于开始菜单磁贴的缓存。 Windows 1709管理员版本 Powershell 下执行： 12Remove-Item 'HKCU:\Software\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount\$start.tilegrid$windows.data.curatedtilecollection.root' -Force -RecurseGet-Process Explorer | Stop-Process 或使用注册表编辑器手动删除： Computer\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount 下的$start.tilegrid$windows.data.curatedtilecollection.root 项目。 Windows 1803管理员版本 Powershell 下执行： 12Remove-Item 'HKCU:\Software\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount\' -Force -RecurseGet-Process Explorer | Stop-Process 或使用注册表编辑器手动删除： Computer\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount 下以的 $start.tilegrid$windows.data.curatedtilecollection.root 结尾的项目。 EnglishIt has been a long while since Windows 10 had issues with its start menu layout, such as dragging and dropping icons causes crashes, or layout gets reverted after signing out and in. At least 1709 and 1803 fresh installations are affected. A strategy to mitigate the issue, according to the other end of Google, is to remove the cache store in the system registery. Windows 1709Execute the following under Admin Powershell: 12Remove-Item 'HKCU:\Software\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount\$start.tilegrid$windows.data.curatedtilecollection.root' -Force -RecurseGet-Process Explorer | Stop-Process Or, using the Registry Editor Navigate to Computer\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount and delete $start.tilegrid$windows.data.curatedtilecollection.root item. Windows 1803Execute the following under Admin Powershell: 12Remove-Item 'HKCU:\Software\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount\' -Force -RecurseGet-Process Explorer | Stop-Process Or, using the Registry Editor Navigate to Computer\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount and delete item ending with $start.tilegrid$windows.data.curatedtilecollection.root. 由于问题的普遍性，特留下中英文两版以供查阅。 References: [1]: How to reset your start menu layout in Windows 10 1709 转载自：https://www.v2ex.com/t/444426#reply4]]></content>
      <tags>
        <tag>Windows 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去掉Mx player的广告]]></title>
    <url>%2F2018%2F04%2F01%2FRemove-the-ads-of-Mx-player%2F</url>
    <content type="text"><![CDATA[mx player就安卓端来说还是很棒的应用的，可是pro版本售价要6$，汇率一换过来就贵了。想了想，手动给它去广告好了，网上的破解版还是不放心。App展示广告，得有一个地方给它下载广告，阻止App连接相应广告站点就可以了，目标则是找出App用的广告站点。找到的mx player广告站点用的是谷歌，把以下内容添加到手机hosts文件就可以了 1127.0.0.1 googleads.g.doubleclick.net 下面是找到站点的过程。 配置 Fildder到https://www.telerik.com/download/fiddler下载好Fiddler，打开之后，勾选Tools-&gt;&gt;Options-&gt;&gt;HTTPS允许https和Connetions下面的允许局域网远程连接，如下图 然后打开http://localhost:8888，下载证书，双击导入。 配置手机为了能对https进行抓包，还得在手机上安装证书，把证书拷贝或发送到手机内。对于MIUI来说，在设置--&gt;更多设置--&gt;系统安全--&gt;从存储设备安装，然后找到相应的证书就可以安装了，安装后手机会提示网络受到监控。如果提示需要启用文档，则在设置--&gt;更多应用，点一下右上角的三个点，选中显示所有应用，搜索文档，然后点进去就可以启用了。 这个时候，打开WLAN设置，选中连接的wifi，将代理设置成电脑的IP地址，代理端口为8888 开始抓包这个时候，在手机上打开mx plyer，可以在Fiddler上看到很多信息 仔细观看域名和访问的数据，在mx player上的广告是首屏幕启动广告、视频浏览界面的广告和播放视频时的广告。观察url中某些访问了jpg资源的域名，在电脑上屏蔽掉相应的域名，最后找到了googleads.g.doubleclick.net，把这个地址在hosts文件内定向到127.0.0.1，mx player的广告消除。（谷歌老大，对不起你了，我会愧疚的(。・∀・)ノ） 附一份手机上常用的用于屏蔽广告的hosts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317#by wenxibuding QQ410154425#url=http://www.miui.com/thread-11958646-1-1.html127.0.0.1 localhost::1 ip6-localhost#xiaomi/miui/qqtv/youku/pptv/letv/sohutv/#mstat/report127.0.0.1 aeventlog.beacon.qq.com127.0.0.1 android.rqd.qq.com127.0.0.1 astrategy.beacon.qq.com127.0.0.1 eventlog.beacon.qq.com127.0.0.1 monitor.uu.qq.com127.0.0.1 omgmta.qq.com127.0.0.1 omgmta1.qq.com127.0.0.1 oth.eve.mdt.qq.com127.0.0.1 oth.str.mdt.qq.com127.0.0.1 oth.update.mdt.qq.com127.0.0.1 pingma.qq.com127.0.0.1 sngmta.qq.com127.0.0.1 strategy.beacon.qq.com#qq-1127.0.0.1 dp3.qq.com127.0.0.1 imc.l.qq.com#qq-ad127.0.0.1 ad.qq.com127.0.0.1 ad.qun.qq.com127.0.0.1 adping.qq.com127.0.0.1 adpm.app.qq.com127.0.0.1 adrdir.qq.com127.0.0.1 adsclick.qq.com127.0.0.1 adsfile.qq.com127.0.0.1 adsgroup.qq.com127.0.0.1 adshmct.qq.com127.0.0.1 adshmmsg.qq.com127.0.0.1 adslvfile.qq.com127.0.0.1 adslvseed.qq.com127.0.0.1 adsqqclick.qq.com127.0.0.1 adstextview.qq.com127.0.0.1 adsview.qq.com127.0.0.1 adsview2.qq.com127.0.0.1 adv.app.qq.com127.0.0.1 adver.qq.com127.0.0.1 analy.qq.com127.0.0.1 d3g.qq.com127.0.0.1 j.wit.qq.com127.0.0.1 jqmt.qq.com127.0.0.1 jsqmt.qq.com127.0.0.1 mini2015.qq.com127.0.0.1 qqshow2-item.qq.com127.0.0.1 setting.snswin.qq.com127.0.0.1 tj.video.qq.com127.0.0.1 updatecenter.qq.com127.0.0.1 video.ureport.push.qq.com127.0.0.1 video.wap.mpush.qq.com127.0.0.1 wap.mpush.qq.com#qq-t127.0.0.1 ta.qq.com127.0.0.1 tajs.qq.com127.0.0.1 tcss.qq.com127.0.0.1 p.tencentmind.com#qq-e127.0.0.1 e.qq.com127.0.0.1 cm.e.qq.com127.0.0.1 sdk.e.qq.com#qq-gdt127.0.0.1 c.gdt.qq.com127.0.0.1 d.gdt.qq.com127.0.0.1 i.gdt.qq.com127.0.0.1 mi.gdt.qq.com127.0.0.1 q.i.gdt.qq.com127.0.0.1 rm.gdt.qq.com127.0.0.1 t.gdt.qq.com127.0.0.1 v.gdt.qq.com127.0.0.1 win.gdt.qq.com#qq-gtimg127.0.0.1 beacon.gtimg.com127.0.0.1 bla.gtimg.com127.0.0.1 lb.gtimg.com127.0.0.1 pgdt.gtimg.cn127.0.0.1 ra.gtimg.com127.0.0.1 wa.gtimg.com127.0.0.1 wb.gtimg.com#qq-l127.0.0.1 bs.l.qq.com127.0.0.1 c2.l.qq.com127.0.0.1 cb.l.qq.com127.0.0.1 cm.l.qq.com127.0.0.1 hm.l.qq.com127.0.0.1 l.qq.com127.0.0.1 l2.l.qq.com127.0.0.1 lb.l.qq.com127.0.0.1 livec.l.qq.com127.0.0.1 livem.l.qq.com127.0.0.1 livep.l.qq.com127.0.0.1 lives.l.qq.com127.0.0.1 ls.l.qq.com127.0.0.1 p2.l.qq.com127.0.0.1 p3.l.qq.com127.0.0.1 t.l.qq.com127.0.0.1 vd.l.qq.com127.0.0.1 w.l.qq.com#down-127.0.0.1 scdown.qq.com127.0.0.1 download.sj.qq.com127.0.0.1 c.gj.qq.com127.0.0.1 t.sj.qq.com127.0.0.1 ws.sj.qq.com#http://tv.qq.com/127.0.0.1 andrqd.play.aiseet.atianqi.com127.0.0.1 otheve.play.aiseet.atianqi.com127.0.0.1 othstr.play.aiseet.atianqi.com127.0.0.1 omgmta.play.aiseet.atianqi.com127.0.0.1 news-l.play.aiseet.atianqi.com127.0.0.1 p-l.play.aiseet.atianqi.com127.0.0.1 t-l.play.aiseet.atianqi.com#v.qq.com127.0.0.1 news-l.play.ott.video.qq.com127.0.0.1 omgmta.play.ott.video.qq.com127.0.0.1 livep.l.ott.video.qq.com127.0.0.1 lives.l.ott.video.qq.com#tv.qq.com127.0.0.1 aiseet.aa.atianqi.com127.0.0.1 dp3.play.aiseet.atianqi.com127.0.0.1 livep.l.aiseet.atianqi.com127.0.0.1 lives.l.aiseet.atianqi.com127.0.0.1 vmindhls.tc.qq.com127.0.0.1 monitor-uu.play.aiseet.atianqi.com127.0.0.1 sdkconfig.play.aiseet.atianqi.com127.0.0.1 livew.l.qq.com127.0.0.1 c.l.qq.com127.0.0.1 mdevstat.qqlive.qq.com#http://pd.youku.com/CIBN127.0.0.1 g.dtv.cn.miaozhen.com127.0.0.1 xtrader-mipdx.cn.miaozhen.com127.0.0.1 ssv.admaster.com.cn127.0.0.1 vyk.admaster.com.cn127.0.0.1 ipm.atm.cp31.ott.cibntv.net127.0.0.1 val.atm.cp31.ott.cibntv.net127.0.0.1 valf.atm.cp31.ott.cibntv.net#http://m.youku.com/127.0.0.1 adp.atm.youku.com127.0.0.1 iyes.youku.com127.0.0.1 m.atm.youku.com127.0.0.1 mf.atm.youku.com127.0.0.1 mobilemsg.youku.com127.0.0.1 push.m.youku.com#http://www.youku.com/127.0.0.1 bsv.atm.youku.com127.0.0.1 count.atm.youku.com127.0.0.1 dmapp.youku.com127.0.0.1 html.atm.youku.com127.0.0.1 ipm.atm.youku.com127.0.0.1 myes.youku.com127.0.0.1 r.l.youku.com127.0.0.1 service.danmu.youku.com127.0.0.1 statis.mobile.youku.com127.0.0.1 v2html.atm.youku.com127.0.0.1 val.atm.youku.com127.0.0.1 valb.atm.youku.com127.0.0.1 valc.atm.youku.com127.0.0.1 valf.atm.youku.com127.0.0.1 valp.atm.youku.com127.0.0.1 valt.atm.youku.com#youku127.0.0.1 ad.api.3g.tudou.com127.0.0.1 ad.api.3g.youku.com127.0.0.1 ad.api.mobile.youku.com127.0.0.1 b.smartvideo.youku.com127.0.0.1 c.yes.youku.com127.0.0.1 cm.atm.youku.com127.0.0.1 cm.miaozhen.atm.youku.com127.0.0.1 guanggaoad.youku.com127.0.0.1 lstat.youku.com127.0.0.1 m.yes.youku.com127.0.0.1 mb.atm.youku.com127.0.0.1 mi.atm.youku.com127.0.0.1 miaozhen.atm.youku.com127.0.0.1 mo.atm.youku.com127.0.0.1 mp.atm.youku.com127.0.0.1 notify.youku.com127.0.0.1 passport-log.youku.com127.0.0.1 player.lstat.youku.com127.0.0.1 s.p.youku.com127.0.0.1 sdk.api.gamex.mobile.youku.com127.0.0.1 static.atm.youku.com127.0.0.1 store.tv.api.3g.youku.com127.0.0.1 store.xl.api.3g.youku.com127.0.0.1 urchin.lstat.youku.com127.0.0.1 valo.atm.youku.com127.0.0.1 wan.youku.com#youku-area127.0.0.1 cms.laifeng.com127.0.0.1 ld.kuaigames.com127.0.0.1 rd.kuaigames.com127.0.0.1 g.x.cn.majorserving.com127.0.0.1 mon.majorserving.com127.0.0.1 l.ftx.fancyapi.com127.0.0.1 w.fancyapi.com127.0.0.1 l.fancyapi.com127.0.0.1 api.shuzilm.cn127.0.0.1 daa.shuzilm.cn127.0.0.1 www.shuzilm.cn127.0.0.1 cb.lomark.cn127.0.0.1 reply.lomark.cn127.0.0.1 rm.lomark.cn127.0.0.1 p-cn.acxiom-online.com127.0.0.1 hp.smiler-ad.com127.0.0.1 static8.pmadx.com127.0.0.1 www.bfshan.cn#miui-xiaomi127.0.0.1 api.ad.xiaomi.com127.0.0.1 cdn.ad.xiaomi.com127.0.0.1 e.ad.xiaomi.com127.0.0.1 log.ad.xiaomi.com127.0.0.1 new.api.ad.xiaomi.com127.0.0.1 sdkconfig.ad.xiaomi.com127.0.0.1 ssp.ad.xiaomi.com127.0.0.1 test.ad.xiaomi.com127.0.0.1 test.e.ad.xiaomi.com127.0.0.1 zeus.ad.xiaomi.com127.0.0.1 test.zeus.ad.xiaomi.com#miui-stat127.0.0.1 a.stat.xiaomi.com127.0.0.1 abtest.mistat.xiaomi.com127.0.0.1 data.mistat.xiaomi.com127.0.0.1 storeconfig.mistat.xiaomi.com#miui--1127.0.0.1 shenghuo.xiaomi.com#miui-download127.0.0.1 etl.xlmc.sandai.net#miui-file127.0.0.1 api.tw06.xlmc.sec.miui.com127.0.0.1 etl.xlmc.sec.miui.com127.0.0.1 fb.xk.miui.com#miui-game127.0.0.1 notice.game.xiaomi.com127.0.0.1 ppurifier.game.xiaomi.com#miui-sec127.0.0.1 adv.sec.miui.com127.0.0.1 tracking.miui.com127.0.0.1 beha.ksmobile.com127.0.0.1 up.cm.ksmobile.com#miui-weather127.0.0.1 wtradv.market.xiaomi.com#miui-wps127.0.0.1 cloudservice13.kingsoft-office-service.com127.0.0.1 counter.kingsoft.com127.0.0.1 event.ksosoft.com127.0.0.1 uid.ksosoft.com127.0.0.1 ups.ksmobile.net127.0.0.1 ws.ksmobile.net#mitv127.0.0.1 bss.pandora.xiaomi.com127.0.0.1 de.pandora.xiaomi.com127.0.0.1 dvb.pandora.xiaomi.com127.0.0.1 jellyfish.pandora.xiaomi.com127.0.0.1 stat.pandora.xiaomi.com127.0.0.1 irs01.com#http://app.pptv.com/pg_get_tv127.0.0.1 de.as.cp61.ott.cibntv.net127.0.0.1 clickc.admaster.com.cn127.0.0.1 vpptv.admaster.com.cn127.0.0.1 pptv.m.cn.miaozhen.com127.0.0.1 tpptv.ipdx.cn.miaozhen.com127.0.0.1 ads.aplus.pptv.com127.0.0.1 app.aplus.pptv.com127.0.0.1 as.aplus.pptv.com127.0.0.1 de.as.pptv.com127.0.0.1 img1.g.pptv.com127.0.0.1 img2.g.pptv.com127.0.0.1 img3.g.pptv.com127.0.0.1 jp.as.pptv.com127.0.0.1 static.g.pptv.com127.0.0.1 tj.g.pptv.com127.0.0.1 asimgs.pplive.cn127.0.0.1 ads.data.pplive.com127.0.0.1 gas.data.pplive.com127.0.0.1 plt.data.pplive.com127.0.0.1 web.data.pplive.com127.0.0.1 apm.suning.cn127.0.0.1 click.suning.cn127.0.0.1 dfp.suning.com127.0.0.1 ssac.suning.com#letv127.0.0.1 api.game.letvstore.com127.0.0.1 dev.dc.letv.com127.0.0.1 msg.m.letv.com127.0.0.1 n.mark.letv.com127.0.0.1 static.app.m.letv.com127.0.0.1 test.ark.letv.com#sohu-video127.0.0.1 agn.aty.sohu.com127.0.0.1 f.aty.sohu.com127.0.0.1 m.aty.sohu.com127.0.0.1 mmg.aty.sohu.com127.0.0.1 p.aty.sohu.com127.0.0.1 pg.aty.sohu.com127.0.0.1 pm.aty.sohu.com127.0.0.1 v.aty.sohu.com127.0.0.1 vg.aty.sohu.com127.0.0.1 vm.aty.sohu.com127.0.0.1 api.danmu.tv.sohu.com127.0.0.1 download.wan.sohu.com127.0.0.1 da.mmarket.com127.0.0.1 sohu.irs01.com#google ads127.0.0.1 googleads.g.doubleclick.net127.0.0.1 ads.nexage.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个在线的文件浏览器]]></title>
    <url>%2F2018%2F03%2F30%2Fh5ai%2F</url>
    <content type="text"><![CDATA[之前租的VPS过期了，折折腾腾，修修补补又换回搬瓦工，用上了久负盛名的CN2路线，表现比之前的digitalocean好多了，digitalocean的优势在于同时支持BBR和IPv6，搬瓦工这边BBR和IPv6只能二选一，虽然已经有在openVz上安装BBR的方法，但是效果并不是很好，今年翼讯升级了一下，比以往好用得多，于是选了有BBR的版本。有这样一个长期开机的东西，自然不会让它吃灰，，目前的打算是让它作为一个下载中转站，aria2开服下载，h5ai作为在线文件浏览器，抽空可以从VPS上高速把文件弄回来。 安装h5aih5ai是一个非常美观的目录列表程序，如上图，安装h5ai之后，可以实现在线的文件浏览，安装相应的依赖之后，可以在线预览文件，包括图片、视频和压缩包，可以说是相当的方便了，装在树莓派上的话，就可以让树莓派把视频下载好，直接观看了，不用传回电脑来。 安装准备提前安装好nginx（其实在装好PHP之后安装也是可以的） 12345yum install nginx -y #for CentOS# ORsudo apt install nginx #for Ubuntu/debian 安装PHPh5ai依赖于PHP运行，h5ai本身的安装并不复杂，就整个过程而言，复杂的是安装PHP，CentOS 7.4 所携带的PHP版本最高到 PHP 5.4， h5ai要求的PHP为5.5+，刚好不符合要求，下面先放安装PHP的过程。 在CentOS上安装PHP12345rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpmyum --enablerepo=remi,remi-php72 install nginx php-fpm php-commonyum --enablerepo=remi,remi-php72 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xmlservice php-fpm start 这里使用了第三方库，自行编译有很多需要配置的地方，很容易出错，尝试了很多次，总是有点毛病，还是回头用了这个办法。 在Ubuntu/debian上安装PHP在Ubuntu/debian上安装PHP相对来说方便得多了 12sudo apt update sudo apt install php-fpm -y 配置nginx向nginx的配置内的server段写入以下内容 123456location ~ \.php$ &#123; include /etc/nginx/fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;&#125; 并且更改index段内容为index index.html index.php /_h5ai/public/index.php;然后 12sudo nginx -tsudo nginx -s reload -t提示都OK的话，这个时候nginx已经能识别PHP了。 如果出现错误nginx: [error] invalid PID number &quot;&quot; in &quot;/usr/local/var/run/nginx/nginx.pid&quot;,那么使用命令 12sudo nginx -c /etc/nginx/nginx.confsudo nginx -s reload 这个时候PHP应该已经安装好并且已经启动了，到nginx的工作目录/var/www/html/或者/usr/share/nginx/html/（一般在这两个位置，），新建一个php文件，比如vim /usr/share/nginx/html/index.php，按I键进入编辑模式，添加以下内容 12&lt;?php phpinfo(); 这个时候，打开如下链接http://x.x.x.x/index.php(x.x.x.x是VPS的公网IP地址)，出现如下画面表示安装成功 安装h5ai到作者的网站下载源码包到nginx的工作目录并解压 123cd /usr/share/nginx/html #or use: cd /var/www/html/wget https://release.larsjung.de/h5ai/h5ai-0.29.0.zipunzip h5ai-0.29.0.zip 这个时候，访问http://x.x.x.x/_h5ai/public/index.php，出现如下画面表示h5ai安装成功 访问http://x.x.x.x/，可以看到nginx的工作目录里面的文件（PS：不能含有index.html,index.php） 安装aria2在Debian/Ubuntu上直接执行sudo apt-get install aria2就能安装好了，版本相对来说也较新，在Cent OS上可以执行sudo yum install aria2来安装，然而，一如既往的是老掉牙的版本，虽然说一味追求新版并无实在的意义，但是某些功能旧版本是没有的啊啊啊~~可以自己编译安装aria2 12345678910sudo apt-get install build-essential libgnutls-dev nettle-dev libgmp-dev libssh2-1-dev libc-ares-dev libxml2-dev zlib1g-dev libsqlite3-dev pkg-config -y # For Debian/Ubuntu# ORsudo yum groupinstall "Development Tools" -y &amp;&amp; yum install gnutls-devel nettle-devel gmp-devel libssh2-devel c-ares-devel libxml2-devel zlib-devel sqlite-devel pkgconfig libgcrypt-devel libssl-devel libtool autoconf automake autotools autopoint #For Centoswget https://github.com/aria2/aria2/releases/download/release-1.33.1/aria2-1.33.1.tar.gztar -zxf aria2-1.33.1.tar.gzcd aria2-1.33.1autoreconf -i./configure make sudo make install 在执行./configure的时候报的错误基本上都是缺少依赖，少谁装谁就好。静态编译参数./configure ARIA2_STATIC=yes编译出来的程序体积巨大，动态链接的程序只有2M+，静态编译出来之后达到75M+。 配置aria2可以参考https://blog.icehoney.me/posts/2015-01-31-Aria2-download，新建配置文件vim aria2c.conf，添加以下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#用户名#rpc-user=user#密码#rpc-passwd=passwd#上面的认证方式不建议使用,建议使用下面的token方式#设置加密的密钥#rpc-secret=token#允许rpcenable-rpc=true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all=true#允许外部访问，false的话只监听本地端口rpc-listen-all=true#RPC端口, 仅当默认端口被占用时修改#rpc-listen-port=6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads=5#断点续传continue=true#同服务器连接数max-connection-per-server=5#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size=10M#单文件最大线程数, 路由建议值: 5split=10#下载速度限制max-overall-download-limit=0#单文件速度限制max-download-limit=0#上传速度限制max-overall-upload-limit=0#单文件速度限制max-upload-limit=0#断开速度过慢的连接#lowest-speed-limit=0#验证用，需要1.16.1之后的release版本#referer=*#文件保存路径, 默认为当前启动位置dir=/home/acgotaku/Downloads#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache=0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap=true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc &lt;&lt; prealloc, falloc和trunc需要文件系统和内核支持file-allocation=prealloc 使用命令aria2c --conf-path aria2c.conf -D让aria2c后台运行，然后去往https://github.com/ziahamza/webui-aria2下载好整个仓库，双击indel.html，然后将设置/连接设置里面的主机设置为VPS的IP地址。 整个思路就是aria2c后台运行，本地的webui可以直接向VPS发出下载命令，下载好之后，打开h5ai的的页面查看文件，然后再从VPS上下载回本地。]]></content>
  </entry>
  <entry>
    <title><![CDATA[手动编译shadowsocks-libev]]></title>
    <url>%2F2018%2F03%2F16%2Fbuild-shadowsocks-libev%2F</url>
    <content type="text"><![CDATA[把树莓派的系统刷掉了，重新装了一些环境，shadowsocks-libev是比较活跃的分支，更新得较为频繁，在树莓派的官方源内的版本较低，这里记录一下安装过程。 为Linux编译下载123git clone https://github.com/shadowsocks/shadowsocks-libev.gitcd shadowsocks-libevgit submodule update --init --recursive 编译准备安装基本依赖环境1sudo apt-get install --no-install-recommends gettext build-essential autoconf libtool libpcre3-dev xmlto libev-dev libc-ares-dev automake libmbedtls-dev libsodium-dev 这里本该装asciidoc，但是它有1GB+，这对于树莓派来说已经是一个巨型软件了，所以没有装。 安装加密协议依赖包12345678910111213141516171819# Installation of Libsodiumexport LIBSODIUM_VER=1.0.13wget https://download.libsodium.org/libsodium/releases/libsodium-$LIBSODIUM_VER.tar.gztar xvf libsodium-$LIBSODIUM_VER.tar.gzpushd libsodium-$LIBSODIUM_VER./configure --prefix=/usr &amp;&amp; makesudo make installpopdsudo ldconfig# Installation of MbedTLSexport MBEDTLS_VER=2.6.0wget https://tls.mbed.org/download/mbedtls-$MBEDTLS_VER-gpl.tgztar xvf mbedtls-$MBEDTLS_VER-gpl.tgzpushd mbedtls-$MBEDTLS_VERmake SHARED=1 CFLAGS=-fPICsudo make DESTDIR=/usr installpopdsudo ldconfig 编译12./configure --disable-documentationmake -j4 参数--disable-documentation是在没有安装asciidoc的情况下使用的，编译完成后可以在src目录里面找到它们。 为 Windows 编译在Windows上编译在 Windows 上的编译步骤很少，但是不太好实现。很多时候都会因为网络原因中断。方法如下：到https://www.docker.com/下载Docker安装。然后将shadowsocks项目克隆到本地，再双击docker\mingw内的make.bat，等待编译完成就好。不过得实现配置好MinGW的环境。这里提供已经编译好的Windows程序https://github.com/BDZNH/shadowsocks-libev/releases 在Linux上编译docker在Windows上的安装步骤稍微麻烦一些，在Linux上安装就方便得多了。 1sudo yum install docker 或者 1sudo apt-get install docker.io 安装好docker之后，使用命令 1service docker start 启动docker，然后到Shaodwoskcs的docker/mingw目录下面运行make命令，等待完成就好，优势在于可以在VPS上运行，不用顾及网络。]]></content>
  </entry>
  <entry>
    <title><![CDATA[小米路由器与IPv6]]></title>
    <url>%2F2018%2F03%2F02%2FIPv6-For-xiaomi-nano-router%2F</url>
    <content type="text"><![CDATA[西电的校园网拨号之后可以获取到IPv6地址，刷了op的路由器也可以获取到IPv6地址，但是后端设备想要获取到IPv6地址还得再折腾一下。手里的设备是小米路由器青春版。 将小米路由器刷成op，得给它换一个bootloader，这里使用的是breed，可以参考链接http://www.v5china.com/xiaomi-router-youth-version-of-breed-after-the-brush-brush-into-asus-firmware-tutorial.html，进行到该文章的第七步即可。下载lede固件https://downloads.lede-project.org/releases/17.01.4/targets/ramips/mt7628/lede-17.01.4-ramips-mt7628-miwifi-nano-squashfs-sysupgrade.bin，模仿第八步，为小米路由器安装lede固件。开机之后，第一次连接会提示设置登录密码（使用网线，lede固件默认不开启WiFi），在network-&gt;&gt;interface-&gt;&gt;wan处可以设置路由器的联网方式，确保路由器能联网之后，使用putty登录路由器12opkg updateopkg install luci-i18n-base-zh-cn 安装好中文语言包1opkg install kmod-ipt-nat6 安装nat6模块1234567echo "net.ipv6.conf.default.accept_ra=2" &gt;&gt; /etc/sysctl.confecho "net.ipv6.conf.all.accept_ra=2" &gt;&gt; /etc/sysctl.confuci set network.globals.ula_prefix="$(uci get network.globals.ula_prefix | sed 's/^./d/')"uci commit networkuci set dhcp.lan.ra_default='1'uci commit dhcp 配置网络在/etc/init.d/目录下新建一个文件，向文件内写入123#!/bin/baship6tables -t nat -I POSTROUTING -s `uci get network.globals.ula_prefix` -j MASQUERADEroute -A inet6 add 2000::/3 `route -A inet6 | grep ::/0 | awk 'NR==1&#123;print "gw "$2" dev "$7&#125;'` 应用文件并重启，通过WiFi和网线连接到路由器的设备可以获取IPv6地址。 乱七八糟查看lede固件完整的支持列表：https://wiki.openwrt.org/toh/views/toh_extended_all bootloader换bootloader的原因是，路由器本身的bootloader不支持安装lede固件，就像给手机刷机需要更换recovery一样 失败的例子从大一就开始尝试，一开始刷的的原版的openwrt，刷完之后根本无法开机，后来尝试了pandorabox，路由器能获取到IPv6地址，但是安装好nat6模块，执行命令转发时失败，内核不支持，辗转到了lede固件，貌似现在lede固件已经是openwrt的官方固件了，官网合并了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[作品推荐《我的三体》]]></title>
    <url>%2F2018%2F02%2F27%2FThe-three-body-problem%2F</url>
    <content type="text"><![CDATA[BiliBili的up主神游八方的作品，还原度很高，第一季是很典型的摆拍型，MC气息很浓啊，第二季质量就非常高了，超赞！ 附带三个童话故事 王国的新画师很久很久以前，有一个王国叫无故事王国，它一直没有故事。其实对于一个王国而言，没有故事是最好的，没有故事的国王中的人民是最幸福的，因为故事就意味着曲折和灾难。无故事王国有一个贤明的国王、一个善良的王后和一群正直能干的大臣，还有勤劳朴实的人民。王国的生活像镜而一样平静，昨天像今天，今天像明天，去年像今年，今年像明年，一直没有故事。直到王子和公主长大。国王有两个儿子，分别是深水王子和冰沙王子，还有一个女儿：露珠公主。深水王子小时候去了饕餮海中的墓岛上，再也没有回来，原因后面再讲。冰沙王子在父王和母后身边长大，但也让他们深深忧虑。这孩子很聪明，但从小就显示出暴虐的品性。他让仆役们从王宫外搜集许多小动物，他就和这些小动物玩帝国游戏，他自封为皇帝，小动物们为臣民，臣民们都是奴隶，稍有不从就砍头，往往游戏结束时小动物们都被杀了，冰沙就站在一地鲜血中狂笑不已……王子长大后性格收敛了一些，变得沉默寡言，目光阴沉。国王知道这只是狼藏起了撩牙，冰沙心中有一窝冬眠的毒蛇，在等待着苏醒的机会。国王终于决定取消冰沙王子的王位继承权，由露珠公主继承王位，无故事王国在未来将有一位女王。假如父王和母后传给后代的美德是有一个定量的，那冰沙王子缺少的部分一定都给了露珠公主。公主聪明善良，且无与伦比地美丽，她在白天出来太阳会收敛光辉，她在夜晚散步月亮会睁大眼睛，她一说话百鸟会停止鸣唱，她踏过的荒地会长出绚丽的花朵。露珠成为女王必定为万民拥戴，大臣们也会全力辅佐，就连冰沙王子对此也没有说什么，只是目光更阴沉了。于是，无故事王国有了故事。国王是在他的六十寿辰这一天正式宣布这一决定的。在这个庆典之夜，夜空被焰火装点成流光溢彩的花园，灿烂的灯火几乎把王宫照成透明的水晶宫殿，在欢歌笑语中，美酒如河水般流淌……每一个人都沉浸在幸福快乐中，连冰沙王子那颗冰冷的心似乎也被融化，他一改往日的阴沉，恭顺地向父王祝寿，愿他的生命之光像太阳一样永远照耀王国。他还赞颂父王的决定，说露珠公主确实比自己更适合成为君主。他祝福妹妹，希望她多多向父王学习治国本领，以备将来担当重任。他的真诚和善意让所有的人为之动容。“吾儿，看到你这样我真是高兴。”国王抚着王子的头说，“真想永远留住这美好的时光。”于是有大臣建议，应该制作一幅巨型油画，把庆典的场景画下来，挂在宫殿中以资纪念。国王摇摇头，“我的画师老了，世界在他昏花的老眼中已蒙上了雾霭，他颇抖的老手已绘不出我们幸福的笑容。”“我正要说这个，”冰沙王子对国王深深鞠躬，“我的父王，我正要献给您一位新画师。”王子说完对后面示意了一下，新画师立刻走了进来。这是一个大男孩，看上去也就十四五岁的样子，裹着一件修士的灰色斗篷，在这金碧辉煌的宫殿和珠光宝气的宾客中像一只惊恐的小老鼠。他走路时，已经很瘦小的身子紧缩成一根树枝一般，仿佛时时躲避着身边看不见的荆刺。国王看着眼前的画师显得有些失望，“他这么年轻，能掌握那高深的技巧吗?”王子再次鞠躬，“我的父王，他叫针眼，从赫尔辛根默斯肯来，是空灵大画师最好的学生。他自五岁起就跟大画师学画，现已学了十年，深得空灵画师的真传。他对世界的色彩和形状，就像我们对烧红的烙铁一样敏感，这种感觉通过他如神的画笔凝固在画布上，除了空灵画师，他举世无双。”王子转向针眼画师，“作为画师，你可以直视国王，不算无礼。”针眼画师抬头看了一眼国王，立刻又低下了头。国王有些吃惊，“孩子，你的目光很锐利，像烈焰旁出鞘的牙剑，与你的年龄极不相称。”针眼画师第一次说话了：“至高无上的国王，请宽怒一个卑微画师的冒犯。这是一个画师的眼睛，他要先在心里绘画，我已经把您，还有您的威严和贤明一起画在心里，我会画到画里的。”“你也可以看王后。”王子说。针眼画师看了一眼王后，低下头说：“最最尊敬的王后，请宽怒一个卑微画师的冒犯，我已经把您，还有您的高贵和典维一起画在心里，我会画到画里的。”“再看看公主，未来的女王，你也要画她。”针眼画师看露珠公主的时间更短，如闪电般看了一眼后就低头说：”最最受人景仰的公主，请宽怒一个卑微画师的冒犯。您的美丽像正午的阳光刺伤了我，我第一次感到了自己画笔的无力，但我已经把您，还有您无与伦比的美丽一起画在心里，我会画到画里的。”然后王子又让针眼画师看看大臣们。他挨着看了，目光在每个人的身上只停留一瞬间，最后低下头说：“最最尊敬的大人们，请宽怒一个卑微画师的冒犯。我已经把你们，还有你们的才能和智慧一起画在心里，我会画到画里的。”盛宴继续进行，冰沙王子把针眼画师拉到宫殿的一个角落，低声问道：“都记住了吗?”针眼画师头低低的，脸全部隐藏在斗篷帽的阴影里，使那件斗篷看上去仿佛是空的，里面只有黑影没有躯体。“记住了，我的王。”“全记住了?”“我的王，全记住了，即使给他们每人的每根头发和汗毛各单画一幅特写，我都能画得真真切切分毫不差。”宴会到后半夜才结束，王宫中的灯火渐渐熄灭。这正是黎明前最黑暗的时候，月亮已经西沉，乌云自西向东，像帷幕一样遮住了夜空，大地像是浸在墨汁中一般。一阵阴冷的寒风吹来，鸟儿在巢中颤抖，花儿惊惧地合上了花瓣。有两匹快马像幽灵一般出了王宫，向西方奔驰而去，骑在马上的分别是冰沙王子和针眼画师。他们来到了距王宫十多里的一处幽深的地堡中。这里处于夜之海的最深处，潮湿阴森，像一个沉睡着的冷血巨怪的腹腔。两人的影子在火炬的光芒中摇曳，他们的身躯只是那长长影子末端的两个黑点。针眼画师拆开一幅画，那画有一人高，他把包画的帆布掀开后让王子看。这是一位老人的肖像，老人的白发和白须像银色的火焰包围着头脸，他的眼神很像针眼画师，但锐利中多了一份深沉，这画显示出画师高超的技艺，纤毫毕现，栩栩如生。“我的王，这是我的老师，空灵大画师。”王子打量着画，点点头说：“你先把他画出来是明智的。”“是的，我的王，以免他先把我画出来。”针眼画师说着，小心翼冀地把画挂到潮湿的墙上，“好了，我现在可以为您做新画了。”针眼画师从地堡的一个暗角抱出一卷雪白的东西，“我的王，这是赫尔辛根默斯肯的雪浪树的树干，这树百年长成后，它的树干就是一大卷纸，上好的画纸啊!我的画只有画在雪浪纸上才有魔力。”他把树干纸卷放到一张石桌上，拉出一段纸来，压在一大块黑曜石石板下，然后用一把锋利的小匕首沿石板把压着的纸切下，掀开石板后，那张纸已经平平展展地铺在石桌上，它一片雪白，仿佛自己会发光似的。然后画师从帆布包中拿出各种绘画工具，“我的王，看这些画笔，是用赫尔辛根默斯肯的狼的耳毛做的。这几罐颜料也都来自赫尔辛根默斯肯，这罐红的，是那里巨编蝠的血;黑的，是那里深海乌贼的墨汁;蓝的和黄的，都是从那里的古老陨石中提取的……这些都要用一种叫月毯的大鸟的眼泪来调和。”“赶快画画吧。”王子不耐烦地说。“好的，我的王，先画谁呢?”“国王。”针眼画师拿起画笔开始作画。他画得很随意，用不同的色彩这里点一点，那里画一道，画纸上的色彩渐渐多了起来，但看不出任何形状，就像把画纸暴露在一场彩色的雨中，五彩的雨滴不断滴到纸面上。画面渐渐被色彩填满，一片纷繁迷乱的色彩，像被马群践踏的花园。画笔继续在这色彩的迷宫中游走，仿佛不是画师在运笔，而是画笔牵着他的手游移。王子在旁边疑惑地看着，他想提问，但画面上色彩的涌现和聚集有一种作用，让他着迷。突然，几乎是在一瞬间，就像波光粼粼的水面被冻祥，所有的色块都有了联系，所有的色彩都有了意义，形状出现了，并很快变得精细清晰。王子现在看到，针眼画师画的确实是国王，画面上的国王就是他在宴会上看到的装束，头戴金色的王冠，身穿华丽的礼服，但表情大不相同，国王的目光中没有了威严和睿智，而是透出一种极其复杂的东西，如梦初醒、迷惑、震惊、悲哀……藏在这一切后面的是来不及浮现的巨大恐俱，就像看到自己最亲密的人突然拔剑刺来的那一瞬间。“我的王，画完了，我把国王画到画里了。”针眼画师说。“你把他画到画里了，很好。”王子看着国王的画像满意地点点头，他的眸子中映着火把的火光，像灵魂在深井中燃烧。在十几里外的王宫中，在国王的寝室里，国王消失了。在那张床腿是四个天神雕像的大床上，被褥还有他身体的余温，床单上还有他压出的凹印，但他的躯体消失得无影无踪。王子把已完成的画从石桌上拿起扔到地上，“我会把这幅画装裱起来，挂在这里的墙上，没事的时候经常来看一看。下面画王后吧。”针眼画师又用黑曜石石板压平了一张雪浪纸，开始画王后的肖像。这次王子没有站在旁边看，而是来回踱步，空旷的地堡中回荡着单调的脚步声。这次画师作画的速度更快，只用了画上幅画一半的时间就完成了。“我的王，画完了，我把王后画到画里了。”“你把她画到画里了，很好。”在王宫中，在王后的寝室里，王后消失了。在那张床腿是四个天使雕像的大床上，被褥还有她身体的余温，床单上还有她压出的凹印，但她的躯体消失得无影无踪。在宫殿外面的深院中，一只狼犬觉察到了什么，狂吠了几声，但它的叫声立刻被无边的黑暗吞没，它自己也在前所未有的恐惧中沉默了，缩到角落不住地颤抖着，与黑暗融为一体。“该画公主了吧？”针眼画师问。“不，等画完了大臣们再画她，大臣们比她危险。当然，只画那些忠于国王的大臣，你应该记得他们的样子吧?”“当然.我的王，全记住了，即使给他们每人的每根头发和汗毛各画一幅特写……”“好了，快画吧，天亮前画完。”“没问题，我的王，天亮前我会把忠于国王的大臣，还有公主，都画到画里。”针眼画师一次压平了好几张雪浪纸，开始疯狂作画。他每完成一幅画，画中的人就从睡榻上消失。随着黑夜的流逝，冰沙王子要消灭的人一个接一个变成了挂在地堡墙上的画像。露珠公主在睡梦中被一阵敲门声惊醒，那声音又急又响，从来没有人敢这样敲她的门。她从床上起身，来到门前时看到宽姨已经把门打开了。宽姨是露珠的奶妈，一直照顾她长大，公主与她建立的亲情甚至超过了生母王后。宽姨看到门外站着王宫的卫队长，他的盔甲还带着外面暗夜的寒气。“你太无礼了!竟敢吵醒公主？！她这几天一直失眠睡不好觉!”卫队长没有理会宽姨的责骂，只是向公主匆匆敬礼，“公主，有人要见你!”然后闪到一边，露出他身后的人，那是一位老者，白发和白须像银色的火焰包围着头脸，他的目光锐利而深沉，他就是针眼画师向王子展示的第一幅画中的人。他的脸上和斗篷上满是尘土，靴覆满泥巴，显然是长途跋涉而来。他背着一个硕大的帆布袋，但奇怪的是打着一把伞，更奇怪的是他打伞的方式：一直不停地转动着伞。细看一下伞的结构，就知道他这样做的原因：那把伞的伞面和伞柄都足乌黑色，每根伞骨的末端都固定着一只小圆球，是某种半透明的石头做成的，有一定重量。可以看到伞里面几根伞撑都折断了，无法把全伞撑起来，只有让伞不断转动，把伞骨末端的小石球甩起来，才能把伞撑开。“你怎么随便让外人进来，还是这么个怪老头?!”宽姨指着老者责问道。“哨兵当然没让他进王宫，但他说……”卫队长忧虑地看了一眼公主，“他说国王已经没了。”“你在说什么?!你疯了吗?”宽姨大喊，公主仍没有做声，只是双手抓紧了胸前的睡袍。“但国王确实不见了，王后也不见了，我派人看过，他们的寝室都是空的。”公主短促地惊叫了一声，一手扶住宽姨好让自己站稳。老者开口了：“尊敬的公主，请允许我把事情说清楚。”“让老人家进来，你守在门口。”公主对卫队长说。老者转着伞，对公主鞠躬，似乎对于公主能够这么快镇静下来心存敬意。“你转那把伞干什么?你是马戏团的小丑吗?”宽姨说。“我必须一直打着这把伞，否则也会像，国王和王后一样消失。”“那就打着伞进来吧。”公主说，宽姨把门大开，以便让老者举伞通过。老者进入房间后，把肩上的帆布袋放到地毯上，疲惫地长出一口气，但仍转着黑伞，伞沿的小石球在烛光中闪亮，在周围的墙壁上投映出一圈旋转的星光。“我是赫尔辛根默斯肯的空灵画师，王宫里新来的那个针眼画师是我的学生。”老者说。“我见过他。”公主点点头说。“那他见过你吗?他看过你吗?”空灵画师紧张地问。“是的，他当然看过我。”“糟透了，我的公主，那糟透了!”空灵画师长叹一声，“他是个魔鬼，掌握着魔鬼的画技，他能把人画到画里。”“真是废话!”宽姨说，“不能把人画到画里那叫画师吗?”空灵画师摇摇头，“不是那个意思，他把人画到画里后，人在外面就没了，人变成了死的画。”“那还不快派人找到他杀了他?!”卫队长从门外探进头来说：“我派全部的卫队去找了，找不到。我原想去找军机大臣，他可以出动王宫外的禁卫军搜查，可这个老人家说军机大臣此时大概也没了。”空灵画师又摇摇头，“禁卫军没有用，冰沙王子和针眼可能根本就不在王宫里，针眼在世界上任何地方作画，都能杀掉王宫中的人。”“你说冰沙王子?”宽姨问。“是的，王子要以针眼画师作武器，除掉国王和忠诚于他的人，夺取王位。”空灵画师看到，公主、宽姨和门口的卫队长对他的话似乎都没感到意外。“还是先考虑眼前的生死大事吧!针眼随时可能把公主画出来，他可能已经在画了。”宽姨大惊失色，她一把抱住公主，似乎这样就能保护她。空灵画师接着说：“只有我能除掉针眼，现在他已经把我画出来了，但这把伞能保护我不消失，我只要把他画出来，他就没了。”“那你就在这里画吧!”宽姨说，“让我替你打伞!”空灵画师又摇摇头，“不行，我的画只有画在雪浪纸上才有魔力，我带来的纸还没有压平，不能作画。”宽姨立刻打开画师的帆布包，从中取出一截雪浪树的树干，树干已经刮了外皮，露出白花花的纸卷来。宽姨和公主从树干纸卷上抽出一段纸，纸面现出一片雪白，房间里霎时亮了许多。她们试图在地板上把纸压平•但不管怎样努力，只要一松手，那段纸就弹回原状又卷了回去。画师说：“不行的，只有赫尔辛根默斯肯的黑曜石石板才能压平雪浪纸，那种黑曜石石板很稀有，我只有一块，让针眼偷走了!”“这纸用别的东西真的弄不平吗?”“弄不平的，只有用赫尔辛根默斯肯的黑曜石石板才能压平，我本来是希望能够从针眼那里夺回它的。”“赫尔辛根默斯肯的黑曜石?”宽姨一拍脑袋，“我有一个熨斗，只在熨公主最好的晚礼服时才用，就是赫尔辛根默斯肯出产的，是黑曜石!”“也许能用。”空灵画师点点头。宽姨转身跑出去，很快拿着一个乌黑银亮的熨斗进来了。她和公主再次把雪浪纸从纸卷中拉出一段，用熨斗在地板上压住纸的一角，压了几秒钟后松开，那一角的纸果然压平了。“你来给我打伞，我来压!”空灵画师对宽姨说。在把伞递给她的时候，他嘱咐道，“这伞要一直转着打开，一合上我就没了!”看到宽姨把伞继续旋转着打开举在他的头顶，他才放心地蹲下用熨斗压纸，只能一小块一小块地挨着压。“不能给这伞做个伞撑吗?”公主看着旋转的伞问。“我的公主，以前是有伞撑的。”空灵画师边埋头用熨斗压纸边说，“这把黑伞的来历很不寻常。从前，赫尔辛根默斯肯的其他画师也有这种画技，除了人，他们也能把动物和植物画到画里。但有一天，飞来了一条渊龙，那龙通体鸟黑，既能弃深海潜游，又能在高空飞翔，先后有三个大画师画下了它，但它仍然在画外潜游和飞翔。后来，画师们筹钱雇了一名魔法武士，武士用火剑杀死了渊龙，那场搏杀使赫尔辛根默斯肯的大海都沸腾了。渊龙的尸体大部分都被烧焦了，我就从灰堆中收集了少量残骸，制成了这把伞。伞面是用渊龙的翼膜做的，伞骨、伞柄和伞撑都是用它的乌骨做成，伞沿的那些宝石，其实是从渊龙已经烧焦的肾中取出的结石。这把伞能够保护打着它的人不被画到画里。后来伞骨断了，我曾用几根竹棍做了伞撑，但发现伞的魔力竟消失了，拆去新伞撑后，魔力又恢复了。后来试验用手在里面撑开伞也不行，伞中是不能加入任何异物的，可我现在已经没有渊龙的骨头了，只能这样打开伞……”这时房间一角的钟敲响了，空灵画师抬头看看，已是凌晨，天快亮了。他再看看雪浪纸，压平的一段从纸卷中伸了出来，平铺在地板上不再卷回去，但只有一掌宽的一条，远不够绘一幅画的。他扔下熨斗，长叹一声。“来不及了，我画出画来还需要不少时间，来不及了，针眼随时会画完公主，你们——”空灵画师指指宽姨和卫队长，“针眼见过你们吗?”“他肯定没见过我。”宽姨说。“他进王宫时我远远地看到过他，但我想他应该没看见我。”卫队长说。“很好，”空灵画师站起身来，“你们俩护送公主去饕餮海，去墓岛找深水王子!”“可……即使到了饕餮海，我们也上不了墓岛的，你知道海里有……”“到了再想办法吧，只有这一条生路了。天一亮，所有忠于国王的大臣都会被画到画里，禁卫军将被冰沙控制，他将篡夺王位，只有深水王子能制止他。”“深水王子回到王宫，不是也会被针眼画到画里吗?”会主问。“放心，不会的，针眼画不出深水王子。深水是王国中针眼唯一画不出来的人，很幸运，我只教过针眼西洋画派，没有向他传授东方画派。”公主和其他两人都不太明白空灵画师的话，但老画师没有进一步解释，只是继续说：“你们一定要让深水回到王宫，杀掉针眼，并找到公主的画像，烧掉那幅画，公主就安全了。”“如果也能找到父王和母后的画像……”公主拉住空灵画师急切地说。老画师缓缓地摇摇头，“我的公主，来不及了，他们已经没有了，他们现在就是那两幅画像了，如果找到不要毁掉，留作祭奠吧。”露珠公主被巨大的悲痛压倒，她跌坐在地上掩面痛哭起来。“我的公主，现在不是哀伤的时候，要想为国王和王后复仇，就赶快上路吧!”老画师说着，转向宽姨和卫队长，“你们要注意，在找到并毁掉公主的画像之前，伞要一直给她打着，一刻都不能离开.也不能合上。”他把伞从宽姨手中拿过来，继续转动着，“伞不能转得太慢，那样它就会合上，也不能太快，因为这伞年代已久，转得太快会散架的。黑伞有灵气，如果转得慢了，它会发出像鸟叫的声音，你们听，就足这样子——”老画师把伞转慢了些.伞面在边缘那些石球的重量下慢慢下垂，这时能听到它发出像夜莺一样的叫声，伞转得越慢声音越大。老画师重新加快了转伞的速度，鸟鸣声变小消失了。“如果转得太快，它会发出铃声，就像这样——”老画师继续加快转伞的速度，能听到一阵由小到大的铃声，像风铃，但更急促，“好了，现在快把伞给公主打上。”他说着，把伞又递给宽姨。“老人家，我们俩一起打伞走吧。”露珠公主抬起泪眼说。“不行，黑伞只能保护一个人，如果两个被针眼画出的人一起打伞，那他们都会死，而且死得更惨：每个人的一半被画入画中，一半留在外面……快给公主打伞，拖延一刻危险就大一分，针眼随时可能把她画出来!”宽姨看看公主，又看看空灵画师，犹豫着。老画师说：“是我把这画技传授给那个孽种，我该当此罪。你还等什么？想看着公主在你面前消失?!”最后一句话令宽姨颤抖了一下，她立刻把伞移到公主上方。老画师抚着白须从容地笑起来，“这就对了，老夫绘画一生，变成一幅画也算死得其所。我相信那个孽种的技艺，那会是一幅精致好画的……”空灵大画师的身体渐渐变得透明，然后像雾气一般消失了。露珠公主看着老画师消失的那片空间，喃喃地说：“好吧，我们走，去饕餮海。”宽姨对门口的卫队长说：“你快过来给公主打伞，我去收拾一下。”卫队长接过伞后说：“要快些，现在外面都是冰沙王子的人了，天亮后我们可能出不了王宫。”“可我总得给公主带些东西，她从来没有出过远门，我要带她的斗篷和靴子，她的好多衣服，她喝的水，至少……至少要带上那块赫尔辛根默斯肯出产的好香皂，公主只有用那香皂洗澡才能睡着觉……”宽姨唠唠叨叨地走出房间。半个小时后，在初露的曙光中，一辆轻便马车从一个侧门驶出王宫，卫队长赶着车，车上坐着露珠公主和给她打伞的宽姨，他们都换上了平民装束。马车很快消失在远方的雾霭中。这时，在那个阴森的地堡中，针眼画师刚刚完成露珠公主的画像，他对冰沙王子说，这是他画过的最美的一幅画。 饕餮海出了王宫后，卫队长驾车一路狂奔。三个人都很紧张，他们感觉在未尽的夜色里，影影绰绰掠过的树木和田野中充满危险。天亮了一些后，车驶上了一个小山冈，卫队长勒住马，他们向来路眺望。王国的大地在他们下面铺展开未，他们来的路像一条把世界分成两部分的长线，线的尽头是王宫，已远在天边，像被遗失在远方的一小堆积木玩具。没有看到追兵，显然冰沙王子认为公主已经不存在了，被画到了画中。以后他们可以从容地赶路了。在天亮的过程中，周围的世界就像是一幅正在绘制中的画，开始只有朦胧的轮廓和模糊的色彩，后来，景物的形状和线条渐渐清晰精细，色彩也丰富明快起来。在太阳升起前的一刹那，这幅画已经完成。常年深居王宫的公主从来没有见过这祥大块大块的鲜艳色彩：森林草地和田野的大片绿色、花丛的大片鲜红和嫩黄、湖泊倒映着的清晨天空的银色、早出的羊群的雪白……太阳升起时，仿佛绘制这幅画的画师抓起一把金粉豪爽地撒向整个画面。“外面真好，我们好像已经在画中呢。”公主赞叹道。“是啊，公主，可在这幅画里你活着，在那幅画中你就死了。”打伞的宽姨说。这话又让公主想起了已经离去的父王和母后，但她抑制住了眼泪，她知道自己现在再也不是一个小女孩.她应该担当起国王的重任了。他们谈起了深水王子。“他为什么被流放到墓岛上?”公主问。“人们都说他是怪物。”卫队长说。“深水王子不是怪物!”宽姨反驳道。“人们说他是巨人。”“深水不是巨人!他小的时候我还抱过他，他不是巨人。”“等我们到海边你就会看到的，他肯定是巨人，好多人都看到了。”“就算深水是巨人，他也是王子，为什么要流放到岛上?”公主问。“他没有被流放，他小时候坐船去墓岛上钓鱼，正好那时饕餮鱼在海上出现，他就回不来了，只好在岛上长大。”……太阳升起后，路上的行人和马车渐渐多起来。由于公主以前几乎没有出过王宫，所以人们都不认识她，但尽管她现在还戴着面纱，只露出两只眼睛，看到她的人仍惊叹她的美丽。人们也称赞驾车的小伙子的孔武英俊，笑话那个老妈妈为她的美丽女儿打着的那把奇怪的伞和她那奇怪的打伞方式。好在没有人质疑伞的用途，今天阳光灿烂，人们都以为这是遮阳伞。不知不觉到了中午，卫队长用弓箭射了两只兔子做午餐。三人坐在路边树丛间的空地上吃饭。露珠公主摸着身旁柔软的草地，嗅着青草和鲜花的清香，看着阳光透过树叶投在草地上的光斑，听着林中的鸟鸣和远处牧童的笛声，对这个新世界充满了好奇和惊喜。宽姨却长叹一声，“唉，公主啊，离开王宫这么远，真让你受罪了。”“我觉得外面比王宫好。”公主说。“我的公主哇，外面哪有王宫里好?你真是不知道，外面有很多难处呢，现在是春天，冬天外面会冷，夏天会热，外面会刮风下雨，外面什么样的人都有，外面……”“可我以前对外面什么都不知道。我在王宫里学音乐，学绘画，学诗歌和算术，还学着两种谁都不说的语言，可没人告诉我外面是什么样子，我这样怎么能统治王国呢?”“公主，大臣们会帮你的。”“能帮我的大臣都被画到画里了……我还是觉得外面好。”从王宫到海边有一个白天的路程，但公主一行不敢走大道，遇到城镇就绕开，所以直到半夜才到达。露珠公主从来没有见过这样广阔的星空，也第一次领略了夜的黑暗和寂静，车上的火把只能照亮周围一小块地方。再往远处，世界就是一大块模糊的黑天鹅绒。马蹄声很响，像要把星星震下来。公主突然拉住卫队长，让他把马车停下。“听，这是什么声音？像巨人的呼吸。”“公主，这是海的声音。”又前行了一段，公主看到两旁有许多在夜色中隐约可见的物体，像一根根大香蕉。“那些是什么?”她问。卫队长又停下车，取下车上的火把走到最近的一个旁边，“公主，你应该认识这个的。”“船?”“是的，公主，是船。”“可船为什么在陆地上？”“因为海里有饕餮鱼。”在火把的光芒中可以看到，这艘船已经很旧了，船身被沙子埋住一半，露在外面的部分像巨兽的白骨。“啊，看那里!”公主又指着前方惊叫，“好像有一条白色的大蛇!”“不要怕公主，那不是蛇，是海浪，我们到海边了。”公主和为她打伞的宽姨一起下车，她看到了大海。她以前只在画中见过海，那画的是蓝天下的蓝色海洋，与这夜空下的黑色海洋完全不同这泛着星光的博大与神秘，仿佛是另一个液态的星空。公主不由自主地向海走去，却被卫队长和宽姨拦住了。“公主，离海太近危险。”卫队长说。“我看前面水不深，能淹死我吗?”公主指指沙滩上的白浪说。“海里有饕餮鱼，它们会把你撕碎吃掉的！”宽姨说。卫队长拾起一块破船板，走上前去把船板扔到海中。船板在海面晃荡了儿下，很快附近一个黑影浮出水面向它扑去，由于大部分在水下，看不出那东西的大小、它身上的鳞片在火把的光中闪亮。紧接着又有三四个黑影飞快地游向船板，在水中争抢成一团，伴随着哗哗的水声，可以听到利齿发出的咔嚓咔嚓声，仅一转眼的工夫，黑影和船板都不见了。“看到了吗?它们能在很短的时间里把一艘大船咬成碎片。”卫队长说。“墓岛呢?”宽姨问。“在那个方向，”卫队长指指黑暗的水天相连处，“夜里看不见，天一亮就能看见。”他们在沙滩上露营。宽姨把伞交给卫队长打，从马车上拿下一个小木盆。“公主呀，今天是不能洗澡了，可你至少该洗洗脸的。”卫队长把伞交还给宽姨，说他去找水，就拿着盆消失在夜色中。“他是个好小伙子。”宽姨打着哈欠说。卫队长很快回来，不知从什么地方打来了一盆清水。宽姨为公主洗脸，她拿一块香皂在水中只蘸了一下，一声轻微的吱啦声后，盆面立刻堆满了雪白的泡沫，鼓出圆圆的一团，还不断地从盆沿溢出来。卫队长盯着泡沫看了一会儿，对宽姨说：“让我看看那块香皂。”宽姨从包裹中小心翼冀地拿出一块雪白的香皂，递给卫队长，“拿好了，它比羽毛还轻，一点儿分量都没有，一松手就飘走了。”卫队长接过香皂，真的感觉不到一点儿分量，像拿着一团白色的影子。“这还真是赫尔辛根默斯肯香皂，现在还有这东西?”“我只有两块了，整个王宫，我想整个王国，也只剩这最后两块了，是我早些年特意给公主留的。唉，赫尔辛根默斯肯的东西都是好东西，可惜现在越来越少了。”宽姨说着，把香皂拿回来小心地放回包裹中。看着那团白泡沫，公主在出行后第一次回忆起王宫中的生活。每天晚上，在她那精美华丽的浴宫中，大浴池上就浮着一大团这样的泡沫，灯光从不同方向照来，大团泡沫忽而雪白，像从白天的天空中抓来的一朵云;忽而变幻出宽彩，像宝石堆成的，泡到那团泡沫中，公主会感到身体变得面条般柔软，感到自己在融化，成了泡沫的一部分，那舒服的感觉让她再也不想动弹，只能由女仆把她抱出去擦干，再抱她去床上睡觉。那种美妙的感觉可以一直持续到第二天早晨。现在，公主用赫尔辛根默斯肯香皂洗过的脸很轻松很柔软，身上却僵硬而疲劳。随便吃了些东西后，她便在沙滩上躺下，开始时铺了一张毯子，后来发现直接躺到沙上更舒服。柔软的沙层带着白天阳光的温度，她感觉像被一只温暖的大手捧在手心，涛声像催眠曲，她很快睡着了。不知过了多长时间，露珠公主被一阵铃声从无梦的酣睡中惊醒，那声音是从她上方旋转的黑伞中发出的。宽姨睡在她旁边，打伞的是卫队长，火把已经熄灭，夜色像天鹅绒般笼罩着一切，卫队长是星空背景前的一个剪影，只有他的盔甲映出星光，还可以看到海风吹起他的头发。伞在他的手中稳撼地旋转着，像一个小小的穹顶遮住了一半夜空。她看不见他的眼睛，但能感觉到他的目光，他与无数眨眼的星星一起看着自己。“对不起公主，我刚才转得太快了。”卫队长低声说。“现在什么时间了?”“后半夜了。”“我们离海好像远了。”“公主，这是退潮海水后退了，明天早上还会涨起来。”“你们轮流为我打伞吗?”“是的，公主，宽姨打了一白天，我夜里多打一会儿。”“你也驾了一天车，让我自己打一会儿伞，你也睡吧。”说出这话后，露珠公主自己也有些吃惊，在她的记忆里，这是自己第一次为别人着想。“那不行，公主，你的手那么细嫩，会磨起泡的，还是让我为你打伞吧。”“你叫什么名字?”同行已经一天，她现在才问他的名字。放在以前她会觉得很正常，甚至永远不问都很正常，但现在她为此有些内疚。“我叫长帆。”“帆？”公主转头看看，他们现在是在沙滩上的一艘大船旁边，这里可以避海风。与其他那些搁浅在海滩上的船不同，这艘船的桅杆还在，像一把指向星空的长剑。“帆是不是挂在这根长杆上的大布?”“是的，公主，那叫桅杆，帆挂在上面，风吹帆推动船。”“帆在海面上雪白雪白的，很好看。”“那是在画中吧，真正的帆没有那么白的。”“你好像是赫尔辛根默斯肯人?”“是的，我父亲是赫尔辛根默斯肯的建筑师，在我很小的时候，他带着全家来到了这里。”“你想回家吗，我是说赫尔辛根默斯肯?”“不太想，我小时候就离开那里，记得不太清了，再说想也没用，现在永远也不可能离开无故事王国了。”远处，海浪哗哗地喧响，仿佛在一遍遍地重复着长帆的话：永远不可能离开，永远不可能离开……“给我讲讲外面世界的故事吧，我什么都不知道。”公主说。“你不需要知道，你是无故事王国的公主，王国对你来说当然是无故事的。其实，公主，外面的人们也不给孩子们讲故事，但我的父母不一样，他们是赫尔辛根默斯肯人，他们还是给我讲了一些故事的。”“其实父王说过，无故事王国从前也是有故事的。”“是的……公主，你知道王国的周围都是海吧，王宫在王国的中心，朝任何一个方向走，最后都会走到海边，无故事王国就是一个大岛。”“这我知道。”“以前，王国周围的海不叫饕餮海，那时海中没有饕餮鱼，船可以自由地在海上航行，无故事王国和赫尔辛根默斯肯之间每天都有无数的船只来往。那时无故事王国其实是有故事王国，那时的生活与现在很不一样。”“嗯?”“那时生活中充满了故事，充满了变化和惊奇。那时，王国中有好几座繁华的城市，王宫的周围不是森林和田野，而是繁华的首都。城市中到处可见来自赫尔辛根默斯肯的奇珍异宝和奇异器具。无故事王国，哦不，故事王国的物产也源源不断地从海上运往赫尔辛根默斯肯。那时，人们的生活变幻莫测，像骑着快马在山间飞奔，时而冲上峰顶，时而跌入深谷，充满了机遇和危险。穷人可能一夜暴富，富豪也可能转眼赤贫，早晨醒来，谁也不知道今天要发生什么事，要遇到什么样的人。到处是刺激和惊喜。“但有一天，一艘来自赫尔辛根默斯肯的商船带来一种珍奇的小鱼，这种鱼只有手指长，黑色的，貌不惊人，装在坚硬的铸铁水捅中。卖鱼的商人在王国的集市上表演，他将一把剑伸进铁捅中的水里，只听到一阵刺耳的‘咔嚓咔嚓’声，剑再抽出来时已被咬成了锯齿状。这种鱼叫饕餮鱼，是一种内陆的淡水鱼，生长在赫尔辛根默斯肯岩洞深处黑暗的水潭中。饕餮鱼在王国的市场上销路很好，因为它们的牙齿虽小，但像金钢石一样坚硬，可做钻头;它们的鳍创民锋利，能做箭头或刁、刀。于是，越来越多的饕餮鱼从赫尔辛根默斯肯运到了王国。在一次台风中，一艘运鱼船在王国沿海失事沉没，船上运载的二十多桶饕餮鱼全部倾倒进了海中。“人们发现，饕餮鱼在海中能够飞快地生长，长得比在陆地上要大得多，能达到一人多长，同时繁殖极快，数量飞速增加。饕餮鱼开始捕食所有漂浮在海面上的东西，没来得及拖上岸的船，不管多大，都被啃成碎片，当一艘大船被饕餮鱼群围住时，它的船底很快被啃出大洞，但连沉没都未不及，就在海面上被咬成碎片，像融化掉一般。鱼群在故市王国的沿海环游，很快在王国周国的海中形成一道环形的屏障。“故事三国就这样被周围海域中的饕餮鱼包图，沿海已成为死亡之地，不再有任何船只和风帆，王国被封闭起未，与赫尔辛根默斯肯和整个外部份界斯绝了一切联系，过起了自给自足的田园生活。繁华的城市消失了，变成小镇和牧场，生活日浙宁静平淡，不再有变化，不再有刺激和惊喜，昨天像今天，今天像明天。人们渐渐适应了这样的日子，不再向往其他的生活。对过去的记，就像来自赫尔辛根默斯肯的奇异物品那样日渐稀少，人们甚至有意地忘记过去，也忘记现在。总的来说就是再不要故事了，建立了一个无故事的生活，故事王国也就变成了无故事王国。”露珠公主听得入了迷，长帆停了好久，她才问：“现在海洋上到处都有饕餮鱼吗?”“不，只是无故事王国的沿海有，眼神好的人有时能看到海鸟浮在离岸很远的海面上捕食，那里没有饕餮鱼。海洋很大，无边无际。”“就是说，世界除了无故事王国和赫尔辛根默斯肯，还有别的地方?”“公主，你认为世界只有这两个地方吗?”“小时候我的宫廷老师就是这么说的。”“这话连他自己都不信。世界很大，海洋无边无际，有无数的岛屿，有的比王国小，有的比王国大；还有大陆。”“什么是大陆?”“像海洋一样广阔的陆地，骑着快马走几个月都走不到边。”“世界那么大?”公主轻轻感叹，又突然问道，“你能看到我吗?”“公主，我现在只能看到你的眼睛，那里面有星星。”“那你就能看到我的向往，真想乘着帆船在海上航行，到很远很远的地方去。”“不可能了，公主，我们永远不可能离开无故事王国，永远不能……你要是怕黑，我可以点上火把。”“好的。”火把点燃后，露珠公主看着卫队长，却发现他的目光投向了别的地万。“你在看什么?”公主轻声问。“那里，公主，你看那个。”长帆指的是公主身边一小丛长在沙里的小草，草叶上有几颗小水珠，在火光中晶莹地闪亮。“那叫露珠。”长帆说。“哦，那是我吗？像我吗？”“像你，公主，都像水晶一样美丽。”“天亮后它们在太阳光下会更美的。”卫队长发出一声叹息，很深沉，根本没有声音，但公主感觉到了。“怎么了，长帆?”“露珠在阳光下会很快蒸发消失。”公主轻轻点点头，火光中她的目光黯然了，“那更像我了，这把伞一合上，我就会消失，我就是阳光下的雾珠。”“我不会让你消失的，公主。”“你知道，我也知道，我们到不了墓岛，也不可能把深水王子带回来。”“要是那样，公主，我就永远为你打伞。” 深水王子露珠公主再次醒来时，天已经亮了，大海由黑色变成了蓝色，但公主仍然感觉与画中见过的完全不同。曾被夜色掩盖的广阔现在一览无遗，在清晨的天光下，海面上一片空旷。但在公主的想象中，这空旷并不是饕餮鱼所致，海是为了她空着，就像王宫中公主的宫殿空着等她入住一样。夜里对长帆说过的那种愿望现在更加强烈，她想象着广阔的海面上出现一叶属于她的白帆，顺风漂去，消失在远方。现在为她打伞的是宽姨，卫队长在前面的海滩上向她们打招呼，让她们过去。等她们走去后，他朝海的方向一指说：“看，那就是墓岛。”公主首先看到的不是墓岛，而是站在小岛上的那个巨人，那显然就是深水王子。他顶天立地站在岛上，像海上的一座孤峰。他的皮肤是日晒的棕色，强健的肌肉像孤峰上的岩石，他的头发在海风飘荡，像峰顶的树丛。他长得很像冰沙，但比冰沙强壮，也没有后者的阴郁，他的目光和表情都给人一种大海般豁达的感觉。这时太阳还没有升起，但巨人的头顶已经沐浴在阳光中。金灿灿的，像着火似的。他用巨手搭凉棚眺望着远有那么一瞬间，公主感觉她和巨人的目光相遇了，就跳着大喊：“深水哥哥!我是露珠!我是你的妹妹露珠!我们在这里!”巨人没有反应，他的目光从这里扫过，移向别处，然后放下手，若有所思地摇摇头，转向另一个方向。“他为什么注意不到我们?”公主焦急地问。“谁会注意到远处的三只小蚂蚁呢?”卫队长说，然后转向宽姨，“我说深水王子是巨人吧，你现在看到了。”“可我抱着他的时候他确实是一个小小的婴儿呀!怎么会长得这么高?不过巨人好啊，谁也挡不住他，他可以惩罚那些恶人，为公主找回画像了!”“那首先得让他知道这里发生了什么事。”卫队长摇摇头说。“我要过去，我们必须过去!到墓岛上去!”公主抓住长帆说。“过不去的，公主，这么多年了，没有人能够登上墓岛，那岛上也没有人能回来。”“真想不出办法吗?”公主急得流出了眼泪，“我们到这里来就是为了找他，你一定知道该怎么办的！”看着公主泪眼婆娑，长帆很不安，“我真的没办法，到这里来是对的，你必须远离王宫，否则就是等死，但我当初就知道不可能去墓岛。也许……可以用信鸽给他送一封信。”“那太好了，我们这就去找信鸽!”“但那又有什么用呢?即使他收到了信，也过不来，他虽然是巨人，到海中也会被饕餮鱼撕碎的……先吃了早饭再想办法吧，我去准备。”“哎呀，我的盆!”宽姨叫起来，由于涨潮，海水涌上了沙滩，把昨天晚上公主洗脸用的木盆卷到了海中。盆已经向海里漂出了一段距离，盆倒扣着，里面的洗脸水在海面泛起一片雪白的肥皂泡沫。可以看到有几条饕餮鱼正在向盆游去，它们黑色的鳍像利刀一样划开水面，眼看木盆就要在它们的利齿下粉身碎骨了。但一件不可思议的事发生了：饕餮鱼没有去啃啮木盆，而是都游进了那片泡沫中，一接触泡沫，它们立刻停止游动，全都浮上了水面，凶悍之气荡然无存，全变成了一副懒洋洋的样子，有的慢慢摆动鱼尾，不是为了游动而是表示惬意；有的则露出白色的肚皮仰躺在水面上。三个人吃惊地看了一会儿，公主说：“我知道它们的感觉，它们在泡沫中很舒服，浑身软软的像没有骨头一样，不愿意动。”宽姨说：“赫尔辛根默斯肯的香皂确实是好东西，可惜只有两块了。”卫队长说：“即使在赫尔辛根默斯肯，这种香皂也很珍贵。你们知道它是怎样造出来的吗？赫尔辛根默斯肯有一片神奇的树林，那些树叫魔泡树，都长了上千年，很高大。平时魔泡树没有什么特别之处，但如果刮起大风，魔泡树就会被吹出肥皂泡来，风越大吹出的泡越多，赫尔辛根默斯肯香皂就是用那种泡泡做成的。收集那些肥皂泡十分困难，那些泡泡在大风中飘得极快，加上它们是全透明的，你站在那里很难看清它们，只有跑得和它们一样快，才能看到它们。骑最快的马才能追上风中的泡泡，这样的快马在整个赫尔辛根默斯肯不超过十匹。当魔泡树吹出泡泡时，制肥皂的人就骑着快马顺风狂奔，在马上用一种薄纱网兜收集泡泡。那些泡泡有大有小，但即使最大的泡泡，被收集到网兜里破裂后，也只剩下肉眼都看不见的那么一小点儿。要收集几十万甚至上百万的泡泡才能造出一块香皂，但香皂中的每一个魔树泡如果再溶于水，就又能生发出上百万个泡泡，这就是香皂泡沫这么多的原因。魔泡树的泡泡都没有重量，所以真正纯的赫尔辛根默斯肯香皂也完全没重量，是世界上最轻的东西，但很贵重。宽姨的那些香皂可能是国王加冕时赫尔辛根默斯肯使团带来的赠礼，后来……”长帆突然停止了讲述，若有所思地盯着海面。那里，在雪白的赫尔辛根默斯肯香皂的泡沫中，那几条饕餮鱼仍然懒散地躺浮着，在它们前，是完好无损的木盆。“好像有一个办法到墓岛上去!”长帆指着海面上的木盆说，“你们想想，那要是一只小船呢?”“想也别想!”宽姨大叫起来，“公主怎么能冒这个险?!”“公主当然不能去，我去。”卫队长从海面收回目光，从他坚定的眼神中，公主看出他已经下定了决心。“你一个人去，怎样让深水王子相信你?”公主说，她兴奋得脸颊通红，“我去，我必须去!”“可就算你到了岛上，又怎么证明自己的身份?”卫队长打量着一身平民装束的公主说。宽姨没有说话，她知道有办法。“我们可以滴血认亲。”公主说。“即使这样公主也不能去!这太吓人了!”宽姨说，但她的口气已经不是那么决绝。“我待在这里就安全吗?”公主指着宽姨手中旋转着的黑伞说，“我们太引人注意了，冰沙很快会知道我们的行踪，在这里，我就是暂时逃过了那张画，也逃不脱禁卫军的追杀，到墓岛上反而安全些。”于是他们决定冒险了。卫队长从沙滩上找了一只最小的船，用马拖到水边，就在浪花刚舔到船首的地方。找不到帆，但从其他的船上找到两支旧桨。他让公主和打伞的宽姨上了船，将宽姨拿出来的赫尔辛根默斯肯香皂穿到剑上递给公主，告诉她船一下海就把香皂浸到水里。然后他向海里推船，一直推到水齐腰深的地方才跳上船全力划桨，小船载着三人向墓岛方向驶去。饕餮鱼的黑鳍在周围的海面上出现，向小船围拢过来。公主坐在船尾，把穿在剑上的赫尔辛根默斯肯香皂浸到海水中，船尾立刻涌现一大团泡沫，在早晨的阳光中发出耀眼的白光，泡沫团迅速膨胀至一人多高，并在船尾保持这个高度，在后面则随着船的前行扩散开来，在海面形成雪白的一片。饕餮鱼纷纷游进泡沫浮在其中，像躺在雪白的毛绒毯上一样享受着无与伦比的舒适惬意。公主第一次这么近看饕餮鱼，它们除了肚皮通体乌黑，像钢铁做成的机器，但一进入泡沫就变得懒散温顺。小船在平静的海面上前进，后面拖曳了一条长长的泡沫尾迹，像一道落在海上的白云带。无数的饕餮鱼从两侧游过来进入泡沫中，像在进行一场云河中的朝圣。偶尔也有几条从前方游来的饕餮鱼啃几下船底，还把卫队长手中的木桨咬下了一小块，但它们很快就被后面的泡沫所吸引，没有造成大的破坏。看着船后海面上雪白的泡沫云河，以及陶醉其中的饕餮鱼，公主不由得想起了牧师讲过的天堂。海岸渐渐远离，小船向墓岛靠近。宽姨突然喊道：“你们看，深水王子好像矮了一些!”公主转头望去，宽姨说得没错，岛上的王子仍是个巨人，但比在岸上看明显矮了一些，此时他仍背对着他们，眺望着别的方向。公主收回目光，看着划船的长帆，他此时显得更加强健有力，强劲的肌肉块块鼓起，两支长桨在他手中像一对飞翔的翅膀，推动着小船平稳前行。这人似乎天生是一个水手，在海上显然比在陆地更加自如。“王子看到我们了!”宽姨又喊道。墓岛上，深水王子转向了这边，一手指着小船的方向，眼中透出惊奇的目光，嘴还在动，像喊着什么。他肯定会感到惊奇，除了这只出现在死亡之海上的小船外，船后的泡沫扩散开来，向后宽度逐渐增大，从他那个高度看过去，海面上仿佛出现了一颗拖着雪白彗尾的彗星。他们很快知道王子并非对他们喊话，他的脚下出现了几个正常身高的人。从这个距离上，他们看上去很小，脸也看不清，但肯定都在朝这个方向看，有的还在挥手。墓岛原是个荒岛，没有原住民。二十年前，深水去岛上钓鱼时，陪同他的有一名监护官、一名王宫老师、几名护卫和仆从。他们刚上岛，成群的饕餮鱼就游到这片沿海，封死了他们回王国的航路。他们发现，现在王子看上去又矮了一些，似乎小船距海岛越近，王子就越矮。小船渐渐接近岛岸，可以看清那些正常身高的人了，他们共八个人，大部分都穿着和王子一样的用帆布做的粗糙衣服，其中有两个老者穿着王宫的制服，但都已经很破旧了，这些人大都挂着剑。他们向海滩跑来，王子远远地跟在后面，这时，他看(上)去仅有其他人的两倍高，不再是巨人了。卫队长加速划行，小船冲向岛岸，一道拍岸浪像巨手把小船向前推，船身震动了一下，差点把公主颠下船去，船底触到了沙滩。那些已经跑到海滩上的人看着小船犹豫不前，显然是怕水中的饕餮鱼，但还是有四个人跑上前来，帮忙把船稳住，扶公主下船。“当心，公主不能离开伞!”下船时宽姨高声说，同时使伞保持在公主上方，她这时打伞已经很熟练了，用一只手也能保持伞的旋转。那些人毫不掩饰自己的惊奇，时而看看旋转的黑伞，时而看看小船经过的海面——那里，赫尔辛根默斯肯香皂的白沫和浮在海面的无数饕餮鱼形成了一条黑白相间的海路，连接着墓岛和王国海岸。深水王子也走上前来，这时，他的身高与普通人无异，甚至比这群人中的两个高个子还矮一些。他看着来人微笑着，像一个宽厚的渔民，但公主却从他身上看到了父王的影子，她扔下剑，热泪盈眶地喊道：“哥哥，我是你的妹妹露珠!”“你像我的妹妹。”王子微笑着，点点头，向公主伸出双手。但几个人同时阻止了公主的靠近，把三位来者与王子隔开，其中有人佩剑已出鞘，警惕地盯着刚下船的卫队长。后者没有理会这边的事，只是拾起公主扔下的剑察看，为了避免对方误会，他小心地握着剑尖，发现经过这段航程，那块穿在剑上的赫尔辛根默斯肯香皂只消耗了三分之一左右。“你们必须证实公主的身份。”一位老者说，他身上破旧的制服打理得很整齐，脸上饱经风霜，但留着像模像样的胡须，显然在这孤岛岁月中他仍尽力保持着王国官员的仪表。“你们不认识我了吗?你是暗林监护官，你——”宽姨指指另一位老者，“是广田老师。”两位老者都点点头。广田老师说：“宽姨，你老了。”“你们也老了。”宽姨说着，腾出一只转伞的手抹眼泪。暗林监护官不为所动，仍一丝不苟地说：“二十多年了，我们一点都不知道王国发生了什么，所以还是必须证实公主的身份，”他转向公主，“请问，您愿意滴血认亲吗?”公主点点头。“我觉得没必要，她肯定是我的妹妹。”王子说。“殿下，必须这样做。”监护官说。有人拿来两把很小的匕首，给监护官和老师每人一把。与这些人锈迹斑斑的佩剑不同，两把匕首寒光闪闪，像新的一样。公主伸出手来，监护官用匕首在她白嫩的食指上轻轻划了一下，用刀尖从破口取了一滴血。暗林老师也从王子的手指上取了血样，监护官从老师手中拿过匕首，小心翼翼地把刀尖上的两滴血混在一起，血立刻变成了纯蓝色。“她是露珠公主。”监护官庄重地对王子说，然后同老师一起向公主鞠躬。其他的几个人都扶着剑柄单膝脆下，然后站起来闪到一边，让王子和公主兄妹拥抱在一起。“小时候我抱过你，那时你才这么大。”王子比画着说。公主向王子哭诉王国已经发生的事，王子握着她的手静静地听着，他那饱经风霜但仍然年轻的脸上表情一直从容镇定。大家都围在王子和公主周围，静静地听着公主的讲述，只有卫队长在做着一件奇怪的事。他时而快步跑开，在海滩上跑到很远的地方看着王子，然后又跑回来从近前看他，如此反复好几次，后来宽姨拉住了他。“还是我说得对，王子不是巨人吧。”宽姨指指王子低声说。“他既是巨人又不是巨人。”卫队长也压低声音说，“是这样的：我们看一般的人，他离得越远在我们眼中就越小，是吧?但王子不是这样，不管远近，他在我们眼中的大小都是一样的，近看他是普通身高，远看还是这么高，所以远看就像巨人了。”宽姨点点头，“好像真是这样。”听完公主的讲述，深水王子只是简单地说：“我们回去。”回王国的船只有两只，王子与公主一行三人坐在小船上，其余八人乘另一只更大些的船，是二十年前载着王子一行来墓岛的船，有些漏水，但还能短程行驶。在来时的航道中，泡沫消散了一些，但无数的饕餮鱼仍然浮在海面上很少动弹，有些饕餮鱼被船头撞上，或被桨碰到，也只是懒洋洋地扭动几下，没有更多的动作。大船破旧的帆还能用，在前面行驶，从漂浮一片的饕餮鱼群中为后面的小船开出一条路来。“你最好还是把香皂放到海里，保险一些，万一它们醒过来怎么办？”宽姨看着船周围黑压压的饕餮鱼，心有余悸地说。公主说：“它们一直醒着，只是很舒服，懒得动。香皂只刹一块半了，不要浪费，而且我以后再也不用它洗澡了。”这时，前面的大船上有人喊道：“禁卫军!”在远处王国的海岸上出现了一支马队，像黑压压的潮水般涌上海滩，马上骑士的盔甲和刀剑在阳光中闪亮。“继续走。”深水王子镇定地说。“他们是来杀我们的。”公主的脸色变得苍白。“不要怕，没事的。”王子拍拍公主的手说。露珠公主看着哥哥，现在她知道他更适合当国王。由于是顺风，尽管航道上有懒洋洋漂浮着的饕餮鱼阻碍，回程也快了许多。当两艘船几乎同时靠上海滩时，禁卫军的马阵围拢过来，密集地挡在他们面前，像一堵森严的墙壁。公主和宽姨都大惊失色，但经验丰富的卫队长却把提着的心多少放下一些，他看到对方的剑都在鞘中，长矛也都竖直着；更重要的是，他看到了那些马上的禁卫军士兵的眼睛，他们都身着重甲，面部只露出双眼，但那些眼睛越过他们盯着海面上那漂浮着饕餮鱼的泡沫航道，目光中都露出深深的敬畏。一名军官翻身下马，向刚靠岸的船跑来。大船上的人都跳下船，监护官、老师和几名执剑的卫士把王子和公主档在后面。“这是深水王子和露珠公主，不得无礼!”监护官暗林对禁卫军举起一只手臂大声说。跑过来的军官一手扶着插在沙滩上的剑，对王子和公主行单膝礼，“我们知道，但我们奉命追杀公主。”“露珠公主是合法的王位继承人！而冰沙是谋害国王的逆绒！你们怎么能听他的调遣？！”“我们知道，所以我们不会执行这个命令，但，冰沙王子已经于昨天下午加冕为国王，所以，禁卫军现在也不知道该听谁的指挥。”监护官还想说什么，但深水王子从后面走上前来制止了他，王子对军官说：“这样吧，我和公主与你们一起回王宫，等见到冰沙后，把事情做个了结。”在王宫最豪华的宫殿中，头戴王冠的冰沙正在同忠于他的大臣们纵酒狂欢。突然有人来报，说深水王子和寨珠公主统帅禁卫军从海岸急速向王宫而来，再有一个时辰就到了。宫殿中顿时陷入一片死寂。“深水?他是怎么过海的?难道他长了翅膀?”冰沙自语道，但并没有像其他人那样面露惊恐，“没什么，禁卫军不会受深水和露珠指挥，除非我死了……针眼画师!”随着冰沙的召唤，针眼画师从暗处无声地走出，他仍然穿着那身灰斗篷，显得更瘦小了。“你，带上雪浪纸和绘画工具，骑快马去深水来的方向，看他一眼，然后把他画下来。你见到深水很容易，不用靠近他，他在天边一出现你就能远远看到的。”“是，我的王。”针眼低声说，然后像老鼠一样无声地离去了。“至于露珠，一个女孩子，成不了大气候，我会尽快把她的那把伞抢走的。”冰沙说着，又端起酒杯。宾会在压抑的气氛中结束，大臣们忧心仲钟地离去，只剩下冰沙一人阴郁地坐在空荡荡的大厅中。不知过了多长时间，冰沙看到针眼画师走了进来，他的心立刻提了起不，不是因为针眼两手空空，也不是因为针眼的样子——画师右上去并没有什么变化，仍是那副小心翼翼的敏感模样，而是因为他听到画师的脚步声。以前，画师走路悄无声息，像灰鼠一般从地面滑过，但这一刻，冰沙听到他发出了吧嗒吧嗒的脚步声，像难以抑制的心跳。“我的王，我见到了深水王子，但我不能把他画下来。”针眼低着头说。“难道他真的长了翅膀?”冰沙冷冷地问。“如果是那样我也能画下他，我能把他翅膀的每一根羽毛都画得栩栩如生.但，我的王，深水王子没有长翅膀，比那更可怕：他不符合透视原理。”“什么是透视?”“世界上所有的景物，在我们的视野中都是近大远小，这就是透视原理。我是西洋画派的画师，西洋画派遵循透视原理，所以我不可能画出他。”“有不遵循透视原理的画派吗?”“有，东方画派，我的王，你看，那就是。”针眼指指大厅墙上挂着的一幅卷轴水墨画，画面上是淡雅飘逸的山水，大片的留白似雾似水，与旁边那些浓墨重彩的油画风格迥异，“你可以看出，那幅画是不讲究透视的。可是我没学过东方画派，空灵画师不肯教我，也许他想到了这一天。”“你去吧。”王子面无表情地说。“是，我的王，深水王子就要到王宫了，他会杀了我，也会杀了你。但我不会等着让他杀死，我将自我了断，我要画出一幅登峰造极的杰作，用我的生命。”针眼画师说完就走了，他离去时的脚步再次变得悄无声息。冰沙招来了侍卫，说：“拿我的剑来。”外面传来密集的马蹄声，开始隐隐约约，但很快逼近，如暴雨般急骤，最后在宫殿外面戛然而止。冰沙站起身，提剑走出宫殿。他看到深水王子正走上宫殿前长长的宽石阶，露珠公主跟在他后面，宽姨为她打着黑伞。在石阶下面的广场上，是黑压压的禁卫军阵列，军队只是沉默地等待，没有明确表示支持哪一方。冰沙第一眼看到深水王子时，他有普通人的一倍身高，但随着他在台阶上越走越近，身高也在冰沙的眼中渐渐降低。有那么一瞬间，冰沙的思绪回到了二十多年前的童年。那时，他已经知道了饕餮鱼群正在游向墓岛海域，但还是诱骗深水去墓岛钓鱼。当时父王在焦虑中病倒了，他告诉深水，墓岛有一种鱼，做成的鱼肝油能治好父王的病。一向稳重的深水竞然相信了他，结果如他所愿一去不返，王国里没人知道真相，这一直是他最得意的一件事。冰沙很快打断思绪回到现实，深水已经走上宫殿前宽阔的平台，他的身高已与正常人差不多了。冰沙看着深水说：“我的哥哥，欢迎你和妹妹回来，但你们要明白，这是我的王国，我是国王，你们必须立刻宣布臣服于我。”深水一手按在腰间生铸佩剑的剑柄上，一手指着冰沙说：“你犯下了不可饶怒的罪行!”冰沙冷冷一笑，“针眼不能画出你的画像，我的利剑却可以刺穿你的心脏!”说着他拔剑出鞘。冰沙与深水的剑术不相上下，但由于后者不符合透视原理，冰沙很难准确判断自己与对手的距离，处于明显劣势。决斗很快结束，冰沙被深水一剑刺穿胸膛，从高高的台阶上滚下去，在石阶上拖出一条长长的血迹。禁卫军欢呼起来，他们宣布忠于深水王子和露珠公主。与此同时，卫队长在王宫中搜寻针眼画师。有人告诉他，画师去了自己的画室。画室位于王宫僻静的一角，平时戒备森严，但由于王宫中突发的变故，守卫大部分离去，只留下了一个哨兵。此人原是长帆的部下，说针眼在半个时辰前就进了画室，一直待在里而没有出来。卫队长于是破门而入。画室没有窗户，两个银烛台上的蜡烛大部分已经燃尽，使这里像地堡一样阴冷。卫队长没有看到针眼画师，这里空无一人，但他看到了画架上的一幅画，是刚刚完成的，颜料还未干，这是针眼的自画像。确实是一幅精妙绝伦的杰作，画面像一扇通向另一个世界的窗口，针眼就在窗的另一边望着这个世界。尽管雪浪纸翘起的一角证明这只足一幅没有生命的画，卫队长还是尽力避开画中人那犀利的目光。长帆环顾四周，看到了墙上挂着一排画像，有国王、王后和忠于他们的大臣，他一眼就从中认出了露珠公主的画像。画中的公主让他感到这阴暗的画室如天国一般明亮起来，画中人的眼睛摄住了他的魂，使他久久陶醉其中。但长帆最后还是清醒了，他取下画，拆掉画框，把画幅卷起来，毫不扰豫地在蜡烛上点燃了。画刚刚烧完，门开了，现实中的露珠公主走了进来，她仍然穿着那身朴素的平民衣服，自己打着黑伞。“宽姨呢?”长帆问。“我没让她来，我有话要对你说。”“你的画像已经烧了。”长帆指指地上仍然冒着红光的灰烬说，“不用打伞了。”公主让手中的伞转速慢下来，很快出现了夜莺的鸣叫声，随着伞面的下垂，鸟鸣声越来越大，也越来越急促，最后由夜莺的叫声变成寒鸽的嘶鸣，那是死神降临前的最后警告。当伞最后合上时，随着伞沿那几颗石球吧嗒的碰撞，伞安静下来。公主安然无恙。卫队长看着公主，长长地出了一口气，又低头看看灰烬，“可惜了，是幅好画，真该让你看看，但我不敢再拖下去了……画得真美。”“比我还美吗?”“那就是你。”长帆深情地说。公主拿出了那一块半赫尔辛根默斯肯香皂，她一松手，没有重量的雪白香皂就像羽毛似的飘浮在空气中。“我要离开王国，去大海上航行，你愿意跟我去吗?”公主问。“什么?深水王子不是已经宣布，你明天要加冕为女王吗?他还说他会全力辅佐你的。”公主摇摇头，“哥哥比我更适合当国王，再说，如果不是被困墓岛，王位本来就应该由他继承。他如果成为国王，站在王宫的高处，全国都能看到他。而我，我不想当女王，我觉得外面比王宫里好，我也不想一辈子都待在无故事王国，想到有故事的地方去。”“那种生活艰难又危险。”“我不怕。”公主的双眼在烛光中焕发出生命的光芒，让长帆感到周围又亮了起来。“我当然更不怕，公主我可以跟着你到海的尽头，到世界尽头。”“那我们就是最后两个走出王国的人了。”公主说着，抓住了那一块半飘浮的香皂。“这次我们乘帆船。”“对，雪白的帆。”第二天早晨，在王国的另一处海岸上，有人看到海中出现了一张白帆，那艘帆船后面拖曳着一道白云般的泡沫，在朝阳中驶向远方。以后，王国中的人们再也没有得到露珠公主和长帆的消息。事实上王国得不到任何外界的消息，公主带走了王国中最后一块半赫尔辛根默斯肯香皂，再也没有人能够冲破饕餮鱼的封锁。但没有人抱怨，人们早已习惯了这样的生活，这个故事结束后，无故事王国永远无故事了。但有时夜深人静，也有人讲述不是故事的故事，那是对露珠公主和长帆经历的想象。每个人的想象都不一样，但人们都认为他俩到过无数神奇的国度，还到过像大海一样广阔的陆地，他们永远在航行和旅途中，不管走到哪里，他们总是幸福地生活在一起。]]></content>
  </entry>
  <entry>
    <title><![CDATA[POJ 1127]]></title>
    <url>%2F2017%2F12%2F03%2FPOJ-1127%2F</url>
    <content type="text"><![CDATA[从《挑战程序设计竞赛》里面扣了点东西(P250) Source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;double EPS = 1e-10;double add(double a, double b)&#123; if (abs(a + b) &lt; EPS * (abs(a) + abs(b))) return 0; return a + b;&#125;struct P&#123; double x, y; P() &#123;&#125; P(double x, double y) : x(x), y(y) &#123;&#125; P operator + (P p) &#123; return P(add(x, p.x), add(y, p.y)); &#125; P operator - (P p) &#123; return P(add(x, -p.x), add(y, -p.y)); &#125; P operator * (double d) &#123; return P(x*d, y*d); &#125; double dot(P p) //内积 &#123; return add(x*p.x, y*p.y); &#125; double det(P p) //外积 &#123; return add(x*p.y, -y*p.x); &#125;&#125;;int n;const int MAX_N = 1000;P p[MAX_N], q[MAX_N];int m;int a[MAX_N], b[MAX_N];bool g[MAX_N][MAX_N];bool on_seg(P p1, P p2, P q)&#123; return (p1 - q).det(p2 - q) == 0 &amp;&amp; (p1 - q).dot(p2 - q) &lt;= 0;&#125;P intersection(P p1, P p2, P q1, P q2)&#123; return p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));&#125;void solve()&#123; for (int i = 0; i &lt; n; ++i) &#123; g[i][i] = true; for (int j = 0; j &lt; i; ++j) &#123; if ((p[i] - q[i]).det(p[j] - q[j]) == 0) &#123; g[i][j] = g[j][i] = on_seg(p[i], q[i], p[j]) || on_seg(p[i], q[i], q[j]) || on_seg(p[j], q[j], p[i]) || on_seg(p[j], q[j], q[i]); &#125; else &#123; P r = intersection(p[i], q[i], p[j], q[j]); g[i][j] = g[j][i] =on_seg(p[i], q[i], r) &amp;&amp; on_seg(p[j], q[j], r); &#125; &#125; &#125; for (int k = 0; k &lt; n; ++k) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; g[i][j] |= g[i][k] &amp;&amp; g[k][j]; &#125; &#125; &#125; for (int i = 0; i &lt; m; ++i) &#123; puts(g[a[i] - 1][b[i] - 1] ? "CONNECTED" : "NOT CONNECTED"); &#125;&#125;int main()&#123; //freopen("data.txt", "r", stdin); cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; &#125; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; q[i].x &gt;&gt; q[i].y; &#125; cin &gt;&gt; m; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; a[j] &gt;&gt; b[j]; &#125; solve(); return 0;&#125; 里面引入的向量概念，使用向量有关的计算来判断两直线是否相交(on_seg)，算是和几何的一个应用吧。 测试数据输入1234540 4 0 1 1 2 1 04 1 2 3 3 4 2 141 2 1 4 2 3 2 4 输出1234CONNECTEDNOT CONNECTEDCONNECTEDNOT CONNECTED]]></content>
  </entry>
  <entry>
    <title><![CDATA[搞定Putty的编译问题]]></title>
    <url>%2F2017%2F11%2F11%2FFix-putty-bug%2F</url>
    <content type="text"><![CDATA[之前编译Putty的时候，遇到如下错误：1234567In file included from ../windows/window.c:29:0:D:/CodeBlocks/MinGW/i686-w64-mingw32/include/multimon.h: In function &apos;IsPlatformNT&apos;:D:/CodeBlocks/MinGW/i686-w64-mingw32/include/multimon.h:130:38: error: &apos;osvi&apos; undeclared (first use in this function) oi.dwOSVersionInfoSize = sizeof (osvi); ^~~~D:/CodeBlocks/MinGW/i686-w64-mingw32/include/multimon.h:130:38: note: each undeclared identifier is reported only once for each function it appears inmingw32-make: *** [.\Makefile.mgw:963: window.o] Error 1 之前没怎么仔细看过报错信息，而是把Visual Studio的multimon.h替换掉Mingw的来解决报错。现在回头仔细看了看了信息，无非是Mingw的multimon.h里面的IsPlatformNT函数内的osvi未定义，同时打开了Mingw和Visual Studio的multimon.h，显示如下如图，可以看到Mingw的头文件内定义的变量是oi，但是使用的时候却用了osvi，初步估计是Mingw的问题了，向社区提交，等待回复。]]></content>
  </entry>
  <entry>
    <title><![CDATA[FRP]]></title>
    <url>%2F2017%2F11%2F01%2FFRP%2F</url>
    <content type="text"><![CDATA[这里应该@大老板一下的，这是一个很有意思的小工具，其实也不小，这里仅作推广，作者的文档已经足够详细，使用得当的话，非常方便。于是，我把作者的文档完整的扣过来了，希望不会被打o(￣▽￣)o项目位于https://github.com/fatedier/frp frp 的作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。 开发状态 frp 仍然处于前期开发阶段，未经充分测试与验证，不推荐用于生产环境。 master 分支用于发布稳定版本，dev 分支用于开发，您可以尝试下载最新的 release 版本进行测试。 目前的交互协议可能随时改变，不保证向后兼容，升级新版本时需要注意公告说明同时升级服务端和客户端。 架构 使用示例根据对应的操作系统及架构，从 Release 页面下载最新版本的程序。 将 frps 及 frps.ini 放到具有公网 IP 的机器上。 将 frpc 及 frpc.ini 放到处于内网环境的机器上。 通过 ssh 访问公司内网机器 修改 frps.ini 文件，这里使用了最简化的配置： 123# frps.ini[common]bind_port = 7000 启动 frps： ./frps -c ./frps.ini 修改 frpc.ini 文件，假设 frps 所在服务器的公网 IP 为 x.x.x.x； 12345678910# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 启动 frpc： ./frpc -c ./frpc.ini 通过 ssh 访问内网机器，假设用户名为 test： ssh -oPort=6000 test@x.x.x.x 通过自定义域名访问部署于内网的 web 服务有时想要让其他人通过域名访问或者测试我们在本地搭建的 web 服务，但是由于本地机器没有公网 IP，无法将域名解析到本地的机器，通过 frp 就可以实现这一功能，以下示例为 http 服务，https 服务配置方法相同， vhost_http_port 替换为 vhost_https_port， type 设置为 https 即可。 修改 frps.ini 文件，设置 http 访问端口为 8080： 1234# frps.ini[common]bind_port = 7000vhost_http_port = 8080 启动 frps； ./frps -c ./frps.ini 修改 frpc.ini 文件，假设 frps 所在的服务器的 IP 为 x.x.x.x，local_port 为本地机器上 web 服务对应的端口, 绑定自定义域名 www.yourdomain.com: 123456789# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[web]type = httplocal_port = 80custom_domains = www.yourdomain.com 启动 frpc： ./frpc -c ./frpc.ini 将 www.yourdomain.com 的域名 A 记录解析到 IP x.x.x.x，如果服务器已经有对应的域名，也可以将 CNAME 记录解析到服务器原先的域名。 通过浏览器访问 http://www.yourdomain.com:8080 即可访问到处于内网机器上的 web 服务。 转发 DNS 查询请求DNS 查询请求通常使用 UDP 协议，frp 支持对内网 UDP 服务的穿透，配置方式和 TCP 基本一致。 修改 frps.ini 文件： 123# frps.ini[common]bind_port = 7000 启动 frps： ./frps -c ./frps.ini 修改 frpc.ini 文件，设置 frps 所在服务器的 IP 为 x.x.x.x，转发到 Google 的 DNS 查询服务器 8.8.8.8 的 udp 53 端口： 12345678910# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[dns]type = udplocal_ip = 8.8.8.8local_port = 53remote_port = 6000 启动 frpc： ./frpc -c ./frpc.ini 通过 dig 测试 UDP 包转发是否成功，预期会返回 www.google.com 域名的解析结果： dig @x.x.x.x -p 6000 www.goolge.com 转发 Unix域套接字通过 tcp 端口访问内网的 unix域套接字(和 docker daemon 通信)。 frps 的部署步骤同上。 启动 frpc，启用 unix_domain_socket 插件，配置如下： 12345678910# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[unix_domain_socket]type = tcpremote_port = 6000plugin = unix_domain_socketplugin_unix_path = /var/run/docker.sock 通过 curl 命令查看 docker 版本信息 curl http://x.x.x.x:6000/version 安全地暴露内网服务对于某些服务来说如果直接暴露于公网上将会存在安全隐患。 使用 stcp(secret tcp) 类型的代理可以避免让任何人都能访问到要穿透的服务，但是访问者也需要运行另外一个 frpc。 以下示例将会创建一个只有自己能访问到的 ssh 服务代理。 frps 的部署步骤同上。 启动 frpc，转发内网的 ssh 服务，配置如下，不需要指定远程端口： 1234567891011# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[secret_ssh]type = stcp# 只有 sk 一致的用户才能访问到此服务sk = abcdefglocal_ip = 127.0.0.1local_port = 22 在要访问这个服务的机器上启动另外一个 frpc，配置如下： 123456789101112131415# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[secret_ssh_vistor]type = stcp# stcp 的访问者role = vistor# 要访问的 stcp 代理的名字server_name = secret_sshsk = abcdefg# 绑定本地端口用于访问 ssh 服务bind_addr = 127.0.0.1bind_port = 6000 通过 ssh 访问内网机器，假设用户名为 test： ssh -oPort=6000 test@127.0.0.1 通过 frpc 所在机器访问外网frpc 内置了 http proxy 和 socks5 插件，可以使其他机器通过 frpc 的网络访问互联网。 frps 的部署步骤同上。 启动 frpc，启用 http_proxy 或 socks5 插件(plugin 换为 socks5 即可)， 配置如下： 123456789# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000[http_proxy]type = tcpremote_port = 6000plugin = http_proxy 浏览器设置 http 或 socks5 代理地址为 x.x.x.x:6000，通过 frpc 机器的网络访问互联网。 功能说明配置文件由于 frp 目前支持的功能和配置项较多，未在文档中列出的功能可以从完整的示例配置文件中发现。 frps 完整配置文件 frpc 完整配置文件 Dashboard通过浏览器查看 frp 的状态以及代理统计信息展示。 需要在 frps.ini 中指定 dashboard 服务使用的端口，即可开启此功能： 12345[common]dashboard_port = 7500# dashboard 用户名密码，默认都为 admindashboard_user = admindashboard_pwd = admin 打开浏览器通过 http://[server_addr]:7500 访问 dashboard 界面，用户名密码默认为 admin。 身份验证从 v0.10.0 版本开始，所有 proxy 配置全部放在客户端(也就是之前版本的特权模式)，服务端和客户端的 common 配置中的 privilege_token 参数一致则身份验证通过。 需要注意的是 frpc 所在机器和 frps 所在机器的时间相差不能超过 15 分钟，因为时间戳会被用于加密验证中，防止报文被劫持后被其他人利用。 这个超时时间可以在配置文件中通过 authentication_timeout 这个参数来修改，单位为秒，默认值为 900，即 15 分钟。如果修改为 0，则 frps 将不对身份验证报文的时间戳进行超时校验。 加密与压缩这两个功能默认是不开启的，需要在 frpc.ini 中通过配置来为指定的代理启用加密与压缩的功能，压缩算法使用 snappy： 1234567# frpc.ini[ssh]type = tcplocal_port = 22remote_port = 6000use_encryption = trueuse_compression = true 如果公司内网防火墙对外网访问进行了流量识别与屏蔽，例如禁止了 ssh 协议等，通过设置 use_encryption = true，将 frpc 与 frps 之间的通信内容加密传输，将会有效防止流量被拦截。 如果传输的报文长度较长，通过设置 use_compression = true 对传输内容进行压缩，可以有效减小 frpc 与 frps 之间的网络流量，加快流量转发速度，但是会额外消耗一些 cpu 资源。 客户端热加载配置文件当修改了 frpc 中的代理配置，可以通过 frpc --reload 命令来动态加载配置文件，通常会在 10 秒内完成代理的更新。 启用此功能需要在 frpc 中启用 admin 端口，用于提供 API 服务。配置如下： 1234# frpc.ini[common]admin_addr = 127.0.0.1admin_port = 7400 之后执行重启命令： frpc -c ./frpc.ini --reload 等待一段时间后客户端会根据新的配置文件创建、更新、删除代理。 需要注意的是，[common] 中的参数除了 start 外目前无法被修改。 特权模式由于从 v0.10.0 版本开始，所有 proxy 都在客户端配置，原先的特权模式是目前唯一支持的模式。 端口白名单为了防止端口被滥用，可以手动指定允许哪些端口被使用，在 frps.ini 中通过 privilege_allow_ports 来指定： 123# frps.ini[common]privilege_allow_ports = 2000-3000,3001,3003,4000-50000 privilege_allow_ports 可以配置允许使用的某个指定端口或者是一个范围内的所有端口，以 , 分隔，指定的范围以 - 分隔。 TCP 多路复用从 v0.10.0 版本开始，客户端和服务器端之间的连接支持多路复用，不再需要为每一个用户请求创建一个连接，使连接建立的延迟降低，并且避免了大量文件描述符的占用，使 frp 可以承载更高的并发数。 该功能默认启用，如需关闭，可以在 frps.ini 和 frpc.ini 中配置，该配置项在服务端和客户端必须一致： 123# frps.ini 和 frpc.ini 中[common]tcp_mux = false 底层通信可选 kcp 协议从 v0.12.0 版本开始，底层通信协议支持选择 kcp 协议，在弱网环境下传输效率提升明显，但是会有一些额外的流量消耗。 开启 kcp 协议支持： 在 frps.ini 中启用 kcp 协议支持，指定一个 udp 端口用于接收客户端请求： 12345# frps.ini[common]bind_port = 7000# kcp 绑定的是 udp 端口，可以和 bind_port 一样kcp_bind_port = 7000 在 frpc.ini 指定需要使用的协议类型，目前只支持 tcp 和 kcp。其他代理配置不需要变更： 123456# frpc.ini[common]server_addr = x.x.x.x# server_port 指定为 frps 的 kcp_bind_portserver_port = 7000protocol = kcp 像之前一样使用 frp，需要注意开放相关机器上的 udp 的端口的访问权限。 连接池默认情况下，当用户请求建立连接后，frps 才会请求 frpc 主动与后端服务建立一个连接。当为指定的代理启用连接池后，frp 会预先和后端服务建立起指定数量的连接，每次接收到用户请求后，会从连接池中取出一个连接和用户连接关联起来，避免了等待与后端服务建立连接以及 frpc 和 frps 之间传递控制信息的时间。 这一功能比较适合有大量短连接请求时开启。 首先可以在 frps.ini 中设置每个代理可以创建的连接池上限，避免大量资源占用，客户端设置超过此配置后会被调整到当前值： 123# frps.ini[common]max_pool_count = 5 在 frpc.ini 中为客户端启用连接池，指定预创建连接的数量： 123# frpc.ini[common]pool_count = 1 修改 Host Header通常情况下 frp 不会修改转发的任何数据。但有一些后端服务会根据 http 请求 header 中的 host 字段来展现不同的网站，例如 nginx 的虚拟主机服务，启用 host-header 的修改功能可以动态修改 http 请求中的 host 字段。该功能仅限于 http 类型的代理。 123456# frpc.ini[web]type = httplocal_port = 80custom_domains = test.yourdomain.comhost_header_rewrite = dev.yourdomain.com 原来 http 请求中的 host 字段 test.yourdomain.com 转发到后端服务时会被替换为 dev.yourdomain.com。 获取用户真实 IP目前只有 http 类型的代理支持这一功能，可以通过用户请求的 header 中的 X-Forwarded-For 和 X-Real-IP 来获取用户真实 IP。 需要注意的是，目前只在每一个用户连接的第一个 HTTP 请求中添加了这两个 header。 通过密码保护你的 web 服务由于所有客户端共用一个 frps 的 http 服务端口，任何知道你的域名和 url 的人都能访问到你部署在内网的 web 服务，但是在某些场景下需要确保只有限定的用户才能访问。 frp 支持通过 HTTP Basic Auth 来保护你的 web 服务，使用户需要通过用户名和密码才能访问到你的服务。 该功能目前仅限于 http 类型的代理，需要在 frpc 的代理配置中添加用户名和密码的设置。 1234567# frpc.ini[web]type = httplocal_port = 80custom_domains = test.yourdomain.comhttp_user = abchttp_pwd = abc 通过浏览器访问 http://test.yourdomain.com，需要输入配置的用户名和密码才能访问。 自定义二级域名在多人同时使用一个 frps 时，通过自定义二级域名的方式来使用会更加方便。 通过在 frps 的配置文件中配置 subdomain_host，就可以启用该特性。之后在 frpc 的 http、https 类型的代理中可以不配置 custom_domains，而是配置一个 subdomain 参数。 只需要将 *.{subdomain_host} 解析到 frps 所在服务器。之后用户可以通过 subdomain 自行指定自己的 web 服务所需要使用的二级域名，通过 {subdomain}.{subdomain_host} 来访问自己的 web 服务。 123# frps.ini[common]subdomain_host = frps.com 将泛域名 *.frps.com 解析到 frps 所在服务器的 IP 地址。 12345# frpc.ini[web]type = httplocal_port = 80subdomain = test frps 和 fprc 都启动成功后，通过 test.frps.com 就可以访问到内网的 web 服务。 需要注意的是如果 frps 配置了 subdomain_host，则 custom_domains 中不能是属于 subdomain_host 的子域名或者泛域名。 同一个 http 或 https 类型的代理中 custom_domains 和 subdomain 可以同时配置。 URL 路由frp 支持根据请求的 URL 路径路由转发到不同的后端服务。 通过配置文件中的 locations 字段指定一个或多个 proxy 能够匹配的 URL 前缀(目前仅支持最大前缀匹配，之后会考虑正则匹配)。例如指定 locations = /news，则所有 URL 以 /news 开头的请求都会被转发到这个服务。 123456789101112# frpc.ini[web01]type = httplocal_port = 80custom_domains = web.yourdomain.comlocations = /[web02]type = httplocal_port = 81custom_domains = web.yourdomain.comlocations = /news,/about 按照上述的示例配置后，web.yourdomain.com 这个域名下所有以 /news 以及 /about 作为前缀的 URL 请求都会被转发到 web02，其余的请求会被转发到 web01。 通过代理连接 frps在只能通过代理访问外网的环境内，frpc 支持通过 HTTP PROXY 和 frps 进行通信。 可以通过设置 HTTP_PROXY 系统环境变量或者通过在 frpc 的配置文件中设置 http_proxy 参数来使用此功能。 仅在 protocol = tcp 时生效。 12345# frpc.ini[common]server_addr = x.x.x.xserver_port = 7000http_proxy = http://user:pwd@192.168.1.128:8080 插件默认情况下，frpc 只会转发请求到本地 tcp 或 udp 端口。 插件模式是为了在客户端提供更加丰富的功能，目前内置的插件有 unix_domain_socket、http_proxy、socks5。具体使用方式请查看使用示例。 通过 plugin 指定需要使用的插件，插件的配置参数都以 plugin_ 开头。使用插件后 local_ip 和 local_port 不再需要配置。 使用 http_proxy 插件的示例: 1234567# frpc.ini[http_proxy]type = tcpremote_port = 6000plugin = http_proxyplugin_http_user = abcplugin_http_passwd = abc plugin_http_user 和 plugin_http_passwd 即为 http_proxy 插件可选的配置参数。 开发计划计划在后续版本中加入的功能与优化，排名不分先后，如果有其他功能建议欢迎在 issues 中反馈。 frps 记录 http 请求日志。 frps 支持直接反向代理，类似 haproxy。 frpc 支持负载均衡到后端不同服务。 frpc 支持直接作为 webserver 访问指定静态页面。 支持 udp 打洞的方式，提供两边内网机器直接通信，流量不经过服务器转发。 集成对 k8s 等平台的支持。 为 frp 做贡献frp 是一个免费且开源的项目，我们欢迎任何人为其开发和进步贡献力量。 在使用过程中出现任何问题，可以通过 issues 来反馈。 Bug 的修复可以直接提交 Pull Request 到 dev 分支。 如果是增加新的功能特性，请先创建一个 issue 并做简单描述以及大致的实现方法，提议被采纳后，就可以创建一个实现新特性的 Pull Request。 欢迎对说明文档做出改善，帮助更多的人使用 frp，特别是英文文档。 贡献代码请提交 PR 至 dev 分支，master 分支仅用于发布稳定可用版本。 如果你有任何其他方面的问题，欢迎反馈至 fatedier@gmail.com 共同交流。 提醒：和项目相关的问题最好在 issues 中反馈，这样方便其他有类似问题的人可以快速查找解决方法，并且也避免了我们重复回答一些问题。 捐助如果您觉得 frp 对你有帮助，欢迎给予我们一定的捐助来维持项目的长期发展。 frp 交流群：606194980 (QQ 群号) 支付宝扫码捐赠 微信支付捐赠 Paypal 捐赠海外用户推荐通过 Paypal 向作者的账户 **fatedier@gmail.com** 进行捐赠。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Configure Git to use a proxy]]></title>
    <url>%2F2017%2F10%2F13%2FSet-proxy-for-git%2F</url>
    <content type="text"><![CDATA[From: https://gist.github.com/evantoli/f8c23a37eb3558ab8765 In BriefYou may need to configure a proxy server if you’re having trouble cloningor fetching from a remote repository or getting an errorlike unable to access &#39;...&#39; Couldn&#39;t resolve host &#39;...&#39;.Consider something like: 1git config --global http.proxy http://proxyUsername:proxyPassword@proxy.server.com:port Or for a specific domain, something like: 12git config --global http.https://domain.com.proxy http://proxyUsername:proxyPassword@proxy.server.com:portgit config --global http.https://domain.com.sslVerify false Setting http.&lt;url&gt;.sslVerify to false may help you quickly get going if your workplaceemploys man-in-the-middle HTTPS proxying. Longer term, you could get theroot CA that they are applying to the certificate chainand specify it with either http.sslCAInfo or http.sslCAPath. See also the git-config documentation, especially the followingsections if you’re having HTTPS/SSL issues http.sslVerify http.sslCAInfo http.sslCAPath http.sslCert http.sslKey http.sslCertPasswordProtected In DetailConfigure the proxyYou can configure these globally in your user ~/.gitconfig file using the --global switch, or local to a repository in its .git/config file. Setting a global proxyConfigure a global proxy if all access to all repos require this proxy 1git config --global http.proxy http://proxyUsername:proxyPassword@proxy.server.com:port Setting a global socks5 proxy1git config --global http.proxy &apos;socks5://server:port&apos; URL specific proxyIf you wish to specify that a proxy should be used for justsome URLs that specify the URL as a git config subsectionusing http.&lt;url&gt;.key notation: 1git config --global http.https://domain.com.proxy http://proxyUsername:proxyPassword@proxy.server.com:port Which will result in the following in the ~/.gitconfig file: 123[http][http &quot;https://domain.com&quot;] proxy = http://proxyUsername:proxyPassword@proxy.server.com:port Handle subsequent SSL protocol errorsIf you’re still having trouble cloning or fetching and are now gettingan unable to access &#39;https://...&#39;: Unknown SSL protocol error in connection to ...:443 thenyou may decide to switch off SSL verification for the single operationby using the -c http.sslVerify=false option 1git -c http.sslVerify=false clone https://domain.com/path/to/git Once cloned, you may decide set this for just this clonedrepository’s .git/config by doing. Notice the absence of the --global 1git config http.sslVerify false If you choose to make it global then limit it to a URL usingthe http.&lt;url&gt;.sslVerify notation: 1git config --global http.https://domain.com.sslVerify false Which will result in the following in the ~/.gitconfig file: 1234[http][http &quot;https://domain.com&quot;] proxy = http://proxyUsername:proxyPassword@proxy.server.com:port sslVerify = false Show current configurationTo show the current configuration of all http sections 1git config --global --get-regexp http.* If you are in a locally cloned repository folder then you dropthe --global and see all current config: 1git config --get-regexp http.* Unset a proxy or SSL verificationUse the --unset flag to remove configuration being specific about theproperty – for example whether it was http.proxy or http.&lt;url&gt;.proxy.Consider using any of the following: 12345git config --global --unset http.proxygit config --global --unset http.https://domain.com.proxygit config --global --unset http.sslVerifygit config --global --unset http.https://domain.com.sslVerify]]></content>
  </entry>
  <entry>
    <title><![CDATA[手动编译Spigot]]></title>
    <url>%2F2017%2F10%2F04%2FHow-to-build-spigot-on-Windows%2F</url>
    <content type="text"><![CDATA[其实官网的教程很简单，只有一条命令：1java -jar BuildTools.jar 确实，用这一条命令就能完成，不过踩了一些坑。做一下记录。前往https://git-scm.com/下载Git，http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html#javasejdk下载jdk。在国内首先要解决的是网络问题，否则数百MB的源码得很长时间才能下载好，然后，内存至少为2GB，1GB 是不够的，想来前几天编译总是失败的原因就是这个。内存不够，会出现下面这个错误:12345678910111213141516171819202122232425Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at org.objectweb.asm.ClassReader.readLabel(ClassReader.java:2403) at org.objectweb.asm.ClassReader.readCode(ClassReader.java:1324) at org.objectweb.asm.ClassReader.readMethod(ClassReader.java:1165) at org.objectweb.asm.ClassReader.accept(ClassReader.java:727) at org.objectweb.asm.ClassReader.accept(ClassReader.java:525) at net.md_5.ss.repo.JarRepo.getClass0(JarRepo.java:38) at net.md_5.ss.repo.ClassRepo.getClass(ClassRepo.java:22) at net.md_5.ss.repo.AggregateRepo.getClass0(AggregateRepo.java:30) at net.md_5.ss.repo.ClassRepo.getClass(ClassRepo.java:22) at net.md_5.ss.remapper.EnhancedRemapper.findMethodDeclarer(EnhancedRemapper.java:67) at net.md_5.ss.remapper.EnhancedRemapper.mapMethodName(EnhancedRemapper.java:33) at org.objectweb.asm.commons.MethodRemapper.doVisitMethodInsn(MethodRemapper.java:155) at org.objectweb.asm.commons.MethodRemapper.visitMethodInsn(MethodRemapper.java:142) at org.objectweb.asm.ClassReader.readCode(ClassReader.java:1647) at org.objectweb.asm.ClassReader.readMethod(ClassReader.java:1165) at org.objectweb.asm.ClassReader.accept(ClassReader.java:727) at org.objectweb.asm.ClassReader.accept(ClassReader.java:525) at net.md_5.ss.model.ClassInfo.remap(ClassInfo.java:120) at net.md_5.ss.SpecialSource.map(SpecialSource.java:96) at net.md_5.ss.SpecialSource.main(SpecialSource.java:44)Exception in thread &quot;main&quot; java.lang.RuntimeException: Error running command, return status !=0: [java, -jar, BuildData/bin/SpecialSource-2.jar, map, -i, work/minecraft_server.1.12.2.jar, -m, BuildData/mappings/bukkit-1.12.2-cl.csrg, -o, work/mapped.cf6b1333.jar-cl] at org.spigotmc.builder.Builder.runProcess(Builder.java:555) at org.spigotmc.builder.Builder.main(Builder.java:313) at org.spigotmc.builder.Bootstrap.main(Bootstrap.java:23) 很奇怪的一点是，因为我首先考虑了网络问题，所以我首先在VPS上执行编译，以便所有的源码全部下载好，然后打包下载到本地，再在本地编译，出现的错误同样是上面这个错误。最后无奈，动用非常手段，让网络正常一点，清空工程目录，单独执行编译命令才成功。来张合影编译成功后会在BuildTools同级目录里面出现craftbukkit-1.12.2.jar和spigot-1.12.2.jar，好了，拿去愉快的玩耍吧。]]></content>
      <tags>
        <tag>Minecraft</tag>
        <tag>Spigot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio启用IPv6支持]]></title>
    <url>%2F2017%2F09%2F30%2Fandroid-studio-ipv6%2F</url>
    <content type="text"><![CDATA[方法打开AndroidStudio主程序所在目录，右键编辑文件“studio64.exe.vmoptions”，将第19行的-Djava.net.preferIPv4Stack=true改成-Djava.net.preferIPv4Stack=false。见文章 一些说明原本的配置文件中的-Djava.net.preferIPv4Stack应该是开启唯IPv4，也就是说，Android stdio只会从IPv4通道连接网络。在默认情况下，我屏蔽掉IPv4网络，也就是仅仅留下IPv6，并且，Android Studio无法更新SDK，在连接上IPv4的情况下，可以看到Android Studio连接了dl.google.com，并且此站点可以通过IPv6连接，但是Android Studio在纯IPv6网络情况下无法连接网络，那么问题就出在Android Studio身上了，更改主程序的配置文件可以使用IPv6网络。 原文作者将配置文件改为 12-Djava.net.preferIPv4Stack=false-Djava.net.preferIPv6Addresses=true 开启了唯IPv6，那么切换到IPv4环境时又需要再改一次配置文件，那么倒不如把唯IPv4关掉，这样到底是使用IPv6还是IPv4，就由主机所连接的网络来决定了，而不是由Android Studio和网络环境来决定。 学校的网络同时支持IPv6和IPv4，能走IPv6的时候，就不走IPv4了，毕竟更新一个SDK也是好多GB流量。 网络环境更改办法For Windows将以下内容添加到C:\Windows\System32\drivers\etc\hosts 122401:3800:4001:806::1009 dl.google.com2401:3800:4001:806::1009 dl.l.google.com 在电脑能连接上IPv6网络的情况下，连接dl.google.com的流量会被引向IPv6通道，即使电脑连接了IPv4网络。若电脑仅连接了IPv4，则此规则不生效。 For LinuxLinux的hosts文件在/etc/hosts，同样把上面的地址添加就好，但是这样有一个弊端——在电脑处于纯IPv4网络时，规则仍然生效，于是Android Studio又连不上网络了。 最优的解决办法是更改电脑所连接的网络环境的hosts文件，比如路由器的，在能连接上IPv6的路由器上，更改其hosts文件，这样电脑连接这个路由器的时候，就能走IPv6，电脑连接上其他仅支持IPv4的网络时，走IPv4，不用更改本机的hosts环境，就不用在切换网络之后，还要更改本机的hosts文件。感觉这点Linux就不如Windows了。 其他的一些想法在很久很久以前，Android_SDK的源还在国外，这可把国内的开发者弄得苦不堪言，SDK就足够折腾一番了，现在的dl.google.com主机位于北京，速度还不错，延迟也很低。对于谷歌来说，在国内多部署几个服务器并不算什么，但是，口碑一下子涨了好多吧，毕竟方便了那么多，而且支持IPv6，真是要给谷歌老大几朵花了。 其实吧，说到底，还是为了钱，大陆毕竟是一块大蛋糕，谷歌也想来分一块，不知道什么时候来呢？And，和Android 8一块来的，谷歌也带来Kotlin对安卓的支持，这是不是对Oracle的一点警示呢。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言调用系统命令]]></title>
    <url>%2F2017%2F09%2F14%2Fuse-cmd-coomand-in-cpp%2F</url>
    <content type="text"><![CDATA[把命令当作一个字符串作为system函数的参数就行了 示例1234567include&lt;stdlib.h&gt;int main ()&#123; char cmd[]=&#123;"echo Hello shell"&#125; system(cmd); return 0;&#125; 实用示范依据这个思路，写了个小东西,到中国大学mooc官网复制课程链接到http://tools.antlm.com/，然后复制批量改名用链接，粘贴到”download_link.txt”,并与”Downloadmanager.exe”和”aria2c.exe”放到同一个文件夹，双击”Downloadmanager.exe”，就可以开始下载了。很简单的一个小东西，读取download_link.txt的内容，分离下载链接和文件名，将其作为下载器aria2c.exe的参数，调用aria2c，就OK啦。生命重在折腾]]></content>
  </entry>
  <entry>
    <title><![CDATA[关闭Chrome的“推荐的文章”]]></title>
    <url>%2F2017%2F08%2F31%2Fclose-suggested-article%2F</url>
    <content type="text"><![CDATA[手机版的Chrome打开会显示推荐的文章，下载的内容，最近使用的书签，作为资深强迫症，肯定是要把它去掉的。先放解决办法，在地址栏分别输入以下内容： chrome://flags/#enable-ntp-popular-sites chrome://flags/#enable-ntp-remote-suggestions 然后改成“禁用”或者“disable”，Chrome会提示重启，重启后就没有了。 如上图，若要把最近使用的书签，下载内容也去掉，就在地址栏输入: chrome://flags/#enable-ntp-bookmark-suggestion chrome://flags/#enable-ntp-offline-page-download-suggestions chrome://flags/#enable-ntp-asset-download-suggetons 本来没有必要说的，百度一搜一大把，然而其实百度得到的解决办法都是同一个，而且不生效，或者说百度的办法已经失效，比如此文。默默的吐槽一下，转人家的文章转就转吧，不验证是否有用就算吧，还不标明文章出处，翻遍百度无果，求助谷歌，参考https://www.reddit.com/r/Android/comments/6b3ubd/how_to_disable_in_chrome_58_new_tab_page_ntp/，然而，其实此文也有误，去掉下载的内容的办法也不生效，所以写下此文。 都去掉之后，chrome打开就变成这样了 生命重在折腾]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gcc静态编译]]></title>
    <url>%2F2017%2F08%2F25%2Fgcc-static%2F</url>
    <content type="text"><![CDATA[用Gcc(G++)编译一个小程序的时候，本地主机配置好了环境，默认的编译命令使用了动态链接库，这样编译出来的程序在本地主机上是可以直接运行的，并且这样的小程序有另外一个好处——体积特别小，因为动态链接库已经在本地主机上了，不必另外安装，可是把这个小程序拷贝到另外一个电脑上去的话，问题就来了，总是提示缺少”***.dll”文件，解决办法是将动态链接库一起拷贝过去，缺哪一个就拷贝哪一个，另外一个问题又来了，有时候动态链接库还挺大的，数目还不少，对于一些仅有几MB的文件来说，带着一大堆”.dll”文件简直可以逼死强迫症，然后，静态编译就派上用场啦。 情景再现 如图，用默认的动态编译命令，生成的debug版本可执行文件仅有212KB，Release版本仅有157KB，若没有配置环境变量，运行这个程序则会得到如下提示： 并不一定是缺少图中的”libstdc++-6.dll”文件，具体缺少哪些文件是源代码确定的，一劳永逸的办法是使用静态编译命令，这样用到的动态链接库可以集成到可执行文件里面去，直接拷贝到另外一台电脑就可以用了，方法是，最后生成可执行文件时，加上-static参数 CodeBlocks实现依次点击Setting—&gt;Complier settings—&gt;Linker Settings，将参数填在如图的框里面： 静态编译生成的可执行文件体积较大，这里生成的debug版本的可执行文件体积已经达到1540KB，差不多变大了六倍吧，Release版本的达到798KB，对于数MB的小程序来说，用静态编译很合适，免去了各种”.dll”文件缺失的麻烦，把静态编译生成的Release版本的可执行文件拷贝给别人就好了，dll文件可以不用管。 动态编译还是有好处的，链接库只用安装一次，所有用到该链接库的程序就不用自带链接库，程序的体积会变得小一点。 似乎说了一大堆废话╮(╯-╰)╭ 生命重在折腾]]></content>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[启用树莓派摄像头]]></title>
    <url>%2F2017%2F08%2F01%2Fcamera-on-raspberry%2F</url>
    <content type="text"><![CDATA[树莓派有很多官方出品的配件，虽然很多配件比树莓派自己还贵，但是总有一些值得玩的小物件，比如“camera” 目标用这个摄像头做监控 实施过程首先的首先，确保你已经通过putty或者什么软件之类的，或者键盘什么的能连接上树莓派，并且打开了终端。 raspivid &amp; vlc使用命令安装所需软件包： 12sudo apt-get updatesudo apt-get install raspivid vlc -y raspivid是官方的调用树莓派摄像头的软件包，若树莓派上安装的不是raspbian，则需要用其他软件了。 现在你可以输入 1raspivid -t 0 -hf 来显示图像了，如果树莓派上插了显示器，你就能在显示器上看到摄像头的画面了。但是最终目标可不是把显示器插在树莓派上，而是要将画面显示在电脑显示器上。 输入以下命令 1raspivid -o - -t 0 -hf -w 1280 -h 720 -fps 30 |cvlc -vvv stream:///dev/stdin --sout '#standard&#123;access=http,mux=ts,dst=:8160&#125;' :demux=h264 然后，需要在电脑上安装支持流媒体的播放器，这里推荐potplayer 和 VLC media player 按下ctrl u(for potplayer) 或者ctrl N(for vlc media palyer)，将树莓派的ip地址给贴进去，这里我的树莓派的地址是192.168.100.109，你也可以输入 1ifconfig | grep "inet addr" 来查看树莓派的IP地址，然后以http://x.x.x.x:8160的格式粘贴到播放器的框里面去，确定就OK了。 用这个方法简单一些，但是延迟非常高，图像质量也不怎么样，所以提供第二个办法 mjpg-stream用这个的话，延迟低了很多，并且质量也不错，极力推荐。 12345cd ~sudo apt-get install cmake libjpeg8-dev git-coregit clone https://github.com/jacksonliam/mjpg-streamercd mjpg-streamer-master/mjpg-streamer-experimental/make 这个时候可执行程序已经编译好了，可以选择执行make install来将软件安装到系统，也可以不安装，直接执行。 然后： 1./mjpg_streamer -i "./input_raspicam.so -fps 30 -x 854 -y 480" -o "./output_http.so -w ./www" 这个时候，在谷歌浏览器或者火狐浏览器(IE和Edge浏览器不行)打开http://x.x.x.x:8080/?action=stream即可看到树莓派摄像头的画面。 或者将上面的地址粘贴到vlc media player里面去也可以看(potplayer不可以)。 参数调整对于第一种办法，可以通过调整-w -h -fps来调整画面质量，还可以通过添加-rot参数来调整画面旋转角度。 对于第二种办法，可以通过调整-x -y -fps来调整画面质量，也可以通过添加-rot参数来调整画面旋转角度。 PS： 123456789MJPG Streamer Version.: 2.0 i: Using V4L2 device.: /dev/video0 i: Desired Resolution: 640 x 480 i: Frames Per Second.: -1 i: Format............: JPEG i: TV-Norm...........: DEFAULTERROR opening V4L interface: No such file or directory Init v4L2 failed !! exit fatal i: init_VideoIn failed 这个错误是因为使用了不对等的输入文件，input_raspicam.so对应的是树莓派官方摄像头，而input_uvc.so对应的是USB摄像头。 对于两种命令的更多使用方法，查看文档咯。生命重在折腾]]></content>
  </entry>
  <entry>
    <title><![CDATA[Google BBR 提速]]></title>
    <url>%2F2017%2F07%2F18%2FBBR%2F</url>
    <content type="text"><![CDATA[谷歌总是有各种惊喜。偶然挖到这个家伙——BBR。vps加速有之前的锐速，也有kcptun，锐速效果不好，kcptun搭建步骤繁琐，并且是双边加速，很不方便。bbr是单边加速，给服务器一端配置好之后，所有客户端都能用。在教育网的IPv6下，晚八点左右，平时仅能达到500KB，开启bbr之后，可以达到2M+，效果很明显。 安装内核bbr依赖于高于4.9+的Linux内核，要使用bbr，首先得升级内核。对于Ubuntu，可以这样做：1234wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.1/linux-headers-4.10.1-041001_4.10.1-041001.201702260735_all.debwget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.1/linux-headers-4.10.1-041001-generic_4.10.1-041001.201702260735_amd64.debwget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.1/linux-image-4.10.1-041001-generic_4.10.1-041001.201702260735_amd64.debsudo dpkg -i *.deb &amp;&amp; sudo reboot 重启之后，输入uname -sr可以看到新的内核已经安装。 启动bbr输入lsmod | grep bbr，如果结果中没有 tcp_bbr 的话就先执行12345modprobe tcp_bbrecho "tcp_bbr" &gt;&gt; /etc/modules-load.d/modules.confecho "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.confecho "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.confsysctl -p 然后依次执行：12sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control 每条命令输入之后，提示信息里面都有bbr，则表示bbr已经开启。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Code::Blocks 快捷键(中文)]]></title>
    <url>%2F2017%2F07%2F12%2Fzh-CN-shortcut-of-code-blocks%2F</url>
    <content type="text"><![CDATA[编辑相关 Function Shortcut Key 撤销 Ctrl + Z 重复上一次 操作 Ctrl + Shift + Z 剪切选中的文本 Ctrl + X 复制选中的文本 Ctrl + C 从剪贴板粘贴 Ctrl + V 选中所有文本 Ctrl + A 切换头文件/源文件 F11 注释掉代码 Ctrl + Shift + C 撤销注释代码 Ctrl + Shift + X 复制当前行 Ctrl + D 自动完成/填充代码 Ctrl + Space / Ctrl + J Show call tip Ctrl + Shift + Space 将当前行与上一行交换位置 Ctrl + T 添加/取消书签 Ctrl + B 跳转到上一个书签 Alt + PgUp 跳转到下一个书签 Alt + PgDown Toggle current block folding F12 Toggle all folds Shift + F12 This is a list of shortcuts provided by the Code::Blocks’ editor component. These shortcuts cannot be rebound. Function Shortcut Key 放大文本 Ctrl + Keypad “+” 缩小文本 Ctrl + Keypad “-“ 换源文本大小 Ctrl + Keypad “/“ 浏览最近文件 Ctrl + Tab Indent block. Tab Dedent block. Shift + Tab 删除到词首 Ctrl + BackSpace 删除到词尾 Ctrl + Delete 删除到行首 Ctrl + Shift + BackSpace 删除到行尾 Ctrl + Shift + Delete 跳转到文件首 Ctrl + Home Extend selection to start of document. Ctrl + Shift + Home Go to start of display line. Alt + Home Extend selection to start of display line. Alt + Shift + Home Go to end of document. Ctrl + End Extend selection to end of document. Ctrl + Shift + End Go to end of display line. Alt + End Extend selection to end of display line. Alt + Shift + End Expand or contract a fold point. Ctrl + Keypad “*” Create or delete a bookmark. Ctrl + F2 Go to next bookmark. F2 Select to next bookmark. Alt + F2 Find selection. Ctrl + F3 Find selection backwards. Ctrl + Shift + F3 Scroll up. Ctrl + Up Scroll down. Ctrl + Down 前切当前行到剪贴板 Ctrl + L 复制当前行到剪贴板 Ctrl + Shift + T 删除当前行 Ctrl + Shift + L Line transpose with previous. Ctrl + T 复制当前行 Ctrl + D Find matching preprocessor conditional, skipping nested ones. Ctrl + K Select to matching preprocessor conditional. Ctrl + Shift + K Find matching preprocessor conditional backwards, skipping nested ones. Ctrl + J Select to matching preprocessor conditional backwards. Ctrl + Shift + J Previous paragraph. Shift extends selection. Ctrl + [ Next paragraph. Shift extends selection. Ctrl + ] Previous word. Shift extends selection. Ctrl + Left Next word. Shift extends selection. Ctrl + Right Previous word part. Shift extends selection. Ctrl + / Next word part. Shift extends selection. Ctrl + \ 文件相关 Function Shortcut Key 新建空文件 Ctrl + N 打开已存在的文件或项目 Ctrl + O 保存当前文件 Ctrl + S 保存所有文件 Ctrl + Shift + S 关闭当前文件 Ctrl + F4 / Ctrl + W 关闭所有文件 Ctrl + Shift + F4 / Ctrl + Shift + W 预览相关 Function Shortcut Key 显示/隐藏 底部信息面板 F2 显示/隐藏 管理左侧面板 Shift + F2 Move project up (in Project tree) Ctrl + Shift + Up Move project down (in Project tree) Ctrl + Shift + Down 激活前一个项目 Alt + F5 激活下一个项目 Alt + F6 Zoom in / out Ctrl + Roll Mouse Wheel Focus editor CTRL + Alt + E 查找相关 功能 快捷键 查找 Ctrl + F 查找下一个 F3 查找上一个 Shift + F3 在文件内查找 Crtl + Shift + F 替换 Ctrl + R 在文件内替换 Ctrl + Shift + R 跳转到某行 Ctrl + G Goto next changed line Ctrl + F3 Goto previous changed line Ctrl + Shift + F3 跳转到某文件 Alt + G 跳转到某个函数 Ctrl + Alt + G 跳转到上一个函数 Ctrl + PgUp 跳转到下一个函数 Ctrl + PgDn Goto declaration Ctrl + Shift + . Goto implementation Ctrl + . Open include file Ctrl + Alt + . Build Function Shortcut Key 构建 Ctrl + F9 编译当前文件 Ctrl + Shift + F9 运行 Ctrl + F10 构建并运行 F9 重新构建 Ctrl + F11 Debug Function Shortcut Key 开始调试 F8 继续调试 Ctrl + F7 Step over a code block F7 Step into a code block Shift + F7 Step out of a code block Ctrl + Shift + F7 添加/取消断点 F5 运行到下一个断点 F4 上一个错误 Alt + F1 下一个错误 Alt + F2 内容来自官方wiki:http://wiki.codeblocks.org/index.php?title=Keyboard_Shortcuts ，看来得抽空翻译一下d=====(￣▽￣*)b]]></content>
  </entry>
  <entry>
    <title><![CDATA[Code::Blocks 快捷键]]></title>
    <url>%2F2017%2F07%2F05%2Fshortcut-of-code-blocks%2F</url>
    <content type="text"><![CDATA[Editor Function Shortcut Key Undo last action Ctrl + Z Redo last action Ctrl + Shift + Z Cut selected text Ctrl + X Copy selected text Ctrl + C Paste text from clipboard Ctrl + V Select all text Ctrl + A Swap header / source F11 Comment highlighted code Ctrl + Shift + C Uncomment highlighted code Ctrl + Shift + X Duplicate line caret is on Ctrl + D Auto-complete / Abbreviations Ctrl + Space / Ctrl + J Show call tip Ctrl + Shift + Space Swap line caret is on with line above it Ctrl + T Toggle bookmark Ctrl + B Goto previous bookmark Alt + PgUp Goto next bookmark Alt + PgDown Toggle current block folding F12 Toggle all folds Shift + F12 This is a list of shortcuts provided by the Code::Blocks’ editor component. These shortcuts cannot be rebound. Function Shortcut Key Magnify text size. Ctrl + Keypad “+” Reduce text size. Ctrl + Keypad “-“ Restore text size to normal. Ctrl + Keypad “/“ Cycle through recent files. Ctrl + Tab Indent block. Tab Dedent block. Shift + Tab Delete to start of word. Ctrl + BackSpace Delete to end of word. Ctrl + Delete Delete to start of line. Ctrl + Shift + BackSpace Delete to end of line. Ctrl + Shift + Delete Go to start of document. Ctrl + Home Extend selection to start of document. Ctrl + Shift + Home Go to start of display line. Alt + Home Extend selection to start of display line. Alt + Shift + Home Go to end of document. Ctrl + End Extend selection to end of document. Ctrl + Shift + End Go to end of display line. Alt + End Extend selection to end of display line. Alt + Shift + End Expand or contract a fold point. Ctrl + Keypad “*” Create or delete a bookmark. Ctrl + F2 Go to next bookmark. F2 Select to next bookmark. Alt + F2 Find selection. Ctrl + F3 Find selection backwards. Ctrl + Shift + F3 Scroll up. Ctrl + Up Scroll down. Ctrl + Down Line cut. Ctrl + L Line copy. Ctrl + Shift + T Line delete. Ctrl + Shift + L Line transpose with previous. Ctrl + T Line duplicate. Ctrl + D Find matching preprocessor conditional, skipping nested ones. Ctrl + K Select to matching preprocessor conditional. Ctrl + Shift + K Find matching preprocessor conditional backwards, skipping nested ones. Ctrl + J Select to matching preprocessor conditional backwards. Ctrl + Shift + J Previous paragraph. Shift extends selection. Ctrl + [ Next paragraph. Shift extends selection. Ctrl + ] Previous word. Shift extends selection. Ctrl + Left Next word. Shift extends selection. Ctrl + Right Previous word part. Shift extends selection. Ctrl + / Next word part. Shift extends selection. Ctrl + \ Files Function Shortcut Key New file or project Ctrl + N Open existing file or project Ctrl + O Save current file Ctrl + S Save all files Ctrl + Shift + S Close current file Ctrl + F4 / Ctrl + W Close all files Ctrl + Shift + F4 / Ctrl + Shift + W View Function Shortcut Key Show / hide Messages pane F2 Show / hide Management pane Shift + F2 Move project up (in Project tree) Ctrl + Shift + Up Move project down (in Project tree) Ctrl + Shift + Down Activate prior (in Project tree) Alt + F5 Activate next (in Project tree) Alt + F6 Zoom in / out Ctrl + Roll Mouse Wheel Focus editor CTRL + Alt + E Search Function Shortcut Key Find Ctrl + F Find next F3 Find previous Shift + F3 Find in files Crtl + Shift + F Replace Ctrl + R Replace in files Ctrl + Shift + R Goto line Ctrl + G Goto next changed line Ctrl + F3 Goto previous changed line Ctrl + Shift + F3 Goto file Alt + G Goto function Ctrl + Alt + G Goto previous function Ctrl + PgUp Goto next function Ctrl + PgDn Goto declaration Ctrl + Shift + . Goto implementation Ctrl + . Open include file Ctrl + Alt + . Build Function Shortcut Key Build Ctrl + F9 Compile current file Ctrl + Shift + F9 Run Ctrl + F10 Build and Run F9 Rebuild Ctrl + F11 Debug Function Shortcut Key Debug F8 Continue debugging Ctrl + F7 Step over a code block F7 Step into a code block Shift + F7 Step out of a code block Ctrl + Shift + F7 Toggle breakpoint F5 Run to cursor F4 Previous error Alt + F1 Next error Alt + F2 内容来自官方wiki:http://wiki.codeblocks.org/index.php?title=Keyboard_Shortcuts看来得抽空翻译一下d=====(￣▽￣*)b]]></content>
  </entry>
  <entry>
    <title><![CDATA[也许是一个特性]]></title>
    <url>%2F2017%2F07%2F02%2Fan-error%2F</url>
    <content type="text"><![CDATA[遇到一个神奇的现象，仅作记录，如下代码：12345678#include &lt;iostream&gt;using namespace std;int main()&#123; printf("啊哈哈"); return 0;&#125; 一眼看过去，肯定会编译错误，printf的头文件cstdio都没有包含进去，事实证明，确实如此：那么，再来一张如何:这几日折腾putty，下载了gcc-7.1.0，顺手把Code::Blocks的编译器换了，结果出这么个岔子，也许7.1.0版本的iostream已经包含了printf了吧，某天应该会被这个“特性”坑一把吧!生命重在折腾]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Windows中手动编译Putty]]></title>
    <url>%2F2017%2F06%2F30%2Fbuild-putty-on-Windows%2F</url>
    <content type="text"><![CDATA[最近琢磨着汉化一下putty，于是下载了其源代码，解压后，阅读其文档，发现，其实重新编译似乎并不是太麻烦。 使用VS的编译器编译第一种办法是使用VS的编译器来编译putty，安装VS后，在开始菜单里面，Visual Studio的子菜单下面找到Developer Command Prompt for vs 2017(PS:我电脑上安装了Visual Studio 2017，所以是for 2017，具体视安装版本而定)，然后，切换目录到解压后的putty源码所在的目录的windows下面，使用命令namek -f Makefile.vc,即可编译putty，如图:如图，为编译完成的样子于是，就可以在Windows文件夹内看到编译好的putty套件了耗时一分钟都不到，不愧为巨硬出品。 使用MinGW编译使用VS的编译器来编译的前提是安装了Visual Studio，但是Visual Studio安装包好几个G，安装时间超长，有时候还联网检查一下更新什么的，巨硬的服务器貌似都在国外，下载速度超慢，所以使用MinGW编译也不失为一个方便的选择。这里直接提供可用的MinGW包， 下载后双击解压，然后把解压后文件夹内的bin文件夹添加到环境变量。假设bin文件的完整路径为D:\MinGW-7.1.0\bin在开始菜单上点右键，然后点击命令提示符，输入1set PATH=D:\MinGW-7.1.0\bin;%PATH% 验证是否添加成功若出现如上图的提示信息，即表示添加成功。然后，切换目录到putty目录下的windows文件夹内，使用make -f Makefile.mgw即可编译putty如图为编译成功： 碎碎念以上为我自己试验之后，成功编译的步骤，中途还是踩了一些坑。使用VS的编译其很顺利，一次就通过了，使用MinGW的编译的过程比较曲折，首先是下载了MinGW-w64的包，忍受着超级慢的网速安装好之后，发现没有make工具，其bin目录的mingw32-make也无法编译，差不多要放弃的时候，又在Gayhub上发现了这个mingw-distro,作者网站为https://nuwen.net/mingw.html,下载好，配置好环境变量，进行编译的时候又出现这个错误123456789gcc -Wall -O2 -D_WINDOWS -DDEBUG -DWIN32S_COMPAT -D_NO_OLDNAMES -I.././ -I../charset/ -I../windows/ -I../unix/ -D_WIN32_IE=0x0500 -DWINVER=0x0500 -D_WIN32_WINDOWS=0x0410 -D_WIN32_WINNT=0x0500 -c ../windows/window.cIn file included from ../windows/window.c:29:0:d:\mingw-7.1.0\x86_64-w64-mingw32\include\multimon.h: In function &apos;IsPlatformNT&apos;:d:\mingw-7.1.0\x86_64-w64-mingw32\include\multimon.h:130:38: error: &apos;osvi&apos; undeclared (first use in this function); did you mean &apos;oi&apos;? oi.dwOSVersionInfoSize = sizeof (osvi); ^~~~ oid:\mingw-7.1.0\x86_64-w64-mingw32\include\multimon.h:130:38: note: each undeclared identifier is reported only once for each function it appears inmake: *** [Makefile.mgw:963: window.o] Error 1 问遍百度不得解，问Google，得到的只是4gbug提交报告。然后又转战MinGW原版，cygwn，均以失败告终，最后还是回到Gayhub的这个版本，最后折腾一番，更改x86_64-w64-mingw32\include\multimon.h的内容如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509//=============================================================================//// multimon.h -- Stub module that fakes multiple monitor apis on Win32 OSes// without them.//// By using this header your code will get back default values from// GetSystemMetrics() for new metrics, and the new multimonitor APIs// will act like only one display is present on a Win32 OS without// multimonitor APIs.//// Exactly one source must include this with COMPILE_MULTIMON_STUBS defined.//// Copyright (c) Microsoft Corporation. All rights reserved. ////=============================================================================#include &lt;winapifamily.h&gt;#pragma region Desktop Family#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)#ifdef __cplusplusextern "C" &#123; // Assume C declarations for C++#endif // __cplusplus//// If we are building with Win95/NT4 headers, we need to declare// the multimonitor-related metrics and APIs ourselves.//#ifndef SM_CMONITORS#define SM_XVIRTUALSCREEN 76#define SM_YVIRTUALSCREEN 77#define SM_CXVIRTUALSCREEN 78#define SM_CYVIRTUALSCREEN 79#define SM_CMONITORS 80#define SM_SAMEDISPLAYFORMAT 81// HMONITOR is already declared if WINVER &gt;= 0x0500 in windef.h// This is for components built with an older version number.//#if !defined(HMONITOR_DECLARED) &amp;&amp; (WINVER &lt; 0x0500)DECLARE_HANDLE(HMONITOR);#define HMONITOR_DECLARED#endif#define MONITOR_DEFAULTTONULL 0x00000000#define MONITOR_DEFAULTTOPRIMARY 0x00000001#define MONITOR_DEFAULTTONEAREST 0x00000002#define MONITORINFOF_PRIMARY 0x00000001typedef struct tagMONITORINFO&#123; DWORD cbSize; RECT rcMonitor; RECT rcWork; DWORD dwFlags;&#125; MONITORINFO, *LPMONITORINFO;#ifndef CCHDEVICENAME#define CCHDEVICENAME 32#endif#ifdef __cplusplustypedef struct tagMONITORINFOEXA : public tagMONITORINFO&#123; CHAR szDevice[CCHDEVICENAME];&#125; MONITORINFOEXA, *LPMONITORINFOEXA;typedef struct tagMONITORINFOEXW : public tagMONITORINFO&#123; WCHAR szDevice[CCHDEVICENAME];&#125; MONITORINFOEXW, *LPMONITORINFOEXW;#ifdef UNICODEtypedef MONITORINFOEXW MONITORINFOEX;typedef LPMONITORINFOEXW LPMONITORINFOEX;#elsetypedef MONITORINFOEXA MONITORINFOEX;typedef LPMONITORINFOEXA LPMONITORINFOEX;#endif // UNICODE#else // ndef __cplusplustypedef struct tagMONITORINFOEXA&#123; MONITORINFO; CHAR szDevice[CCHDEVICENAME];&#125; MONITORINFOEXA, *LPMONITORINFOEXA;typedef struct tagMONITORINFOEXW&#123; MONITORINFO; WCHAR szDevice[CCHDEVICENAME];&#125; MONITORINFOEXW, *LPMONITORINFOEXW;#ifdef UNICODEtypedef MONITORINFOEXW MONITORINFOEX;typedef LPMONITORINFOEXW LPMONITORINFOEX;#elsetypedef MONITORINFOEXA MONITORINFOEX;typedef LPMONITORINFOEXA LPMONITORINFOEX;#endif // UNICODE#endiftypedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);#ifndef DISPLAY_DEVICE_ATTACHED_TO_DESKTOPtypedef struct _DISPLAY_DEVICEA &#123; DWORD cb; CHAR DeviceName[32]; CHAR DeviceString[128]; DWORD StateFlags; CHAR DeviceID[128]; CHAR DeviceKey[128];&#125; DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;typedef struct _DISPLAY_DEVICEW &#123; DWORD cb; WCHAR DeviceName[32]; WCHAR DeviceString[128]; DWORD StateFlags; WCHAR DeviceID[128]; WCHAR DeviceKey[128];&#125; DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;#ifdef UNICODEtypedef DISPLAY_DEVICEW DISPLAY_DEVICE;typedef PDISPLAY_DEVICEW PDISPLAY_DEVICE;typedef LPDISPLAY_DEVICEW LPDISPLAY_DEVICE;#elsetypedef DISPLAY_DEVICEA DISPLAY_DEVICE;typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;#endif // UNICODE#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001#define DISPLAY_DEVICE_MULTI_DRIVER 0x00000002#define DISPLAY_DEVICE_PRIMARY_DEVICE 0x00000004#define DISPLAY_DEVICE_MIRRORING_DRIVER 0x00000008#define DISPLAY_DEVICE_VGA_COMPATIBLE 0x00000010#endif#endif // SM_CMONITORS#undef GetMonitorInfo#undef GetSystemMetrics#undef MonitorFromWindow#undef MonitorFromRect#undef MonitorFromPoint#undef EnumDisplayMonitors#undef EnumDisplayDevices//// Define COMPILE_MULTIMON_STUBS to compile the stubs;// otherwise, you get the declarations.//#ifdef COMPILE_MULTIMON_STUBS//-----------------------------------------------------------------------------//// Implement the API stubs.////-----------------------------------------------------------------------------#ifndef _MULTIMON_USE_SECURE_CRT#if defined(__GOT_SECURE_LIB__) &amp;&amp; __GOT_SECURE_LIB__ &gt;= 200402L#define _MULTIMON_USE_SECURE_CRT 1#else#define _MULTIMON_USE_SECURE_CRT 0#endif#endif#ifndef MULTIMON_FNS_DEFINEDint (WINAPI* g_pfnGetSystemMetrics)(int) = NULL;HMONITOR (WINAPI* g_pfnMonitorFromWindow)(HWND, DWORD) = NULL;HMONITOR (WINAPI* g_pfnMonitorFromRect)(LPCRECT, DWORD) = NULL;HMONITOR (WINAPI* g_pfnMonitorFromPoint)(POINT, DWORD) = NULL;BOOL (WINAPI* g_pfnGetMonitorInfo)(HMONITOR, LPMONITORINFO) = NULL;BOOL (WINAPI* g_pfnEnumDisplayMonitors)(HDC, LPCRECT, MONITORENUMPROC, LPARAM) = NULL;BOOL (WINAPI* g_pfnEnumDisplayDevices)(PVOID, DWORD, PDISPLAY_DEVICE,DWORD) = NULL;BOOL g_fMultiMonInitDone = FALSE;BOOL g_fMultimonPlatformNT = FALSE;#endifBOOL IsPlatformNT()&#123; OSVERSIONINFOA osvi = &#123;0&#125;; osvi.dwOSVersionInfoSize = sizeof(osvi); GetVersionExA((OSVERSIONINFOA*)&amp;osvi); return (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId); &#125;BOOL InitMultipleMonitorStubs(void)&#123; HMODULE hUser32; if (g_fMultiMonInitDone) &#123; return g_pfnGetMonitorInfo != NULL; &#125; g_fMultimonPlatformNT = IsPlatformNT(); hUser32 = GetModuleHandle(TEXT("USER32")); if (hUser32 &amp;&amp; (*(FARPROC*)&amp;g_pfnGetSystemMetrics = GetProcAddress(hUser32,"GetSystemMetrics")) != NULL &amp;&amp; (*(FARPROC*)&amp;g_pfnMonitorFromWindow = GetProcAddress(hUser32,"MonitorFromWindow")) != NULL &amp;&amp; (*(FARPROC*)&amp;g_pfnMonitorFromRect = GetProcAddress(hUser32,"MonitorFromRect")) != NULL &amp;&amp; (*(FARPROC*)&amp;g_pfnMonitorFromPoint = GetProcAddress(hUser32,"MonitorFromPoint")) != NULL &amp;&amp; (*(FARPROC*)&amp;g_pfnEnumDisplayMonitors = GetProcAddress(hUser32,"EnumDisplayMonitors")) != NULL &amp;&amp;#ifdef UNICODE (*(FARPROC*)&amp;g_pfnEnumDisplayDevices = GetProcAddress(hUser32,"EnumDisplayDevicesW")) != NULL &amp;&amp; (*(FARPROC*)&amp;g_pfnGetMonitorInfo = g_fMultimonPlatformNT ? GetProcAddress(hUser32,"GetMonitorInfoW") : GetProcAddress(hUser32,"GetMonitorInfoA")) != NULL#else (*(FARPROC*)&amp;g_pfnGetMonitorInfo = GetProcAddress(hUser32,"GetMonitorInfoA")) != NULL &amp;&amp; (*(FARPROC*)&amp;g_pfnEnumDisplayDevices = GetProcAddress(hUser32,"EnumDisplayDevicesA")) != NULL#endif ) &#123; g_fMultiMonInitDone = TRUE; return TRUE; &#125; else &#123; g_pfnGetSystemMetrics = NULL; g_pfnMonitorFromWindow = NULL; g_pfnMonitorFromRect = NULL; g_pfnMonitorFromPoint = NULL; g_pfnGetMonitorInfo = NULL; g_pfnEnumDisplayMonitors = NULL; g_pfnEnumDisplayDevices = NULL; g_fMultiMonInitDone = TRUE; return FALSE; &#125;&#125;//-----------------------------------------------------------------------------//// fake implementations of Monitor APIs that work with the primary display// no special parameter validation is made since these run in client code////-----------------------------------------------------------------------------int WINAPIxGetSystemMetrics(int nIndex)&#123; if (InitMultipleMonitorStubs()) return g_pfnGetSystemMetrics(nIndex); switch (nIndex) &#123; case SM_CMONITORS: case SM_SAMEDISPLAYFORMAT: return 1; case SM_XVIRTUALSCREEN: case SM_YVIRTUALSCREEN: return 0; case SM_CXVIRTUALSCREEN: nIndex = SM_CXSCREEN; break; case SM_CYVIRTUALSCREEN: nIndex = SM_CYSCREEN; break; &#125; return GetSystemMetrics(nIndex);&#125;#define xPRIMARY_MONITOR ((HMONITOR)0x12340042)HMONITOR WINAPIxMonitorFromPoint(POINT ptScreenCoords, DWORD dwFlags)&#123; if (InitMultipleMonitorStubs()) return g_pfnMonitorFromPoint(ptScreenCoords, dwFlags); if ((dwFlags &amp; (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) || ((ptScreenCoords.x &gt;= 0) &amp;&amp; (ptScreenCoords.x &lt; GetSystemMetrics(SM_CXSCREEN)) &amp;&amp; (ptScreenCoords.y &gt;= 0) &amp;&amp; (ptScreenCoords.y &lt; GetSystemMetrics(SM_CYSCREEN)))) &#123; return xPRIMARY_MONITOR; &#125; return NULL;&#125;HMONITOR WINAPIxMonitorFromRect(LPCRECT lprcScreenCoords, DWORD dwFlags)&#123; if (InitMultipleMonitorStubs()) return g_pfnMonitorFromRect(lprcScreenCoords, dwFlags); if ((dwFlags &amp; (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) || ((lprcScreenCoords-&gt;right &gt; 0) &amp;&amp; (lprcScreenCoords-&gt;bottom &gt; 0) &amp;&amp; (lprcScreenCoords-&gt;left &lt; GetSystemMetrics(SM_CXSCREEN)) &amp;&amp; (lprcScreenCoords-&gt;top &lt; GetSystemMetrics(SM_CYSCREEN)))) &#123; return xPRIMARY_MONITOR; &#125; return NULL;&#125;HMONITOR WINAPIxMonitorFromWindow(HWND hWnd, DWORD dwFlags)&#123; WINDOWPLACEMENT wp; if (InitMultipleMonitorStubs()) return g_pfnMonitorFromWindow(hWnd, dwFlags); if (dwFlags &amp; (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) return xPRIMARY_MONITOR; if (IsIconic(hWnd) ? GetWindowPlacement(hWnd, &amp;wp) : GetWindowRect(hWnd, &amp;wp.rcNormalPosition)) &#123; return xMonitorFromRect(&amp;wp.rcNormalPosition, dwFlags); &#125; return NULL;&#125;BOOL WINAPIxGetMonitorInfo(HMONITOR hMonitor, _Inout_ LPMONITORINFO lpMonitorInfo)&#123; RECT rcWork; if (InitMultipleMonitorStubs()) &#123; BOOL f = g_pfnGetMonitorInfo(hMonitor, lpMonitorInfo);#ifdef UNICODE if (f &amp;&amp; !g_fMultimonPlatformNT &amp;&amp; (lpMonitorInfo-&gt;cbSize &gt;= sizeof(MONITORINFOEX))) &#123; MultiByteToWideChar(CP_ACP, 0, (LPSTR)((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice, -1, ((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice)/sizeof(TCHAR))); &#125;#endif return f; &#125; if ((hMonitor == xPRIMARY_MONITOR) &amp;&amp; lpMonitorInfo &amp;&amp; (lpMonitorInfo-&gt;cbSize &gt;= sizeof(MONITORINFO)) &amp;&amp; SystemParametersInfoA(SPI_GETWORKAREA, 0, &amp;rcWork, 0)) &#123; lpMonitorInfo-&gt;rcMonitor.left = 0; lpMonitorInfo-&gt;rcMonitor.top = 0; lpMonitorInfo-&gt;rcMonitor.right = GetSystemMetrics(SM_CXSCREEN); lpMonitorInfo-&gt;rcMonitor.bottom = GetSystemMetrics(SM_CYSCREEN); lpMonitorInfo-&gt;rcWork = rcWork; lpMonitorInfo-&gt;dwFlags = MONITORINFOF_PRIMARY; if (lpMonitorInfo-&gt;cbSize &gt;= sizeof(MONITORINFOEX)) &#123;#ifdef UNICODE MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, ((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice)/sizeof(TCHAR)));#else // UNICODE#if _MULTIMON_USE_SECURE_CRT strncpy_s(((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice)/sizeof(TCHAR)), TEXT("DISPLAY"), (sizeof(((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice)/sizeof(TCHAR)) - 1);#else lstrcpyn(((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice, TEXT("DISPLAY"), (sizeof(((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice)/sizeof(TCHAR)));#endif // _MULTIMON_USE_SECURE_CRT#endif // UNICODE &#125; return TRUE; &#125; return FALSE;&#125;BOOL WINAPIxEnumDisplayMonitors( HDC hdcOptionalForPainting, LPCRECT lprcEnumMonitorsThatIntersect, MONITORENUMPROC lpfnEnumProc, LPARAM dwData)&#123; RECT rcLimit; if (InitMultipleMonitorStubs()) &#123; return g_pfnEnumDisplayMonitors( hdcOptionalForPainting, lprcEnumMonitorsThatIntersect, lpfnEnumProc, dwData); &#125; if (!lpfnEnumProc) return FALSE; rcLimit.left = 0; rcLimit.top = 0; rcLimit.right = GetSystemMetrics(SM_CXSCREEN); rcLimit.bottom = GetSystemMetrics(SM_CYSCREEN); if (hdcOptionalForPainting) &#123; RECT rcClip; POINT ptOrg; switch (GetClipBox(hdcOptionalForPainting, &amp;rcClip)) &#123; default: if (!GetDCOrgEx(hdcOptionalForPainting, &amp;ptOrg)) return FALSE; OffsetRect(&amp;rcLimit, -ptOrg.x, -ptOrg.y); if (IntersectRect(&amp;rcLimit, &amp;rcLimit, &amp;rcClip) &amp;&amp; (!lprcEnumMonitorsThatIntersect || IntersectRect(&amp;rcLimit, &amp;rcLimit, lprcEnumMonitorsThatIntersect))) &#123; break; &#125; //fall thru case NULLREGION: return TRUE; case ERROR: return FALSE; &#125; &#125; else &#123; if ( lprcEnumMonitorsThatIntersect &amp;&amp; !IntersectRect(&amp;rcLimit, &amp;rcLimit, lprcEnumMonitorsThatIntersect)) &#123; return TRUE; &#125; &#125; return lpfnEnumProc( xPRIMARY_MONITOR, hdcOptionalForPainting, &amp;rcLimit, dwData);&#125;BOOL WINAPIxEnumDisplayDevices( PVOID Unused, DWORD iDevNum, _Inout_ PDISPLAY_DEVICE lpDisplayDevice, DWORD dwFlags)&#123; if (InitMultipleMonitorStubs()) return g_pfnEnumDisplayDevices(Unused, iDevNum, lpDisplayDevice, dwFlags); if (Unused != NULL) return FALSE; if (iDevNum != 0) return FALSE; if (lpDisplayDevice == NULL || lpDisplayDevice-&gt;cb &lt; sizeof(DISPLAY_DEVICE)) return FALSE;#ifdef UNICODE MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, lpDisplayDevice-&gt;DeviceName, (sizeof(lpDisplayDevice-&gt;DeviceName)/sizeof(TCHAR))); MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, lpDisplayDevice-&gt;DeviceString, (sizeof(lpDisplayDevice-&gt;DeviceString)/sizeof(TCHAR)));#else // UNICODE#if _MULTIMON_USE_SECURE_CRT strncpy_s((LPTSTR)lpDisplayDevice-&gt;DeviceName, (sizeof(lpDisplayDevice-&gt;DeviceName)/sizeof(TCHAR)), TEXT("DISPLAY"), (sizeof(lpDisplayDevice-&gt;DeviceName)/sizeof(TCHAR)) - 1); strncpy_s((LPTSTR)lpDisplayDevice-&gt;DeviceString, (sizeof(lpDisplayDevice-&gt;DeviceString)/sizeof(TCHAR)), TEXT("DISPLAY"), (sizeof(lpDisplayDevice-&gt;DeviceName)/sizeof(TCHAR)) - 1);#else lstrcpyn((LPTSTR)lpDisplayDevice-&gt;DeviceName, TEXT("DISPLAY"), (sizeof(lpDisplayDevice-&gt;DeviceName)/sizeof(TCHAR))); lstrcpyn((LPTSTR)lpDisplayDevice-&gt;DeviceString, TEXT("DISPLAY"), (sizeof(lpDisplayDevice-&gt;DeviceString)/sizeof(TCHAR)));#endif // _MULTIMON_USE_SECURE_CRT#endif // UNICODE lpDisplayDevice-&gt;StateFlags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP | DISPLAY_DEVICE_PRIMARY_DEVICE; return TRUE;&#125;#undef xPRIMARY_MONITOR#undef COMPILE_MULTIMON_STUBS#else // COMPILE_MULTIMON_STUBSextern int WINAPI xGetSystemMetrics(int);extern HMONITOR WINAPI xMonitorFromWindow(HWND, DWORD);extern HMONITOR WINAPI xMonitorFromRect(LPCRECT, DWORD);extern HMONITOR WINAPI xMonitorFromPoint(POINT, DWORD);extern BOOL WINAPI xGetMonitorInfo(HMONITOR, LPMONITORINFO);extern BOOL WINAPI xEnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM);extern BOOL WINAPI xEnumDisplayDevices(PVOID, DWORD, PDISPLAY_DEVICE, DWORD);#endif // COMPILE_MULTIMON_STUBS//// build defines that replace the regular APIs with our versions//#define GetSystemMetrics xGetSystemMetrics#define MonitorFromWindow xMonitorFromWindow#define MonitorFromRect xMonitorFromRect#define MonitorFromPoint xMonitorFromPoint#define GetMonitorInfo xGetMonitorInfo#define EnumDisplayMonitors xEnumDisplayMonitors#define EnumDisplayDevices xEnumDisplayDevices#ifdef __cplusplus&#125;#endif // __cplusplus#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */#pragma endregion 才得以编译通过，在文首给出的链接中，我已经更改这个头文件，也保留了源文件，更改文件名为multimon-bak.h。PS:这个头文件是VS编译器的头文件，我给弄到MinGW里面来了。汉化的事情只能往后再拖一拖了，没想到一个编译就把我给卡住了。生命重在折腾]]></content>
  </entry>
  <entry>
    <title><![CDATA[【推广】实用命令——tldr]]></title>
    <url>%2F2017%2F06%2F30%2Ftool-tldr%2F</url>
    <content type="text"><![CDATA[碎碎念如题，通常遇到一个新的命令需要查询其帮助的时候，一般使用command -h或者man command来查询，但是，有时候仅仅想知道这个命令怎么用，并不想知道具体含义啊(这个命令可能不常用，没有必要仔细阅读手册)，于是，tldr出现了。而且，巨长无比的文档看起来就头疼。 安装安装tldr之前，得先安装好node.js，然后使用命令1$ npm install tldr -g 来进行安装。 使用1$ tldr command 就好了，第一次使用，需要联网下载一些数据，等一下就好了。 展示 生命重在折腾]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Python搭建FTP服务器]]></title>
    <url>%2F2017%2F06%2F18%2FFileTransfer-by-python%2F</url>
    <content type="text"><![CDATA[说明在之前的某篇文章中，介绍了告诉传输文件的办法，在文中，我使用了nginx来共享文件，缺点在于Windows的文件编码方式为GBK，在传输中文名的文件的时候，会出错，Windows下搭建FTP服务器的方式还有Windows自带的Internet Information Service 管理器，此法可解决中文问题，但是CPU占用较高，我的电脑上用IIS(Internet Information Service 管理器)搭建的FTP服务器来传松文件的时候，CPU占用超过30%，但是用nginxCPU占用不到5%。所以，今天换另外一个FTP服务器——pyftpdlib 安装首先，电脑上得有已经安装好的python环境，然后使用pip命令安装1pip insstall pyftpdlib 运行编辑一个纯文本文件，其内容如下12345678910111213141516#coding:utf-8from pyftpdlib.authorizers import DummyAuthorizerfrom pyftpdlib.handlers import FTPHandlerfrom pyftpdlib.servers import FTPServer#新建一个用户组authorizer = DummyAuthorizer()#将用户名，密码，指定目录，权限 添加到里面authorizer.add_user(&quot;fan&quot;, &quot;root&quot;, &quot;E:/UT_Downloads/&quot;, perm=&quot;elr&quot;)#adfmw#这个是添加匿名用户,任何人都可以访问，如果去掉的话，需要输入用户名和密码，可以自己尝试authorizer.add_anonymous(&quot;D:/&quot;)handler = FTPHandlerhandler.authorizer = authorizer#开启服务器server = FTPServer((&quot;127.0.0.1&quot;, 21), handler)server.serve_forever() 其中，E:/UT_Downloads/是需要共享的文件所在路径，可以自行更改，fan和root是用户名和密码，也可以自己改动，而authorizer.add_anonymous(&quot;D:/&quot;)是用来控制是否允许匿名用户登录的，若是把改行注释(行首加#号)，在登录服务器的时候，就需要输入用户名和密码了将文件名后缀设置为.py,在命令行下切换到该文件所在目录，使用python ***.py就可以打开FTP服务器了 连接展示nginx搭建的实际上是http服务器，没办法文件管理器里面打开，用pyftpdlib搭建的是可以在文件管理器里面打开的。 存在的问题 以上示范代码，可以提供文件的下载，但是还不支持文件上传，若有上传文件的需要，可阅读官方的文档。我编辑此文的时候，还未与nginx的性能相比较过。 Windows下的中文乱码描述此问题表现为在浏览器打开FTP服务器是正常的，在文件管理器打开FTP服务器是乱码的。解决办法解决方法为更改pyftpdlib的源代码，到https://github.com/giampaolo/pyftpdlib/下载源代码，更改pyftpdlib文件夹下的filesystems.py,第471行和603的utf8改为gbk,文件handlers.py的1382行的utf8改为gbk，然后在命令行切换到setup.py文件所在的目录，使用命令python setup.py install进行安装。 卸载pyftpdlib由于之前已经通过命令pip insstall pyftpdlib安装过了，所以用源代码安装的时候会提示已经安装，可以通过命令1pip uninstall pyftpdlib 来将之前的pyftpdlib卸载掉，然后再安装更改源代码后的pyftpdlib]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow]]></title>
    <url>%2F2017%2F06%2F13%2Finstall-tensorflow%2F</url>
    <content type="text"><![CDATA[Tensorflow一个强大的工具，安装过程很简单，但是还是踩了不少坑，这里仅作记录。 在树莓派上安装TensoFlow环境描述树莓派安装了2016.12月的jessie版本，并保证sudo apt-get update，后更新所有软件。 安装按照官网的描述，Linux通过命令123$sudo pip install tensorflow (For python 2)$sudo pip3 install tensorflow (For python 3) 第一个问题————pip版本过低即可安装。遇到的第一个问题，是pip版本太低，可通过命令123$sudo pip install --upgrade pip或者$sudo pip3 install --upgrade pip 来安装TensorFlow，在输入以上命令之前，你可能需要先输入123$sudo apt-get install python-pip python-dev (For python 2)$sudo apt-get install python3-pip python3-dev (For python 3) 来安装依赖包。 第二个问题————软件源然后，是遇到的第二个问题，遇到错误提示————cannot fetch index base url https //pypi.python.org/simple/,这个错误完全是网络不通畅导致的，pip默认软件源是pypi.python.org，这个时候就需要更换国内的软件源。在Linux中，更换软件源，需要在root用户的家目录下新建.pip文件夹，在该文件夹内新建文件pip.conf,其内容为12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 或者也可以通过临时指定软件源1$sudo pip install tensorflow -i https://pypi.tuna.tsinghua.edu.cn 来进行安装。 第四个问题————软件源内没有相应软件包以上所说，适用于X86平台的Linux，然而raspberry是ARM平台，国内的源似乎没有ARM平台的软件包，所以必须得指定软件包来安装了。在Github上已经有人编译好了树莓派对应的tensorflow包，我在这里也备份了一下,下载文件tensorflow-1.1.0-cp27-none-linux_armv7l.whl，使用命令pip install tensorflow-1.1.0-cp27-none-linux_armv7l.whl就可以安装了，在rasperry上安装时间还是挺长的。这里需要注意，tensorflow有其它的依赖包，所以最好先更换软件源，再进行安装，否则若是依赖包安装失败，tensorflow也没法装好。 验证安装安装好之后，在终端输入python(若使用python3版本的pip安装的tensorflow，则需要输入python3)来进入，依次输入以下命令 一点点说明 在Windows和Linux上的安装都很方便，配置好软件源之后基本上没什么问题，树莓派因为软件源本身并不具备相应版本的TensorFlow，所以得手动下载相应的TensorFlow，在http://118.89.31.219/src/tensorflow/所留的软件包中，python3对应版本的无法安装，会提示不适用于此平台，目测要么是系统把硬件识别错了，要么就是包本身有问题； 在官方的验证示例中，python2和python3的示范结果不一样，python2的示范结果为Hello,TensorFlow,而python3的示范结果为b&#39;Hello,TensorFlow&#39;； Windows平台只能通过python3安装TensorFlow，python3的print被当作一个函数了，与python2不一样，python3的printf后面需要加括号。生命重在折腾]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux的中文乱码问题]]></title>
    <url>%2F2017%2F05%2F27%2Fencoding-on-linux%2F</url>
    <content type="text"><![CDATA[乱语在Linux经常遇到中文乱码的情况，整理一下: 字符集不能显示中文; 终端不能正常显示中文; 文件名本身便是乱码的(多见于 Windows 下拷贝文件到 Linux )。 解决方案 字符集的问题，大多数情况下，在终端里面输入locale,查看当前系统所支持的字符集，改变当前用户或者系统的字符集，就可以了。如图带utf-8的都可以显示中文，在终端输入 12echo export LANG=zh-CN.UTF-8 &gt;&gt; .bashrcsource .bashrc 来改变当前用户所使用的字符集就可以了； 第二种，终端问题，症状表现为，在GUI界面或者Windows的xshell、putty、cmder远程ssh登录Linux可以正常显示中文，但是Linux主机连接显示器之后，在tty界面(亦称纯字符界面，按ctrl + Alt + F1/2/3/4/5/6可以打开)中文显示为方框或者问号。百度得到的答案有两种——安装zhcon或者fbterm，经试验，fbterm表现效果较佳； 第三种的话，给文件名的编码方式改一下就好，可参考此文章。 PS为了兼容各种语言，生出了N多字符集，若是能够大一统，自然最好了，省得折腾。不过由于各种纠纷，就算有一个字符集能够显示所有文字，还是没办法统一起来。至于tty界面下无法正常显示中文，是因为内核上不支持，可以通过为内核安装补丁解决，也可以通过安装fbterm这样的类终端软件解决，能搞定就好了，管他呢。生命重在折腾]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PreArm:ACRO_BAL_ROLL/PITCH]]></title>
    <url>%2F2017%2F05%2F22%2FPixhwak-error%2F</url>
    <content type="text"><![CDATA[症状开机之后闪黄灯(Pixhawk闪蓝灯或者绿灯表示可以解锁)，用数据线或者数传将电脑和飞控连接之后，在Mission Planner可以看到如下提示信息: 解决办法——Disabling the Pre-arm Safety Check在网页里面已经说了解决办法：可能是Mission Planner版本不一样，我所使用的版本要这样:将红圈位置的选项勾选成如图样子，点击写入参数就好了，可以解锁happy了。生命重在折腾]]></content>
      <tags>
        <tag>无人机</tag>
        <tag>tecnology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 作为无线显示器无法被搜索到]]></title>
    <url>%2F2017%2F05%2F20%2Fwirless-display%2F</url>
    <content type="text"><![CDATA[开始菜单的“连接应用打开后”，在无线显示设备页面，其它设备无法搜索到这台电脑。 解决办法 在设备管理器启用“Microsoft Wi-Fi Direct Virtual Adapter” 连接展示 生命重在折腾]]></content>
  </entry>
  <entry>
    <title><![CDATA[Visual Code]]></title>
    <url>%2F2017%2F05%2F14%2FVisual-Code%2F</url>
    <content type="text"><![CDATA[Visual Code，一个优秀的编辑器。当然了，编辑器很多，从Windows内置的nodepad，到Atom，再到notepad++，都是不错的，但是，我觉得Visual Code好看啊。来张照骗当然了，好事做到底，丢一个编辑器的快捷键表，丢掉鼠标，啪啪啪敲键盘吧！]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++容器]]></title>
    <url>%2F2017%2F05%2F11%2Fvector%2F</url>
    <content type="text"><![CDATA[在校赛见到有人用这个了，查了一下，简直神器啊，兼具栈、队列、数组的特性，很理想的工具，贴一点用法，以备查询 table th:first-of-type { width: 100px; } 操作 含义 push_back 在数组的最后添加一个数据 pop_back 去掉数组的最后一个数据 at 得到编号位置的数据 begin 得到数组头的指针 end 得到数组的最后一个单元+1的指针 front 得到数组头的引用 back 得到数组的最后一个单元的引用 max_size 得到vector最大可以是多大 capacity 当前vector分配的大小 size 当前使用数据的大小 resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 reserve 改变当前vecotr所分配空间的大小 erase 删除指针指向的数据项 clear 清空当前的vector rbegin 将vector反转后的开始指针返回(其实就是原来的end-1) rend 将vector反转构的结束指针返回(其实就是原来的begin-1) empty 判断vector是否为空 swap 与另一个vector交换数据 要想使用vector需要:12#include&lt;vector&gt;using nmaespace std; 通过vector&lt;数据类型&gt; 变量名;来声明一个vector型变量。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对排序的一点扯淡]]></title>
    <url>%2F2017%2F04%2F03%2Fsort%2F</url>
    <content type="text"><![CDATA[对数据进行排序，是需要经常进行的操作。手动写排序，归并，冒泡，插入之类的都可以，不过有algorithm自带的sort就省了一些麻烦了。对需要排序的数组这样写sort(a,a+n)(假设a为需要排序的数组，n为数组的长度)再细化一点的话，就这样写:sort(a+n1,a+n2)，这样是对a数组的下标为n1的元素直到下标为n2的元素进行排序，自然，n2&gt;n1。但是吧，有时候，需要排序的不仅仅只是一个数组，这个数组与其他的信息有一定的联系，比如这样的1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;struct Student&#123; string name; int score;&#125;;int main()&#123; struct Student stu[3]=&#123;"stu1",70,"stu2",80,"stu3",60&#125;;//初始化 for(int i=0;i&lt;3;i++) &#123; cout&lt;&lt;stu[i].name&lt;&lt;" "&lt;&lt;stu[i].score&lt;&lt;endl; &#125; return 0;&#125; 结构体内为学生的姓名和成绩，我想以成绩为准排序，当然了，姓名和成绩的对应关系不能乱掉。这个时候肯定不能写成sort(stu,stu+3)，需要给sort加上一定的排序依据。12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;struct Student&#123; string name; int score;&#125;;bool compare(Student a,Student b) //这个比较函数的参数类型也要写成结构体&#123; return a.score&gt;b.score;//"&gt;"是进行降序排序，如果要升序改成&lt;，其实sort默认是升序&#125;int main()&#123; struct Student stu[3]=&#123;"stu1",70,"stu2",80,"stu3",60&#125;; sort(stu,stu+3,compare); for(int i=0;i&lt;3;i++) &#123; cout&lt;&lt;stu[i].name&lt;&lt;" "&lt;&lt;stu[i].score&lt;&lt;endl; &#125; return 0;&#125; 扯一点题外的，看看类的排序1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;class Student&#123;public: string name; int score;&#125;;bool compare(Student a,Student b)&#123; return a.score&gt;b.score;&#125;int main()&#123; Student stu[3]=&#123;"stu1",70,"stu2",80,"stu3",60&#125;; sort(stu,stu+3,compare); for(int i=0;i&lt;3;i++) &#123; cout&lt;&lt;stu[i].name&lt;&lt;" "&lt;&lt;stu[i].score&lt;&lt;endl; &#125; return 0;&#125; 两段代码的区别仅仅是结构体和类的区别而已，结构体和类长得如此相似，访问成员的方式都如此相似，他们的共同存在真是迷惑了不少人，颇有周瑜和诸葛两人之意。http://www.cnblogs.com/starfire86/p/5367740.html，此文做了一定的解说，还不错。生命重在折腾]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证“探寻C++最快的读取文件的方案"]]></title>
    <url>%2F2017%2F03%2F18%2Fthe-truth%2F</url>
    <content type="text"><![CDATA[本文接上一篇文章————探寻C++最快的读取文件的方案仔细看了一下原文，发布时间是五年前，五年时间，无论是硬件还是软件环境都有了巨大的进步，我决定动手实现一下。首先编写了一个生成生成随机数的程序，代码如下:1234567891011#include&lt;cstdio&gt; #include&lt;ctime&gt; #include&lt;cstdlib&gt; int main () &#123; freopen("data.txt","w",stdout); srand(time(0)); for(int i=0;i&lt;1000000;i++) printf("%d ",rand()); return 0; &#125; 生成一千万个随机数，并存储在data.txt中，约54MB。编写使用scanf读取数据的程序，代码如下:1234567891011#include&lt;cstdio&gt; #include&lt;ctime&gt;int a[10000000]; int main () &#123; int start = clock(); freopen("data.txt","r",stdin); for(int i=0;i&lt;10000000;i++) scanf("%d",&amp;a[i]); printf("%.3lf\n",double(clock()-start)/CLOCKS_PER_SEC);&#125; 执行之后，使用时间为1.18s，相比于原文的2.01秒，缩短了一截，然后测试一下使用cin输入的情况，代码如下:123456789101112#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;int a[10000000];int main ()&#123; int start = clock(); freopen("data.txt","r",stdin); for(int i=0;i&lt;10000000;i++) std::cin&gt;&gt;a[i]; printf("%.3lf\n",double(clock()-start)/CLOCKS_PER_SEC);&#125; cin的使用时间为4.67s，比scanf更长，但是相比于原文的6.38s还是短得多。然后取消cin与stdin之间的同步之后，代码如下:12345678910111213#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;iostream&gt;int a[10000000];int main ()&#123; int start = clock(); std::ios::sync_with_stdio(false); freopen("data.txt","r",stdin); for(int i=0;i&lt;1000000;i++) std::cin&gt;&gt;a[i]; printf("%.3lf\n",double(clock()-start)/CLOCKS_PER_SEC);&#125; 时间大幅缩短，为1.24s，与scanf很接近了。然后按原文测试读入整个文件,代码如下:12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt; #include&lt;ctime&gt; #include&lt;cstdio&gt; const int MAXN = 10000000; const int MAXS = 60*1024*1024; int numbers[MAXN]; char buf[MAXS]; void analyse(char *buf, int len =MAXS) &#123; int i; numbers[i=0]=0; for(char *p=buf;*p &amp;&amp; p-buf&lt;len;p++) if(*p == ' ') numbers[++i]=0; else numbers[i]=numbers[i]*10+*p-'0'; &#125; void fread_analyse() &#123; freopen("data.txt","rb",stdin); int len = fread(buf,1,MAXS,stdin); buf[len]='\0'; analyse(buf,len); &#125; int main () &#123; int start = clock(); fread_analyse(); printf("%.3lf\n",double(clock()-start)/CLOCKS_PER_SEC); return 0; &#125; 时间如原文一般，大幅缩短，我这里测试得到0.37s，使用read测试，代码如下:123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt; #include&lt;ctime&gt; #include&lt;cstdio&gt; #include&lt;unistd.h&gt; #include&lt;fcntl.h&gt; const int MAXN = 10000000; const int MAXS = 60*1024*1024; int numbers[MAXN]; char buf[MAXS]; void analyse(char *buf, int len =MAXS) &#123; int i; numbers[i=0]=0; for(char *p=buf;*p &amp;&amp; p-buf&lt;len;p++) if(*p == ' ') numbers[++i]=0; else numbers[i]=numbers[i]*10+*p-'0'; &#125; void read_analyse() &#123; int fd = open("data.txt",O_RDONLY); int len = read(fd,buf,MAXS); buf[len]='\0'; analyse(buf,len); &#125; int main () &#123; int start = clock(); read_analyse(); printf("%.3lf\n",double(clock()-start)/CLOCKS_PER_SEC); return 0; &#125; 测试时间为0.31s，有所进步，不过不是非常明显。调用mmap，代码如下:12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt; #include&lt;ctime&gt; #include&lt;cstdio&gt; #include&lt;unistd.h&gt; #include&lt;fcntl.h&gt; #include&lt;sys/mman.h&gt; const int MAXN = 10000000; const int MAXS = 60*1024*1024; int numbers[MAXN]; char buf[MAXS]; void analyse(char *buf, int len =MAXS) &#123; int i; numbers[i=0]=0; for(char *p=buf;*p &amp;&amp; p-buf&lt;len;p++) if(*p == ' ') numbers[++i]=0; else numbers[i]=numbers[i]*10+*p-'0'; &#125; void mmap_analyse() &#123; int fd = open("data.txt",O_RDONLY); int len = lseek(fd,0,SEEK_END); char *mbuf = (char *) mmap(NULL,len,PROT_READ,MAP_PRIVATE,fd,0); analyse(mbuf,len); &#125; int main () &#123; int start = clock(); mmap_analyse(); printf("%.3lf\n",double(clock()-start)/CLOCKS_PER_SEC); return 0; &#125; 运行结果才让我大跌眼镜，虽然我没有眼镜达到0.49s，与原文不符(原文中使用mmnp耗时更短，在我的测试中，耗时变长了)，可能是代码与原作者的不一样，原作者只给出一部分代码，而测试需要写出完整的代码，可能我写的代码有问题。以上测试结果在腾讯云上进行,因为原作者当时的硬件条件可能比不上我所使用的环境，我在树莓派 3B和我自己的电脑上测试了一下，所有平台硬件信息如下： 平台/硬件和软件信息 Cent OS Raspberry Windows CPU 1 core Broadcom BCM2837 1.2GHz intel Core 5200u 2.2GHz RAM 1GB 1GB 12GB Gcc 4.8.5 4.9.2 5.3.0 PS: 这里忽略了硬盘的性能，理论上来说，硬盘的性能肯定能影响读写速度，只是没有较好的方法比较三个平台的硬盘性能，只能作罢。测试结果汇总如下: 方法/平台/耗时(s) Cent OS Raspberry Windows(本机) Ubuntu(本机) scanf 1.180 14.786 4.488 1.158 cin 4.670 61.255 13.026 4.309 cin取消同步 1.240 7.694 8.086 1.135 fread 0.37 3.503 0.327 0.284 read 0.31 2.975 0.370 0.285 mmap 0.49 5.945 NULL 0.447 生命重在折腾]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】探寻C++最快的读取文件的方案]]></title>
    <url>%2F2017%2F03%2F18%2Fabout-C%2F</url>
    <content type="text"><![CDATA[在竞赛中，遇到大数据时，往往读文件成了程序运行速度的瓶颈，需要更快的读取方式。相信几乎所有的C++学习者都在cin机器缓慢的速度上栽过跟头，于是从此以后发誓不用cin读数据。还有人说Pascal的read语句的速度是C/C++中scanf比不上的，C++选手只能干着急。难道C++真的低Pascal一等吗？答案是不言而喻的。一个进阶的方法是把数据一下子读进来，然后再转化字符串，这种方法传说中很不错，但具体如何从没试过，因此今天就索性把能想到的所有的读数据的方式都测试了一边，结果是惊人的。竞赛中读数据的情况最多的莫过于读一大堆整数了，于是我写了一个程序，生成一千万个随机数到data.txt中，一共55MB。然后我写了个程序主干计算运行时间，代码如下：1234567#include &lt;ctime&gt;int main()&#123; int start = clock(); //DO SOMETHING printf("%.3lf\n",double(clock()-start)/CLOCKS_PER_SEC);&#125; 最简单的方法就算写一个循环scanf了，代码如下：12345678910const int MAXN = 10000000;int numbers[MAXN];void scanf_read()&#123; freopen("data.txt","r",stdin); for (int i=0;i&lt;MAXN;i++) scanf("%d",&amp;numbers[i]);&#125; 可是效率如何呢？在我的电脑Linux平台上测试结果为2.01秒。接下来是cin，代码如下12345678910const int MAXN = 10000000;int numbers[MAXN];void cin_read()&#123; freopen("data.txt","r",stdin); for (int i=0;i&lt;MAXN;i++) std::cin &gt;&gt; numbers[i];&#125; 出乎我的意料，cin仅仅用了6.38秒，比我想象的要快。cin慢是有原因的，其实默认的时候，cin与stdin总是保持同步的，也就是说这两种方法可以混用，而不必担心文件指针混乱，同时cout和stdout也一样，两者混用不会输出顺序错乱。正因为这个兼容性的特性，导致cin有许多额外的开销，如何禁用这个特性呢？只需一个语句std::ios::sync_with_stdio(false);，这样就可以取消cin于stdin的同步了。程序如下：1234567891011const int MAXN = 10000000;int numbers[MAXN];void cin_read_nosync()&#123; freopen("data.txt","r",stdin); std::ios::sync_with_stdio(false); for (int i=0;i&lt;MAXN;i++) std::cin &gt;&gt; numbers[i];&#125; 取消同步后效率究竟如何？经测试运行时间锐减到了2.05秒，与scanf效率相差无几了！有了这个以后可以放心使用cin和cout了。 接下来让我们测试一下读入整个文件再处理的方法，首先要写一个字符串转化为数组的函数，代码如下12345678910111213const int MAXS = 60*1024*1024;char buf[MAXS];void analyse(char *buf,int len = MAXS)&#123; int i; numbers[i=0]=0; for (char *p=buf;*p &amp;&amp; p-buf&lt;len;p++) if (*p == ' ') numbers[++i]=0; else numbers[i] = numbers[i] * 10 + *p - '0';&#125; 把整个文件读入一个字符串最常用的方法是用fread，代码如下：12345678910111213const int MAXN = 10000000;const int MAXS = 60*1024*1024;int numbers[MAXN];char buf[MAXS];void fread_analyse()&#123; freopen("data.txt","rb",stdin); int len = fread(buf,1,MAXS,stdin); buf[len] = '\0'; analyse(buf,len);&#125; 上述代码有着惊人的效率，经测试读取这10000000个数只用了0.29秒，效率提高了几乎10倍！掌握这种方法简直无敌了，不过，我记得fread是封装过的read，如果直接使用read，是不是更快呢？代码如下：12345678910111213const int MAXN = 10000000;const int MAXS = 60*1024*1024;int numbers[MAXN];char buf[MAXS];void read_analyse()&#123; int fd = open("data.txt",O_RDONLY); int len = read(fd,buf,MAXS); buf[len] = '\0'; analyse(buf,len);&#125; 测试发现运行时间仍然是0.29秒，可见read不具备特殊的优势。到此已经结束了吗？不，我可以调用Linux的底层函数mmap，这个函数的功能是将文件映射到内存，是所有读文件方法都要封装的基础方法，直接使用mmap会怎样呢？代码如下：123456789101112const int MAXN = 10000000;const int MAXS = 60*1024*1024;int numbers[MAXN];char buf[MAXS];void mmap_analyse()&#123; int fd = open("data.txt",O_RDONLY); int len = lseek(fd,0,SEEK_END); char *mbuf = (char *) mmap(NULL,len,PROT_READ,MAP_PRIVATE,fd,0); analyse(mbuf,len);&#125; 经测试，运行时间缩短到了0.25秒，效率继续提高了14%。到此为止我已经没有更好的方法继续提高读文件的速度了。回头测一下Pascal的速度如何？结果令人大跌眼镜，居然运行了2.16秒之多。程序如下：1234567891011const MAXN = 10000000;var numbers :array[0..MAXN] of longint; i :longint;begin assign(input,'data.txt'); reset(input); for i:=0 to MAXN do read(numbers[i]);end. 为确保准确性，我又换到Windows平台上测试了一下。结果如下表： 方法/平台/时间(秒) Linux gcc Windows mingw Windows VC2008 scanf 2.010 3.704 3.425 cin 6.380 64.003 19.208 cin取消同步 2.050 6.004 19.616 fread 0.290 0.241 0.304 read 0.290 0.398 不支持 mmap 0.250 不支持 不支持 Pascal read 2.160 4.668 NULL 从上面可以看出几个问题: Linux平台上运行程序普遍比Windows上快。 Windows下VC编译的程序一般运行比MINGW（MINimal Gcc for Windows）快。 VC对cin取消同步与否不敏感，前后效率相同。反过来MINGW则非常敏感，前后效率相差8倍。 read本是linux系统函数，MINGW可能采用了某种模拟方式，read比fread更慢。 Pascal程序运行速度实在令人不敢恭维。 原文链接:BYVoid原创 转载请注明]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu中使用IPv6]]></title>
    <url>%2F2017%2F03%2F16%2Fuse-ipv6-on-Ubuntu%2F</url>
    <content type="text"><![CDATA[我的电脑上装了Ubuntu 14.04 LTS 系统，学校的校园网需要拨号才能使用，并且在拨号之后获得IPv6地址。但是实际上，我在Windows上可以正常使用IPv6地址，但是在Ubuntu上无法使用，问了度娘之后，总结解决办法如下:更改文件/etc/sysctl.d/10-ipv6-privacy.conf 123456789101112# IPv6 Privacy Extensions (RFC 4941)# ---# IPv6 typically uses a device's MAC address when choosing an IPv6 address# to use in autoconfiguration. Privacy extensions allow using a randomly# generated IPv6 address, which increases privacy.## Acceptable values:# 0 - don’t use privacy extensions.# 1 - generate privacy addresses# 2 - prefer privacy addresses and use them over the normal addresses.net.ipv6.conf.all.use_tempaddr = 2net.ipv6.conf.default.use_tempaddr = 2 为123456789101112# IPv6 Privacy Extensions (RFC 4941)# ---# IPv6 typically uses a device's MAC address when choosing an IPv6 address# to use in autoconfiguration. Privacy extensions allow using a randomly# generated IPv6 address, which increases privacy.## Acceptable values:# 0 - don’t use privacy extensions.# 1 - generate privacy addresses# 2 - prefer privacy addresses and use them over the normal addresses.net.ipv6.conf.all.use_tempaddr = 2net.ipv6.conf.default.use_tempaddr = 0 然后重新拨号之后，就可以正常使用IPv6了。对于校园网不支持IPv6或者获取方式不一样的小伙伴，此方法不一定适用。使用命令ifconfig可查看网络连接信息:123456789101112131415161718192021222324252627282930313233343536eth0 Link encap:Ethernet HWaddr 50:7b:9d:03:61:aa inet6 addr: fe80::527b:9dff:fe03:61aa/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:506 errors:0 dropped:1 overruns:0 frame:0 TX packets:103 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:48325 (48.3 KB) TX bytes:14006 (14.0 KB) Interrupt:20 Memory:f1200000-f1220000 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:226 errors:0 dropped:0 overruns:0 frame:0 TX packets:226 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:20694 (20.6 KB) TX bytes:20694 (20.6 KB)ppp0 Link encap:Point-to-Point Protocol inet addr:10.170.15.47 P-t-P:10.170.72.254 Mask:255.255.255.255 inet6 addr: fe80::2a:e1b3:3273:b894/10 Scope:Link inet6 addr: 2001:250:1006:dff0:2a:e1b3:3273:b894/64 Scope:Global UP POINTOPOINT RUNNING NOARP MULTICAST MTU:1492 Metric:1 RX packets:42 errors:0 dropped:0 overruns:0 frame:0 TX packets:47 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3 RX bytes:3793 (3.7 KB) TX bytes:3373 (3.3 KB)wlan0 Link encap:Ethernet HWaddr 94:65:9c:4e:02:dc inet addr:192.168.0.108 Bcast:192.168.0.255 Mask:255.255.255.0 inet6 addr: fe80::9665:9cff:fe4e:2dc/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:24275 errors:0 dropped:0 overruns:0 frame:0 TX packets:8251 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:35338441 (35.3 MB) TX bytes:845841 (845.8 KB) 上一张成品图 参考文章:http://www.cnblogs.com/makefile/p/5040615.html生命重在折腾]]></content>
  </entry>
  <entry>
    <title><![CDATA[在Linux中获取可更新软件的下载地址]]></title>
    <url>%2F2017%2F03%2F12%2Fget-the-download-link-of-the-upgradeble-software-on-Linux%2F</url>
    <content type="text"><![CDATA[背景描述:依旧是之前遇到的问题————更新软件超级慢。虽然之前在之前的文章中提及过，可以使用代理来更新软件源，但是有时候就算代理了速度也很慢，区区几M的软件需要花费数个小时才能下载好。所以有了此文。 目标获取到想要更新的软件的下载地址，然后用IDM、迅雷、aria2c之类的下载工具来下载，速度会快很多。 实施步骤原理说明在文章http://www.cnblogs.com/hushuangpu/p/5247084.html中提到过一点。根据当初我编写该文时的状况来看，在更新软件的时候，若遇到网络故障(比如该文中的IPv4不能联网或者干脆断网的情况下)，则apt-get会报错，我们便能在报错信息里面看到软件的下载地址了。 实战为了能让Linux网络正常的情况下，使用apt-get时无法正常连接网络，我们还需要动一些小手段。我是这么干的：安装Proxychains，但是不开启本地的socks5代理端口，这样Proxychains将apt-get的网络访问劫持到该端口的时候，发现没有网络，便会报错，方便我们拿到软件的下载地址。 下载软件得到了软件的下载链接之后，直接用下载工具下载好之后，把文件复制到/var/cache/apt/archives/，再通过sudo apt-get upgrade即可飞速更新软件。 通过此法，我成功的把原本需要一个半小时才能更新完软件的时间缩短到10分钟。此处脑补一个得瑟表情。 生命重在折腾]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 在 Next 主题下打开缓慢]]></title>
    <url>%2F2017%2F02%2F22%2Fsolve-a-problem%2F</url>
    <content type="text"><![CDATA[之前遇到博客打开过于缓慢(甚至于打不开)的情况，将解决办法整理解决如下: 说明本站使用的框架是Hexo，使用的主题是Next。Hexo和Next的安装和使用方法在之前的文章中有所提及，这里不再累述。 字体导致的访问缓慢方法来自博客，博客内容所指为 禁用第三方字体到Next主题的_config.yml中设置不从google加载字体（默认会加载本地字体）设置：use_font_lato: false 换字体源到\themes\next\layout_partials\head\external-fonts.swig文件fonts.googleapis.com 改成 fonts.useso.com按该文所述更改字体库来源之后，访问速度虽然有所提高，但是仍然需要很长时间。 可能该博客撰写时Next的版本较低，在5.1.0版本的Next的配置文件中，并没有use_font_lato字段，而是12font: enable: true 改为12font: enable: false 方法一效果较为明显，方法二几乎没有效果。仔细对比是否使用第三方字体库，发现差别并不明显，所以果断选择方法一了。 体积较大的资源导致的访问缓慢测试了网站首页，打开时间占用最长的是几张体积较大的图片，将这些图片压缩一下就好了。另外是几个js文件，要减小这些得参考更高级的玩法，或者自己学js了(=.=)。 网速导致的访问缓慢本站位于腾讯云(GitPage 也有一份)，带宽为1M，虽然不限流量，但是这小水管实在是跑不起来，没办法了。GitHub又位于美国，访问速度同样缓慢，不忍直视。生命在于折腾]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2048]]></title>
    <url>%2F2017%2F02%2F18%2F2048%2F</url>
    <content type="text"><![CDATA[在gayhub上发现一个挺有意思的小程序————2048 下载安装试玩123$ wget https://raw.githubusercontent.com/mevdschee/2048.c/master/2048.c$ gcc 2048.c$ ./a.out 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;ctime&gt;using namespace std;int const ROW = 4;int const COL = 4;int game[ROW][COL] = &#123;0&#125;;//上下左右int const UP = 1;int const DOWN = 2;int const LEFT = 3;int const RIGHT = 4;//游戏所处的状态int const GAME_OVER = 1;int const GAME_WIN = 2;int const GAME_CONTINUE = 3;enum GameNum&#123; Game_2 = 2, Game_4 = 4, Game_8 = 8, Game_16 = 16, Game_32 = 32, Game_64 = 64, Game_128 = 128, Game_256 = 256, Game_512 = 512, Game_1024 = 1024, Game_2048 = 2048,&#125;;//打印所得的数组void Print()&#123; system("cls"); cout &lt;&lt; "***************** 2048 控 制 台 版 ******************" &lt;&lt; endl; cout &lt;&lt; "***************** By Tanzf (Intern) ******************" &lt;&lt; endl &lt;&lt; endl; for (int i = 0; i &lt; ROW; ++i) &#123; cout &lt;&lt; "---------------------------------"&lt;&lt; endl; for (int j = 0; j &lt; COL; ++j) &#123; if (game[i][j] == 0) &#123; cout &lt;&lt;"| \t"; &#125; else &#123; cout &lt;&lt;"| " &lt;&lt; game[i][j] &lt;&lt; "\t"; &#125; &#125; cout &lt;&lt; "|" &lt;&lt; endl; &#125; cout &lt;&lt; "---------------------------------"&lt;&lt; endl;&#125;bool CreateNumber()&#123; int x = -1; int y = -1; int times = 0; int maxTimes = ROW * COL; //三分之二的概率生成2，三分之一的概率生成4 int whitch = rand() % 3; do &#123; x = rand() % ROW; y = rand() % COL; ++times; &#125; while (game[x][y] != 0 &amp;&amp; times &lt;= maxTimes); //说明格子已经满了 if(times &gt;= maxTimes) &#123; return false; &#125; else &#123; GameNum num; if(whitch == 0) &#123; num = Game_4; &#125; else if(whitch) &#123; num = Game_2; &#125; game[x][y] = num; &#125; return true;&#125;void Process(int direction)&#123; switch (direction) &#123; case UP: //最上面一行不动 for(int row = 1; row &lt; ROW; ++row) &#123; for(int crow = row; crow &gt;= 1; --crow) &#123; for(int col = 0; col &lt; COL; ++col) &#123; //上一个格子为空 if(game[crow-1][col] == 0) &#123; game[crow-1][col] = game[crow][col]; game[crow][col] = 0; &#125; else &#123; //合并 if(game[crow-1][col] == game[crow][col]) &#123; game[crow - 1][col] *= 2; game[crow][col] = 0; &#125; &#125; &#125; &#125; &#125; break; case DOWN: //最下面一行不动 for(int row = ROW - 2; row &gt;= 0; --row) &#123; for(int crow = row; crow &lt; ROW - 1; ++crow) &#123; for(int col = 0; col &lt; COL; ++col) &#123; //上一个格子为空 if(game[crow + 1][col] == 0) &#123; game[crow + 1][col] = game[crow][col]; game[crow][col] = 0; &#125; else &#123; //合并 if(game[crow + 1][col] == game[crow][col]) &#123; game[crow + 1][col] *= 2; game[crow][col] = 0; &#125; &#125; &#125; &#125; &#125; break; case LEFT: //最左边一列不动 for(int col = 1; col &lt; COL; ++col) &#123; for(int ccol = col; ccol &gt;= 1; --ccol) &#123; for(int row = 0; row &lt; ROW; ++row) &#123; //上一个格子为空 if(game[row][ccol-1] == 0) &#123; game[row][ccol - 1] = game[row][ccol]; game[row][ccol] = 0; &#125; else &#123; //合并 if(game[row][ccol - 1] == game[row][ccol]) &#123; game[row][ccol - 1] *= 2; game[row][ccol] = 0; &#125; &#125; &#125; &#125; &#125; break; case RIGHT: //最右边一列不动 for(int col = COL - 2; col &gt;= 0; --col) &#123; for(int ccol = col; ccol &lt;= COL - 2; ++ccol) &#123; for(int row = 0; row &lt; ROW; ++row) &#123; //上一个格子为空 if(game[row][ccol + 1] == 0) &#123; game[row][ccol + 1] = game[row][ccol]; game[row][ccol] = 0; &#125; else &#123; //合并 if(game[row][ccol + 1] == game[row][ccol]) &#123; game[row][ccol + 1] *= 2; game[row][ccol] = 0; &#125; &#125; &#125; &#125; &#125; break; &#125;&#125;//处理输入输出，返回上下左右int Input()&#123; //读取上下左右四个方向键 int upArrow = 0; int downArrow = 0; int leftArrow = 0; int rightArrow = 0; int direction = 0; while (true) &#123; upArrow = GetAsyncKeyState(VK_UP); downArrow = GetAsyncKeyState(VK_DOWN); leftArrow = GetAsyncKeyState(VK_LEFT); rightArrow = GetAsyncKeyState(VK_RIGHT); if(upArrow) &#123; direction = UP; break; &#125; else if(downArrow) &#123; direction = DOWN; break; &#125; else if(leftArrow) &#123; direction = LEFT; break; &#125; else if(rightArrow) &#123; direction = RIGHT; break; &#125; Sleep(100); &#125; return direction;&#125;//判断游戏状态int Judge()&#123; //赢得游戏 for(int i = 0; i &lt; ROW; ++i) &#123; for(int j = 0; j &lt; COL; ++j) &#123; if(game[i][j] == 2048) &#123; return GAME_WIN; break; &#125; &#125; &#125; //横向检查 for(int i = 0 ; i &lt; ROW; ++i) &#123; for(int j = 0; j &lt; COL - 1; ++j) &#123; if(!game[i][j] || (game[i][j] == game[i][j+1])) &#123; return GAME_CONTINUE; break; &#125; &#125; &#125; //纵向检查 for(int j = 0; j&lt; COL; ++j) &#123; for(int i = 0; i &lt; ROW -1; ++i) &#123; if(!game[i][j] || (game[i][j] == game[i+1][j])) &#123; return GAME_CONTINUE; break; &#125; &#125; &#125; //不符合上述两种状况，游戏结束 return GAME_OVER;&#125;int main()&#123; //设置一个随机数种子 srand((unsigned int)time(0)); CreateNumber(); CreateNumber(); Print(); int direction = 0; int gameState = -1; while(true) &#123; direction = Input(); gameState = Judge(); if(direction &amp;&amp; gameState == GAME_CONTINUE) &#123; Process(direction); CreateNumber(); Print(); Sleep(100); &#125; else if(gameState == GAME_WIN) &#123; Print(); cout &lt;&lt; "You Win！" &lt;&lt; endl; break; &#125; else if(gameState == GAME_OVER) &#123; Print(); cout &lt;&lt;"You lose!" &lt;&lt; endl; break; &#125; &#125; return 0;&#125; PS此代码仅可在Linux上使用，Windows上会提示缺失头文件，问了问度娘，虽然有不少这样的代码，但是这份代码的显示效果最好，所以就是它啦。生命重在折腾]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于文件编码的一些思考]]></title>
    <url>%2F2017%2F02%2F14%2Funicode%2F</url>
    <content type="text"><![CDATA[这几日，用nginx给人共享文件，改了配置文件，然后我的博客本地预览的时候是乱码的,成了这样：据之前的经验来看，必定是编码格式的问题，当我查看网页代码的时候，神奇的事情就出现了，用Visual Code查看网页代码是正常的，但是在浏览器里面是乱码的。一开始以为是npm抽风，重装之后，发现并没有起作用，用hexo s --debug查看调试信息也没有什么问题，并且正常，生成网页本地查看的时候是乱码，上传到VPS上却又是正常的。怀疑到nginx上来。慢慢调整，发现是nginx的配置文件的问题，乱码时的nginx配置文件时这样的：123456789101112131415161718192021222324252627282930313233343536worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; listen [::]:80; server_name localhost; location / &#123; root C:\Users\BDZNH\blog\public; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; charset GBK; client_max_body_size 4G; location /src &#123; alias F:\\; autoindex on; autoindex_exact_size off; autoindex_localtime on; &#125; &#125;&#125; 更改之后的配置文件是这样的123456789101112131415161718192021222324252627282930313233343536worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; listen [::]:80; server_name localhost; location / &#123; root C:\Users\BDZNH\blog\public; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; client_max_body_size 4G; location /src &#123; charset GBK; alias F:\\; autoindex on; autoindex_exact_size off; autoindex_localtime on; &#125; &#125;&#125; 正常的时候是这样的29行的charset GBK，问题便出现在这儿，这里让nginx指定了网页的文件编码格式为GBK，但是hexo生成的网页格式是utf-8的，两种编码格式不一样，所以乱码。这里就吐槽一下微软，Windows 系统的默认字符编码集是GBK，据知乎上的大牛说是为了效率，但是字符集的不统一真是一个很肝疼的问题，ssh远程到linux主机，使用了utf-8格式，本地终端使用的却是GBK，调整终端的编码集，远程之后能正常显示中文，但是在本地中文又是乱码的。非得逼我打开几个终端。 生命重在折腾]]></content>
      <tags>
        <tag>unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux 手册]]></title>
    <url>%2F2017%2F02%2F13%2Fmanual-of-tmux%2F</url>
    <content type="text"><![CDATA[分享一个终端利器——tmux 基本操作 table th:first-of-type { width: 100px; } ? 列出所有快捷键；按q返回 d 脱离当前会话,可暂时返回Shell界面，输入tmux attach能够重新进入之前会话 s 选择并切换会话；在同时开启了多个会话时使用 D 选择要脱离的会话；在同时开启了多个会话时使用 : 进入命令行模式；此时可输入支持的命令，例如kill­server所有tmux会话 [ 复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出 ] 进入粘贴模式，粘贴之前复制的内容，按q/Esc退出 ~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息 t 显示当前的时间 Ctrl+z 挂起当前会话 窗口操作 c 创建新窗口 &amp; 关闭当前窗口 数字键 切换到指定窗口 p 切换至上一窗口 n 切换至下一窗口 l 前后窗口间互相切换 w 通过窗口列表切换窗口 , 重命名当前窗口，便于识别 . 修改当前窗口编号，相当于重新排序 f 在所有窗口中查找关键词，便于窗口多了切换 面板操作 “ 将当前面板上下分屏 % 将当前面板左右分屏 x 关闭当前分屏 ! 将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板 Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小 Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小 空格键 可以在默认面板布局中切换，试试就知道了 q 显示面板编号 o 选择当前窗口中下一个面板 方向键 移动光标选择对应面板 { 向前置换当前面板 } 向后置换当前面板 Alt+o 逆时针旋转当前窗口的面板 Ctrl+o 顺时针旋转当前窗口的面板 z tmux 1.8新特性，最大化当前所在面板 视频示范BiliBili]]></content>
  </entry>
  <entry>
    <title><![CDATA[启动jar文件时使用代理]]></title>
    <url>%2F2017%2F02%2F12%2Fuse-proxy-when-start-run-a-jar-file%2F</url>
    <content type="text"><![CDATA[Minecraft用java编写，官方的启动器是一个jar文件，由于GFW横跨在出口网络上，所以启动官方启动器的时候总是连接不上登录服务器，离线的话又会遇到正版验证。解决此问题，启动官方启动器的时候，给它设置一个代理就好了。1$ java -DproxySet=true -DproxyHost=127.0.0.1 -DproxyPort=1080 -jar "C:\Program Files (x86)\Minecraft\game\launcher.jar" C:\Program Files (x86)\Minecraft\game\launcher.jar是官方启动器默认的目录此处本该有对比图，然而官方启动器就在我写这篇博客的时候更新了，所以此法并不适用于最新版本的官方启动器。记于2017.2.12 10:17]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的世界合成表]]></title>
    <url>%2F2017%2F02%2F01%2FMinecraft-synthetic-lists%2F</url>
    <content type="text"><![CDATA[基本合成 名称 材料 合成示意图 描述 木板Wooden Planks 原木Wood 木板是最基本的材料，1个原木可以得到4个木板，所得到的的木板是我们游戏中重要的建造材料，并且木头可以用模板烧制成木炭！ 木棍Sticks 木板Wooden Planks 木棍用来合成火把,弓箭,栅栏,木牌,工具和武器。是游戏中另外一个基础的材料物品，游戏中消耗非常大，建议多做几组备用！ 火把Torches 煤碳和木棍Coal &amp; Stick 提供照明,避免刷怪,融化雪和冰块。火把在夜晚照明以及挖矿的时候都非常的有用，还可以防止刷怪！在火把旁边的冰块雪块，可以很快的融化掉！注意，在亮度小于7的地方就会刷怪！ 工作台Crafting Table 木板Wooden Planks 工作台可以为我们提供一个3X3的物品合成区域，比直接按E建出现的2X2区域多了很多，，游戏中所有高级的物品都需要在工作台上合成！ 熔炉Furnace 圆石Cobblestone 由8个圆石围一圈得来，主要用来烧制烧制物品。各种生肉烧之后可以得到熟肉，各种矿石烧制之后可以得到相应的矿物！和工作台一样是必不可少的工具！ 箱子Chest 木板Wooden Planks 用于存放物品、迷路时暂存身上物品,两个箱子并排放可以增加存放空间.可以多做一些以免东西溢出！ 梯子Ladders 木棍Sticks 用来爬墙. 注：在挖矿开始就铺上梯子，即使在很深的矿道里面也可以回到地面！在梯子上按住SHIFT就可以在一点不动了！ 栅栏Fence 木棍Sticks 用于围地、圈地 注：不跨越栅栏,别墅内的隔栏(装饰品)、防止跌落。可以制作出养鸡场、养牛场之类的农场，也可以在自己家周围围一圈，防止怪物靠近。栅栏是跳不过去的！ 船Boat 木板Wooden Planks 在水中行驶。注：船当然就是在水里面行驶啦，速度很快的哦，需要注意的是船在水中航行不要碰到水中的章鱼，否则就会被破坏掉，另外如果撞到其他物体，也会粉碎，船被破坏之后会掉落木板和木棍！ 木质台阶Wooden Slabs 木板Wooden Planks 用于建造台阶、屋檐、窗台等.是一个非常不错的装饰用具！也就是我们常说的半砖，有上半砖和下半砖的铺发区别，如果上半砖和下半砖叠加起来就是一个完整的方块模板了 石质台阶Stone Slabs 石头,砖,石砖,砂石,圆石,地狱砖,石英Stone or Brick or Stone Brick or Sandstone or Cobblestone or Nether Brick or Quartz 用于建造台阶、屋檐、窗台等.也可以改造刷怪笼、刷怪塔。注：同木质台阶作用一样，只不过是这个是石头做的哦！详情见上面 告示牌Sign 木板和木棍Wooden Planks &amp; Stick 门牌、路标、告示牌、贴在楼梯两侧可组成沙发. 注：你可以在木牌上面写字哦！纯净版只能打英文，需要下载中文输入补丁才能打中文！在服务器中用木牌可以设置私有物品，不会被其他玩家破坏 门Doors 木板或者铁锭Wooden Planks or Iron Ingots 木门能够用手打开或者红石系统打开. 铁门需要激活才能打开.注：在困难模式下，僵尸会将木门破坏，从而破门而入！ 方块合成 名称 材料 合成示意图 描述 萤石块Glowstone 萤石粉Glowstone Dust 能够用于水下照明.注：萤石可以放在喷泉顶上，到了夜晚喷泉就会散发一些光芒！可以替代火把的一种照明工具，常用于室内装潢！ 雪块Snow Block 雪球Snowballs 建筑材料.注：雪块可以用来制作雪傀儡！雪傀儡可以保卫我们的家园，还可以无限刷雪 TNT 火药和沙子Gunpowder &amp; Sand 爆炸物. 注：在创造模式下，TNT放置不宜很多，因为如果机器不好，会很卡。TNT也是熊孩子毁服常用的工具。游戏中沙漠神殿会有9个TNT！ 粘土块Clay Block 粘土Clay 建筑材料.用于装饰 砖块Brick Block 红砖Clay Bricks 坚硬的建筑材料.用于装饰，建筑党必备装饰材料 书架Bookshelf 木板和书本Wooden Planks &amp; Books 装饰和附魔. 注：附魔出来的效果是随机的，如果你的RP不好，很可能附魔很多次才能附魔出你想要的东西 沙石Sandstone Block 沙子Sand 建筑材料.用于装饰，可在熔炉中烧制成玻璃！ 平滑沙石Smooth Sandstone 沙石Sandstone Block 建筑材料.用于装饰用 錾制Decorative Sandstone 沙质台阶Sandstone Slabs 建筑材料.用于装饰用，属于半砖的一种 音符盒Note Block 木板和红石Wooden Planks &amp; Redstone 当点击时发出音符.注：可以发出很多美妙的音乐哦，你一定会喜欢的！放在不同的地面会发出不同的声音 南瓜灯Jack-O Lantern 南瓜和火把Pumpkin &amp; Torch 光源. 注：在晚上看起来会非常的漂亮。也是制作万圣节地图必备的物品之一哦！漂亮的南瓜灯也是室内装修必备物品！ 青金石块Lapis Lazuli Block 青金石染料Lapis Lazuli Dye 存储青金石染料. 注：可以用染料将羊毛染色 钻石块Diamond Block 钻石Diamonds 存储钻石. 注：主要为了节省空间 金块Gold Block 金锭Gold Ingots 存储金锭.注：主要为了节省空间 铁块Iron Block 铁锭Iron Ingots 存储铁锭.注：主要为了节省空间 绿宝石块Emerald Block 绿宝石Emeralds 存储绿宝石.注：主要为了节省空间，也可做信标底座！ 石砖Stone Brick 石头Stone 建筑材料. 注：用于室外的装潢 木质楼梯Wooden Stairs 木板Wooden Planks 做楼梯.注：用于室外和室内的装潢，也可用于矿道 石质楼梯Stone Stairs 圆石,沙,砖石,石砖,地狱砖,石英Cobblestone or Sandstone or Brick or Stone Brick or Nether Brick or Quartz 做楼梯.注：用于室外和室内的装潢，也可用于矿道 圆石墙Cobblestone Wall 圆石或者苔石Cobblestone or Moss Stone 类似于栅栏的作用.注：比栅栏坚固一些，非常好的划分区域工具！ 红石块Block of Redstone 红石Redstone 红石电源.注：在制作红石机器的时候经常使用到哦。 地狱砖块Nether Brick 地狱砖Nether Brick (Item) 建筑材料.注：非常不错的建筑材料哦！ 石英块Block of Quartz 下界石英Nether Quartz 建筑材料.注：游戏中公认最漂亮的建筑材料，有白色大理石的感觉！ 錾制石英块Chiseled Quartz Block 石英台阶Quartz Slabs 建筑材料.注：非常不错的建筑材料哦！ 竖纹石英块Pillar Quartz Block 石英块Block of Quartz 建筑材料.注：具有纹理的石英块！ 工具合成 Name Ingredients Image Description 镐Pickaxe 木棍加木板或圆石或铁锭或金锭或钻石Sticks &amp; Wooden Planks or Cobblestone or Iron Ingots or Gold Ingots or Diamonds 挖方块和资源.注：石头以及各种矿物是不能用手直接挖掉的，这时候必须使用镐头，根据材料的不同，挖掘的速度也会不一样！金镐头耐久度非常低！ 斧头Axes 木棍加木板或圆石或铁锭或金锭或钻石Sticks &amp; Wooden Planks or Cobblestone or Iron Ingots or Gold Ingots or Diamonds 比用拳头砍树快. 注：根据材料的不同，砍伐木头的速度也会不一样！钻石是最好的，其次是铁和石头，金一般不推荐制作工具 锹Shovels 木棍加木板或圆石或铁锭或金锭或钻石Sticks &amp; Wooden Planks or Cobblestone or Iron Ingots or Gold Ingots or Diamonds 用来挖沙子,沙砾,图,草和雪.注：根据材料的不同，挖掘的速度和耐久也会不一样！ 锄Hoes 木棍加木板或圆石或铁锭或金锭或钻石Sticks &amp; Wooden Planks or Cobblestone or Iron Ingots or Gold Ingots or Diamonds 用来锄地.注：根据材料的不同，可用耐久也会不同！因为耕地不是太多，所以建议一般用石锄就可以了！ 钓鱼竿Fishing Rod 木棍和线Sticks &amp; String 钓鱼.注：用来钓鱼还可以放上胡萝卜骑在猪身上，控制猪的前进方向 打火石Flint &amp; Steel 铁锭和燧石Iron Ingot &amp; Flint 生火. 注：可以点燃地狱岩以及树木，部分活塞也可以点燃。也可以点燃游戏中的苦力怕，让他直接自爆！ 指南针Compass 铁锭和红石Iron Ingots &amp; Redstone 指向出生点. 注：迷失方向的时候，指南针当然是我们最好的伙伴啦！ 钟Clock 金锭和红石Gold Ingots &amp; Redstone 显示时间和白天黑夜. 注：在地下挖矿不知道地面上是白天还是黑夜吗？这个物品就能帮助到你哦！ 铁桶Bucket 铁锭Iron Ingots 用来装水,岩浆,牛奶.注：桶自然是用来装各种液体的了~装的牛奶可以解除各种负面状态！ 剪刀Shears 铁锭Iron Ingots 用来剪羊毛和树叶.注：当然在水塘里面遇到荷叶还可以剪一些荷叶哦！ 防具合成 名称 材料 合成示意图 描述 头盔Helmet 皮革或铁锭或金锭或钻石Leather or Iron Ingots or Gold Ingots or Diamonds 提供1.5护甲值（钻石）.给我们提供盔甲，减少我们受到的伤害。注：金头盔还有照明的作用，当在黑暗的环境下，带上金头盔，周围就会被点亮了哦！钻石防具是最好的防具！ 胸甲Chestplate 皮革或铁锭或金锭或钻石Leather or Iron Ingots or Gold Ingots or Diamonds 提供4点护甲值（钻石）.给我们提供盔甲，减少我们受到的伤害。钻石防具是最好的防具！ 护腿Leggings 皮革或铁锭或金锭或钻石Leather or Iron Ingots or Gold Ingots or Diamonds 提供3点护甲值（钻石）.给我们提供盔甲，减少我们受到的伤害。钻石防具是最好的防具！ 靴子Boots 皮革或铁锭或金锭或钻石Leather or Iron Ingots or Gold Ingots or Diamonds 提供1.5点护甲值（钻石）.给我们提供盔甲，减少我们受到的伤害。钻石防具是最好的防具！ 剑Sword 木棍加上木板或圆石或铁锭或金锭或钻石Sticks &amp; Wooden Planks or Cobblestone or Iron Ingots or Gold Ingots or Diamonds 对怪物造成更多的伤害.这是我们和怪物战斗用的利器！注：小编经验来看铁剑的性价比在前期最高，后期当然是钻石附魔剑了！ 弓Bow 线和木棍String &amp; Sticks 射箭. 注：击杀骷髅之后会掉落，后期可以附魔无限弓！ 箭Arrow 燧石和木棍和羽毛Flint &amp; Stick &amp; Feather 箭.注： 击杀骷髅之后会掉落，在丛林神庙的发射器里面也可以找到！在打末影龙boss时候需要多准备几组箭 道具合成 名称 材料 合成示意图 描述 压力版Pressure Plates 木板或石头Wooden Planks or Stone 有生物或玩家站在上面时会发出红石信号. 注：旁边如果有TNT就会发生爆炸！也可以作为一个开门工具 活板门Trapdoor 木板Wooden Planks 可以通过右键点击和红石打开.一般用于制作天窗 栅栏门Fence Gate 木板和木棍Wooden Planks &amp; Sticks 可以像门一样被打开. 注：用栅栏圈地的时候记得留一个格子放栅栏门，不然你会出不去的哦！右键点击即可打开！ 按钮Button 石头或者木板Stone or Wooden Plank 按下的时候发送一个短的脉冲信号。注：用于制作各种红石机器！ 拉杆Lever 木棍和圆石Stick &amp; Cobblestone 通过开关来控制红石信号的输出.注：用于制作各种红石机器！和按钮不一样，拉杆给予一个长的连续的信号。 中继器Redstone Repeater 石头,红石火把,红石和石头Stone &amp; Redstone Torch &amp; Redstone 红石电路的二极管或者延时器.注：右击不同的次数，会产生不同的延迟！总共分三档 红石火把Redstone Torch 木棍和红石Stick &amp; Redstone 不间断发送红石信号. 唱片机Jukebox 木板和钻石Wooden Planks &amp; Diamond 将唱片插入可以播放音乐.注：唱片只有小白杀死苦力怕之后才能获得，所以唱片很难得到哦！ 发射器Dispenser 圆石,弓和红石Cobblestone &amp; Bow &amp; Redstone 开启的适合发射物品. 注：里面可以放箭以及其他物品，可以用来制作射箭器，也能用来制作树场！可以发射几乎所有的东西 活塞Piston 木板,原始,铁锭和红石Wooden Planks &amp; Cobblestone &amp; Iron Ingot &amp; Redstone 推动方块. 注：当被激活就会将活塞推出 粘性活塞Sticky Piston 活塞和史莱姆球Piston &amp; Slime Ball 推拉方块.注：当被激活就会将活塞推出，还可以收回 矿车Minecart 铁锭Iron Ingots 在铁轨上行驶.也可以利用上下矿车的原理制作出矿车电梯 动力矿车Powered Minecart 矿车和熔炉Minecart &amp; Furnace 烧碳来产生能量推动其他矿车前进.注：作用类似火车头 运输矿车Storage Minecart 矿车和箱子Minecart &amp; Chest 通过铁路运送材料和物资. 铁轨Rail 铁锭和木棍Iron Ingots &amp; Stick 铁轨.注：没什么好说的，做铁路的基本材料。 充能铁轨Powered Rail 金锭,木棍和红石Gold Ingots &amp; Stick &amp; Redstone 被激活的时候加速矿车. 注：当矿车经过时，会产生加速度的效果哦！ 探测铁轨Detector Rail 铁锭,石质压力板和红石Iron Ingots &amp; Stone Pressure Plate &amp; Redstone 矿车在其上面经过时产生红石信号.可以用于激活一些红石装置 红石灯Redstone Lamp 红石和萤石块Redstone &amp; Glowstone Block 照明设施,需红石能量激活. 注：非常不错的照明用品 绊线Tripwire Hook 铁锭,木棍和木板Iron Ingot &amp; Stick &amp; Wooden Plank 通过时产生红石信号. 注：可以用来制作陷阱，丛林神庙里面的机关就是利用它实现的，只要触碰到就会产生信号，从而激活红石装置 激活铁轨Activator Rail 铁锭,木棍和红石火把Iron Ingots &amp; Sticks &amp; Redstone Torch 常用来激活TNT矿车和漏斗矿车. 阳光传感器Daylight Sensor 玻璃,下界石英和木板Glass &amp; Nether Quartz &amp; Wooden Slabs 发出红石信号.在白天有太阳的时候使用 投掷器Dropper 圆石和红石Cobblestone &amp; Redstone 扔出物品（类似发射器）. 漏斗Hopper 铁锭和箱子Iron Ingots &amp; Chest 物品通过漏斗在箱子中移进或者移出. 注：有时候被熊孩子用作偷东西。叠放的漏斗可以传送物品可看成是一个类似红石电线的东西！可以看成是一个管道！ 漏斗矿车Minecart with Hopper 漏斗和矿车Hopper &amp; Minecart 类似漏斗的功能. TNT矿车Minecart with TNT TNT和矿车TNT &amp; Minecart 通过激活的铁道发生爆炸或者手动爆炸. 注：可以用来炸山洞和杀怪物 红石比较器Redstone Comparator 红石火把,原始和下界石英Redstone Torches &amp; Stone &amp; Nether Quartz 仅在红石电路中使用.比较信号大小，接收大的那一方信号！ 陷进箱Trapped Chest 箱子和绊线Chest &amp; Tripwire Hook 打开箱子的适合发出红石信号.注：不同于普通箱子的是，如果在他前面铺红石，红石不会和他产生连接 测重压力板Weighted Pressure Plates 铁锭或者金锭Iron Ingots or Gold Ingots 类似普通的压力板,但是只能用物品激活. 物品的数量绝对红石信号的强度. 食物合成 名称 材料 合成示意图 描述 碗Bowl 木板Wooden Planks 装蘑菇煲. 注：吃完之后碗可以重复使用！ 蘑菇煲Mushroom Stew 碗,红蘑菇和棕色蘑菇Bowl &amp; Red Mushroom &amp; Brown Mushroom 恢复4点饥饿值.注：吃完之后碗可以重复使用！非常不错的食物 面包Bread 小麦Wheat 恢复2.5点饥饿值. 注：非常不错的食物 金苹果Golden Apple 苹果和金粒Apple &amp; Gold Nuggets 恢复2点饥饿值. 注：可以在不是满饥饿度的时候恢复生命，打末影龙和凋零必备食物！也是游戏中最好食材 附魔金苹果Enchanted Golden Apple 苹果和金块Apple &amp; Gold Blocks 恢复2点饥饿值. 同时给予30秒的抗火属性. 注：金苹果的升级版，也是游戏中最好食材 糖Sugar 甘蔗Sugar Cane 用来制作蛋糕. 蛋糕Cake 牛奶桶,汤,小麦和鸡蛋Milk Buckets &amp; Sugar &amp; Wheat &amp; Egg 每块恢复1.5饥饿值,一共6块. 曲奇Cookies 小麦和可可豆Wheat &amp; Cocoa Beans 恢复1点饥饿值. 西瓜Melon Block 西瓜片Melon Slice 西瓜.可以食用 西瓜种子Melon Seeds 西瓜片Melon Slice 能够种植在耕地上.注：成熟以后可以得到西瓜 南瓜种子Pumpkin Seeds 南瓜Pumpkin 能够种植在耕地上.注：成熟以后可以得到南瓜 金胡萝卜Golden Carrot 胡萝卜和金粒Carrot &amp; Gold Nuggets 酿造原料,恢复3点饥饿值. 南瓜派Pumpkin Pie 南瓜,鸡蛋和糖Pumpkin &amp; Egg &amp; Sugar 恢复4点饥饿值.非常不错的食物！ 其他合成 名称 材料 合成示意图 描述 床Bed 木板和羊毛Wooden Planks &amp; Wool 在晚上睡觉快速度过夜晚. 注：当然周围不能有僵尸，不然无法进入睡眠！另外在末地可以利用床炸末影龙，是打末影龙的高端技巧！ 画Painting 木棍和羊毛Sticks &amp; Wool 装饰.得到的画是随机图案！ 纸Paper 甘蔗Sugar Cane 用来制造地图和书本. 书Book 纸Paper 用来制造书架和书与笔. 书与笔Book and Quill 书,羽毛和墨囊Book &amp; Feather &amp; Ink Sac 能够写文章. 注：写出来的文章可以阅读哦！ 地图Map 纸和指南针Paper &amp; Compass 能够显示附近一块的地图. 注：可以用几张地图合成出一张大地图 玻璃板Glass Pane 玻璃Glass Blocks 类似栅栏的窗格玻璃.注：非常不错的装饰物品 铁栏杆Iron Bars 铁锭Iron Ingots 类似栅栏但是只有1个方块的高度.常见于末影遗迹和地牢！ 金锭Gold Ingot 金粒Gold Nugget 用来制造其他东西. 注：也可以烧制金矿石获得。在地狱打僵尸猪人会爆金粒 地狱砖栅栏Nether Brick Fence 地狱砖块Nether Brick 类似普通的栅栏只不过原料不同. 末影之眼Eye of Ender 末影珍珠和烈焰粉Ender Pearl &amp; Blaze Powder 定位末地传送门. 注：使用方法：右键斜向上抛出，跟着末影之眼的方向走，当他只望头顶飞的时候，这时候向下挖即可！ 附魔台Enchantment Table 书,钻石和黑曜石Book, Diamond &amp; Obsidian. 用来附魔工具.附魔所需等级最高30级，30级满16个书架附魔也被称为顶级附魔！ 火焰弹Fire Charge 烈焰粉,碳和火药Blaze Powder &amp; Coal &amp; Gunpowder 能够通过发射器发射的火球. 末影箱Ender Chest 黑曜石和末影之眼Obsidian &amp; Eye of Ender 用于储存. 所有末影箱共享一个物品栏. 注：可以在其他地方拿到你想用的东西！ 信标Beacon 玻璃,黑曜石和下界之心Glass &amp; Obsidian &amp; Nether Star 用于放置在钻石块，金块，绿宝石块或铁块（或这四种方块的任意组合）结构的金字塔顶端，可以向天空直射光束的功能型方块. 注：用于装饰！和定位，可以加上玻璃变成彩色信标！ 铁跕Anvil 铁块和铁锭Iron Block &amp; Iron Ingot 修复物品和合并附魔.注：铁砧使用过后会损坏，有一定的使用次数！ 花盆Flower Pot 红砖Bricks 装饰.可以栽种小花，是室内盆景必备！ 物品展示框Item Frame 木棍和皮革Sticks &amp; Leather 放在墙上展示物品和方块. 注：可以将任意物品放入物品展示框 萝卜钓竿Carrot on a Stick 钓竿和胡萝卜Fishing Rod &amp; Carrot 控制猪. 注：骑上猪，猪就会跟你跑啦！ 烟花火箭Firework Rocket 火药,纸和烟火之星Gunpowder &amp; Paper &amp; Firework Star 烟花. 烟火之星Firework Star 火药,燃料和附加物品（可选）Gunpowder &amp; Dye &amp; an extra ingredient (optional) 不同的烟火之星决定不同的烟花效果. 染料合成 名称 材料 合成示意图 描述 骨粉Bone Meal 骨头Bone 用来使农作物树木快速长大. 也可以催熟蘑菇！注：可以和发射器一起制作出半自动农场，效率超高 淡灰色染料Light Gray Dye 骨粉和墨囊Bonemeal &amp; Ink Sac 用于制作淡灰色羊毛. 灰色染料Gray Dye 骨粉和墨囊Bonemeal &amp; Ink Sac 用于制作灰色羊毛. 玫瑰红Rose Red 玫瑰花Rose 用于制作红色羊毛. 橙色染料Orange Dye 玫瑰红和蒲公英黄Rose Red &amp; Dandelion Yellow 用于制作橙色羊毛. 蒲公英黄Dandelion Yellow 蒲公英Dandelion 用于制作黄色羊毛. 黄绿色染料Lime Dye 仙人掌绿和骨粉Cactus Green &amp; Bone Meal 用于制作黄绿色羊毛. 淡蓝色染料Light Blue Dye 青金石染料和骨粉Lapis Lazuli Dye &amp; Bone Meal 用于制作淡蓝色羊毛. 青色染料Cyan Dye 青金石染料和仙人掌绿Lapis Lazuli Dye &amp; Cactus Green 用于制作青色羊毛. 紫色染料Purple Dye 青金石染料和玫瑰红Lapis Lazuli Dye &amp; Rose Red 用于制作紫色羊毛. 品红染料Magenta Dye 粉红色染料和紫色染料Purple Dye &amp; Pink Dye 用于制作品红羊毛. 粉红色染料Pink Dye 骨粉和玫瑰红Bone Meal &amp; Rose Red 用于制作粉红色羊毛. 羊毛合成 名称 材料 合成示意图 描述 羊毛Wool 线String 建筑材料能被染色.注： 可以用剪刀从羊身上获取，也可以直接杀死羊获取 浅灰色羊毛Light Gray Wool 羊毛和浅灰色染料Wool &amp; Light Gray Dye 建筑和装饰材料. 灰色羊毛Gray Wool 羊毛和灰色染料Wool &amp; Gray Dye 建筑和装饰材料. 黑色羊毛Black Wool 羊毛和墨囊Wool &amp; Ink Sac 建筑和装饰材料. 红色羊毛Red Wool 羊毛和玫瑰红Wool &amp; Rose Red 建筑和装饰材料. 橙色羊毛Orange Wool 羊毛和橙色染料Wool &amp; Orange Dye 建筑和装饰材料. 注：在沙漠神殿可以得到 黄色羊毛Yellow Wool 羊毛和蒲公英黄Wool &amp; Dandelion Yellow 建筑和装饰材料. 黄绿色羊毛Lime Wool 羊毛和黄绿色染料Wool &amp; Lime Dye 建筑和装饰材料. 绿色羊毛Green Wool 羊毛和仙人掌绿Wool &amp; Cactus Green 建筑和装饰材料. 淡蓝色羊毛Light Blue Wool 羊毛和淡蓝色染料Wool &amp; Light Blue Dye 建筑和装饰材料. 青色羊毛Cyan Wool 羊毛和青色染料Wool &amp; Cyan Dye 建筑和装饰材料. 蓝色羊毛Blue Wool 羊毛和青金石染料Wool &amp; Lapis Lazuli Dye 建筑和装饰材料.注： 在沙漠神殿可以得到 紫色羊毛Purple Wool 羊毛和紫色染料Wool &amp; Purple Dye 建筑和装饰材料. 品红色羊毛Magenta Wool 羊毛和品红色染料Wool &amp; Magenta Dye 建筑和装饰材料. 粉红色羊毛Pink Wool 羊毛和粉红色染料Wool &amp; Pink Dye 建筑和装饰材料. 棕色羊毛Brown Wool 羊毛和可可豆Wool &amp; Cocoa Beans 建筑和装饰材料. 炼金合成 名称 材料 合成示意图 描述 玻璃瓶Glass Bottle 玻璃Glass 用于酿造.注：打女巫可以掉落玻璃瓶！ 炼药锅Cauldron 铁锭Iron Ingot 填满玻璃瓶的水.用于酿造药水！ 酿造台Brewing Stand 烈焰棒和圆石Blaze Rod &amp; Cobblestone 用于酿造. 烈焰粉Blaze Powder 烈焰棒Blaze Rod 用于制造末影眼和岩浆膏.注：地狱烈焰人掉落，找寻末影遗迹必备材料！ 研究膏Magma Cream 史莱姆和烈焰粉Slimeball &amp; Blaze Powder 用于药剂制作. 发酵蜘蛛眼Fermented Spider Eye 蜘蛛眼,棕色蘑菇和糖Spider Eye, Brown Mushroom &amp; Sugar 用于药剂制作. 闪烁的西瓜Glistering Melon 西瓜片和金粒Melon Slice &amp; Gold Nugget 用于药剂制作. 1.8新增合成 名称 材料 合成示意图 描述 兔肉煲 兔肉、碗、蘑菇、胡萝卜、土豆 用于食用，可恢复饱食度！ 皮革 兔子皮 与皮革作用一样 新栅栏 木板、木棍 用于圈地和制作农场、牧场 海晶灯 海晶碎片和海晶沙粒 用于水下照明 海晶石 海晶碎片 用于装饰 海晶石砖 海晶碎片 用于装饰 暗海晶石 海晶碎片、墨囊 用于装饰]]></content>
      <tags>
        <tag>Minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派折腾记——Samba]]></title>
    <url>%2F2017%2F01%2F31%2Fraspberry-train%2F</url>
    <content type="text"><![CDATA[树莓派用多了，总是要经常树莓派上传文件或者从树莓派下载文件，纵然可以使用putty携带的pscp或者rsync之类的命令行软件，但是总是不如图形界面来的方便，还省得记那些命令。于是，有了此文。1$ sudo apt-get install samba 然后，编辑/etc/samba/smb.conf，在文件末尾添加上如下内容123456789[public]comment = Public Storagepath = /home/pi #这里是用于树莓派共享到局域网的目录，这里设置为了pi用户的家目录read only = no#任何人都具有了访问修改的权限#因为是公共文件夹，所以给了所有用户全部权限，可以自定义create mask = 0777#新创建文件的默认属性directory mask = 0777#新创建文件夹的默认属性guest ok = yes#默认的访问用户名为guestbrowseable = yes 然后，通过命令sudo smbd restart，便可以在Windows的网络邻居里面发现树莓派了，如图此时只能看到树莓派出现在网络邻居里面，要想能正常查看树莓派上的内容，还是得要进行一些配置输入如下命令1$ sudo smbpasswd -a pi 按照提示，输入密码(密码是自定义的)12345pi@raspberrypi:/etc/samba $ sudo smbpasswd -a piNew SMB password:Retype new SMB password:Added user pi.pi@raspberrypi:/etc/samba $ 然后，在网络邻居里面双击raspberry，会提示需要输入用户名和密码，用户名为pi，密码为刚才设置的密码。然后，就可以畅快的用网络邻居与树莓派之间互传文件了。生命重在折腾]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx的一点点小折腾]]></title>
    <url>%2F2017%2F01%2F27%2Fnginx-skill%2F</url>
    <content type="text"><![CDATA[说明对于这样某个url来说，假设其站点在主机上的/var/www/目录下，若该目录下的结构是这样(图示结构为本站的目录结构):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114├─2016│ ├─03│ │ ├─25│ │ │ └─hello-world│ │ ├─26│ │ │ └─First-day│ │ └─28│ │ └─ubuntu-touchpad│ ├─04│ │ ├─03│ │ │ └─Lake-Counting│ │ └─26│ │ └─start│ ├─07│ │ └─03│ │ └─Minecraft-server│ │ └─images│ ├─10│ │ └─20│ │ └─Aria2c│ ├─11│ │ ├─25│ │ │ └─High-Speed-transfer│ │ └─26│ │ ├─4-四元数与欧拉角│ │ └─NOIP2016│ └─12│ ├─05│ │ └─NOIP2016更改│ ├─09│ │ └─Dynamic-programming│ ├─23│ │ └─zheyilu│ └─31│ └─such-a-program├─2017│ └─01│ ├─06│ │ └─who-am-I│ ├─08│ │ ├─error-in-Linux-when-use-C-language│ │ └─install-node-js-on-a-Linux-OS│ ├─09│ │ └─install-node-js-on-raspberry-3B│ ├─10│ │ └─Ferryman│ ├─12│ │ └─replace-background-image-of-ubuntu-when-login-in-to-it│ ├─16│ │ └─home│ ├─19│ │ └─NOIP-2015-Message│ └─25│ └─use-proxy-in-terminal├─about├─archives│ ├─2016│ │ ├─03│ │ ├─04│ │ ├─07│ │ ├─10│ │ ├─11│ │ ├─12│ │ └─page│ │ └─2│ ├─2017│ │ └─01│ └─page│ ├─2│ └─3├─css├─images├─js│ └─src│ └─schemes├─lib│ ├─algolia-instant-search│ ├─fancybox│ │ └─source│ │ └─helpers│ ├─fastclick│ │ └─lib│ ├─font-awesome│ │ ├─css│ │ └─fonts│ ├─jquery│ ├─jquery_lazyload│ ├─ua-parser-js│ │ └─dist│ └─velocity├─page│ ├─2│ └─3└─tags ├─C ├─Games ├─hexo ├─Linux ├─node-js ├─NOIP ├─raspberry ├─technology ├─tecnology ├─Ubuntu ├─ubuntu-touchpad-触控板调节 ├─wanwan ├─乱七八糟 ├─动态规划 ├─学术 ├─小窍门 ├─文学 ├─深度优先搜索 ├─竞赛 └─算法 此时，若是直接访问hushuangpu.xyz/tags看到的是站点目录下的tags文件夹内的内容。若是想要访问hushuangpu.xyz/src，且src指向的内容不在站点目录里面，该怎么弄？于是有了此文。 实战这里用Nginx实现，只需要更改nginx的配置文件就好,若无意外，正常的nginx的配置文件内容应该如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; # Load dynamic modules. See /usr/share/nginx/README.dynamic. include /usr/share/nginx/modules/*.conf; events &#123; worker_connections 1024; &#125; http &#123; log_format main '$remote_addr - $remote_user [$time_local] "$request" '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; root /usr/share/nginx/html; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; 我的站点文件全部放在/usr/share/nginx/html目录里面了，然后我想让hushuangpu.xyz/src指向另外一个目录，比如/var/resource,在配置文件内添加如下内容:12345678charset utf-8;#指定文件名编码，防止中文乱码，若是在Windows上使用，应该将其utf-8改成gbkclient_max_body_size 4G;#限制单个最大文件的体积location /src &#123;#这行的src就是hushuangpu.xyz/src里面的src alias /usr/resource/;#更改目录指向 autoindex on;#建立目录 autoindex_exact_size off;#显示文件体积 autoindex_localtime on;显示时间&#125; 本站实现示范如下: 其它说明在上文中，代码12345678charset utf-8;#指定文件名编码，防止中文乱码，若是在Windows上使用，应该将其utf-8改成gbkclient_max_body_size 4G;#限制单个最大文件的体积location /src &#123;#这行的src就是hushuangpu.xyz/src里面的src alias /usr/resource/;#更改目录指向 autoindex on; autoindex_exact_size off; autoindex_localtime on;&#125; 其实是在/usr/resource建立了以个静态文件服务器，若是要当成web服务器则要改成这样12345charset utf-8;#指定文件名编码，防止中文乱码，若是在Windows上使用，应该将其utf-8改成gbkclient_max_body_size 4G;#限制单个最大文件的体积location /src &#123;#这行的src就是hushuangpu.xyz/src里面的src alias /usr/resource/;#更改目录指向&#125; 生命重在折腾]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux终端使用代理]]></title>
    <url>%2F2017%2F01%2F25%2Fuse-proxy-in-terminal%2F</url>
    <content type="text"><![CDATA[用linux的都能体会到，如果用国外的软件源，更新软件将是极其痛苦的事情————速度慢啊！但是如果使用国内的软件源，如果某些软件国内软件源没有，还是会从国外的软件源下载，于是纠结了一下，使出下面的办法: 思路即使clowwindy大神被请喝茶，他的项目仍然被持续更新。 用影梭能很方便的开启socks5代理，并且速度还不赖，于是朝着这个方向走。 更新软件，就要让’apt-get’走代理通道，而不是正常的http/https/ftp。 有了目标好办事，下面是具体实施步骤。 实战劫持apt-get到socks5，我用了这个软件————Proxychains 安装Proxychains使用root权限(其实只有第四个和第五个命令需要root权限)123456$ git clone https://github.com/rofl0r/proxychains-ng.git$ cd proxychains-ng$ ./configure$ make &amp;&amp; make install$ cp ./src/proxychains.conf /etc/proxychains.conf$ cd .. &amp;&amp; rm -rf proxychains-ng 然后，编辑/etc/proxychains.conf，到最后一行，把socks4 127.0.0.1 9095改成socks5 127.0.0.1 1080(注意: 这里如果直接注释掉该行，然后自己新添一行的话，需要注意缩进)去掉49行quiet_mode前面的#号，这样运行的时候proxychains4就不会输出大量log了。 然后，启动Shadosocks后(它默认会开启一个本地1080的socks5端口)，在任意命令前面加上proxychains4，若有需要联网的操作，就会被自动劫持到socks5代理去，这样下载国外的资源速度会快一些。 示范使用proxychains4更新软件源的一个小示范 一点点说明虽然此类文章百度一搜一大把，但是还是要把我参考的原文贴出来http://www.jianshu.com/p/8e7d7f57bf59,感谢原博主。 原文中提及好几种在终端使用代理的办法，我只取了一种，因为proxychains可以针对任何联网的软件，而不需要记住某些环境配置，一次配置，终身方便。 有一个大前提，就是你需要能Fuck GFW。 其他的玩法将代码clone到本地之后，可以编辑项目目录里面的src文件夹内的main.c，把71行的int quiet = 0;改成int quiet = 1;，这样运行的时候就不会输出大量log了。 悠哉的一天&gt;_&lt; 生命重在折腾]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP 2015 信息传递]]></title>
    <url>%2F2017%2F01%2F19%2FNOIP-2015-Message%2F</url>
    <content type="text"><![CDATA[初探图论，这本来是大一就该学的，没想到拖到这个假期，感觉好懒啊。尝试做了一下NOIP 2015 day1 的信息传递，整理如下。 题目 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; int n,i,j=0; cin&gt;&gt;n; int circle[n+2]=&#123;0&#125;,status[n+2]=&#123;0&#125;,via[n+2]=&#123;0&#125;,flag[n+2]=&#123;0&#125;;//circle用来存储输入的数据，status用来记录i个人有几个人会告诉他信息，via用来记录某个人是否被告诉过信息 for( i = 1 ; i &lt;= n ; i++ ) &#123; cin&gt;&gt;circle[i]; status[circle[i]]++; &#125; for( i = 1 ; i &lt;= n; i++ ) &#123; if(status[i]==0) &#123; flag[j++]=i; via[i]=1; &#125; &#125; for( i = 0 ; i &lt; j ; i++ ) &#123; status[circle[flag[i]]]--; if(status[circle[flag[i]]]==0) &#123; flag[j++]=circle[flag[i]]; via[circle[flag[i]]]=1; &#125; &#125; int ans=n,temp; for( i = 1 ; i &lt;= n ; i++ ) &#123; if( via[i]==0 &amp;&amp; circle[i]!=0 ) &#123; via[i]=1; temp=1; j=circle[i]; while(!via[j]) &#123; via[j]=1; j=circle[j]; temp++; &#125; if(temp&lt;ans) ans=temp; &#125; &#125; printf("%d",ans); return 0;&#125; 解析题意说明代码大量参考了此文章文中的没有给出详细解题信息，我看了之后整理了一下。文中有这样一句话 其实这道题题意非常明确，就是让我们寻找一个最小环的长度，怎么求呢？也很简单，先把入度为0的点删除，然后把这个点指向的点的入度-1，如果入度为0，也删去，这样就只保留有用的点，那么从任意一个点开始，用vis数组记录是否被访问过，访问到一个新节点就累加计数器，然后就做出来了.bfs和dfs都可以. 把样例输入数据变成图，就成了这样：从图中可以看到，第一个人讲自己所知道的信息告诉第二个人，第二个人告诉第四个人，第三个人告诉第二个人，第四个人告诉第三个人，第五个人告诉第一个人。这样，仔细一看，2绝对不可能从1处获得自己的生日(游戏结束条件) 很容易看出，2将自己的生日告诉3，3告诉4，4告诉2，2获得了自己的生日，游戏结束，对于3和4来说也同样是这样。 所以，这个题简短来说，就是找到图中的最小环。 解题思路首先，由于5—&gt;1—&gt;2并不构成圈，所以2不可能从1处获得自己的信息，所以干脆将5–&gt;1–&gt;2这条路去掉，这样，只需要统计形成圈的有几个人就行了，若有多个圈，找出最小的圈就好。 代码分析存储数据，计算权值12345for( i = 1 ; i &lt;= n ; i++ )&#123; cin&gt;&gt;circle[i]; status[circle[i]]++;&#125; 这一段意思很明显，输入数据，然后，记录每个人有几个人告诉他信息 找到权值为0的人权值为0，也就是示范数据中的5号，没有任何人将自己的信息告诉他12345678for( i = 1 ; i &lt;= n; i++ )&#123; if(status[i]==0) &#123; flag[j++]=i; via[i]=1; &#125;&#125; flag用于标记权值为0的人的编号 去除权值为0的点123456789for( i = 0 ; i &lt; j ; i++ )&#123; status[circle[flag[i]]]--;//去掉某个权值为0的点之后，讲它所指向的人的权值减1 if(status[circle[flag[i]]]==0)//若此人的权值减1之后，其权值为0，就将他的编号标记一下，同时更新j(x循环结束条件)的值 &#123; flag[j++]=circle[flag[i]]; via[circle[flag[i]]]=1; &#125;&#125; 计算圈的成员数目，找到最小的圈123456789101112131415161718int ans=n,temp;for( i = 1 ; i &lt;= n ; i++ )&#123; if( via[i]==0 &amp;&amp; circle[i]!=0 ) &#123; via[i]=1; temp=1; j=circle[i]; while(!via[j]) &#123; via[j]=1; j=circle[j]; temp++; &#125; if(temp&lt;ans) ans=temp; &#125;&#125; 一点点小总结可能我的解析说得也并不比原文详细多少，实际上我是跟着代码一步一步调试，才看懂原文的代码的。 然后，我剔除了原文的队列，使用了一个数组代替，导致我不得不更新数组的有效长度，也就是文中的j值。反而让代码变得更加难以理解。不过，也照顾了一下不知道队列的小伙伴。然后，原文使用了1memset(to, 0, sizeof(to)); 来将数组清零，有时候，会忘记这个函数的用法，所以我用了下面的办法1int a[100]=&#123;0&#125;; 这样，只要初始化数组的第一个元素为0，数组的其他元素会全都变成0。 生命重在折腾]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[替换Ubuntu默认的登录背景图片]]></title>
    <url>%2F2017%2F01%2F12%2Freplace-background-image-of-ubuntu-when-login-in-to-it%2F</url>
    <content type="text"><![CDATA[Ubuntu默认的登录背景看起来还是比较高贵的，但是作为一个爱折腾的人，当然要换成自己喜欢的背景图了。一开始跟着百度走，进了不少坑，最后还是自己走出来的。先上一个成品照百度得到的答案几乎都是安装ubuntu tweak，然而，安装ubuntu tweak的过程就很艰辛。 思路:ubuntu启动到达登录界面的时候，无非就是将已经存储在电脑上的背景图片显示在登录界面，找到这张图片，替换成自己的就好了。系统默认的图片是在”/usr/share/background/“下的”warty-final-ubuntu.png”。有基础的童鞋到这儿已经知道该怎么办了，下面的是给新手看的。 实战先准备好一张想要当成背景的图片(PS:必须是png格式的，jpg格式的不能用，我已经试过了)，假设这张图片叫1.png，放在用户主目录下，那么按Ctrl Alt T打开终端，输入以下命令123$ cd ~/$ sudo mv /usr/share/background/warty-final-ubuntu.png /usr/share/background/warty-final-ubuntu.png-bak$ sudo mv 1.pn /usr/share/background/warty-final-ubuntu.png O了，注销或者重启一下，就可以看到成果了。 注意对于图片的尺寸要求，至少清晰度和要屏幕的分辨率一样高，这样才不会失真，比例最好用16:9的，现在大多数屏幕的比例都是这个。生命重在折腾]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>technology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摆渡人]]></title>
    <url>%2F2017%2F01%2F10%2FFerryman%2F</url>
    <content type="text"><![CDATA[I exist because you need me.如果我真的存在，也是因为你需要我。 前些天读完《摆渡人》，小小的写点读后感。 他坐在隧道出口的左侧，手放在膝盖上，注视着她。在这个距离望过去，只能辨认出他是个男孩，大概十几岁的样子。山风吹乱了他浅茶色的头发，拍打着他的脸。“崔斯坦”她低声说，轻松和喜悦一下充盈在胸中。她看着他出现在了自己的世界里，如痴如醉。他成功了。这时，一个人走过来隔在了他们之间，是一个消防队员。迪伦静静的看着他俯下身子，给崔斯坦的肩上披上了一条毯子。那人在向他询问着什么，迪伦看到崔斯坦摇了摇头。接着他慢慢地，有点笨手笨脚的从草地上站了起来。对着消防队员讲完了最后一句话，他开始朝她的方向缓缓走了过来。就要走到她跟前时，他冲她一笑。“嗨。”他喃喃地说，伸出一只手轻柔地拍了拍迪伦身上地毯子。他的手指顺着她身体一侧慢慢划过，最后紧紧地抓住了她的手。“嗨。”她也轻声回了一句，嘴唇颤抖着露出了微笑，“原来你在这里。”“我在这里。” 迪伦很平静的接受了自己死亡的事实。崔斯坦感觉这个灵魂的不一般。 听了崔斯坦的口中故事，迪伦觉得崔斯坦受着不平之待遇。 灵魂与她的摆渡人一同跨过险恶的荒原。 迪伦在跨过边界之后，仍然做出了所有灵魂都没有做出过的决定————返回荒原，寻找崔斯坦。即使这样会死去。 人这一辈子，所求为何？得何而足？一个灵魂伴侣。]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在树莓派3B上安装node.js]]></title>
    <url>%2F2017%2F01%2F09%2Finstall-node-js-on-raspberry-3B%2F</url>
    <content type="text"><![CDATA[本文主讲如何在树莓派3B上安装node.js (在之前的文章中说了通用的办法————编译node.js源码，但是树莓派的性能太弱，编译时间非常长) 环境描述 树莓派安装了2016-11-25-raspbian-jessie-lite(PS：在此版本的镜像中，默认禁用了ssh，在烧录好镜像之后，在boot分区中新建一个名为ssh的文件夹，正常开机，通过ssh即可连接到树莓派) 所有官方软件源软件已经更新至最新版。 目标在树莓派3B上安装node.js-6.9.4(截至本文发布时间的最新稳定版) 实战连接树莓派之后：下载已经编译好的node.js for ARM 版本1$ wget https://nodejs.org/dist/latest-v6.x/node-v6.9.4-linux-armv7l.tar.gz 解压文件1$ tar -xvf node-v6.9.4-linux-armv7l.tar.gz 验证node是否正常123$ cd node-v6.9.4-linux-armv7l/bin/$ ./node -vv6.9.4 说明正常，PS:运行npm会出现如下错误信息:12$ ./npm -v/usr/bin/env: node: No such file or directory 别着急，往下看。依次输入以下命令:1234$ cd ~/$ mv node-v6.9.4-linux-armv7l /usr/local/node$ echo PATH=$PATH:/usr/local/node/bin &gt;&gt; ~/.bashrc$ source .bashrc 现在在任何路径下都可以通过输入node -v得到当前的node.js版本。若出现npm命令出错的情况，那么就编辑”/etc/sudoers”文件,将12行的1Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" 更改为1Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/node/bin" 然后重启一下，enjoy it. 一点点说明理论上任何Linux系统都可以通过类似的办法来安装Node.js，并且还省去了很多时间，但是需要注意下载的node.js的版本，本文的命令中下载node.js仅仅适用于ARM v7l平台想要知道需要下载什么版本的node.js，通过命令1$ uname -a 来查看，在我的树莓派上显示如下信息1Linux raspberrypi 4.4.38-v7+ #938 SMP Thu Dec 15 15:22:21 GMT 2016 armv7l GNU/Linux 在cent OS 6上显示如下信息1Linux VM_131_160_centos 3.10.0-514.2.2.el7.x86_64 #1 SMP Tue Dec 6 23:06:41 UTC 在ubuntu 14.04 LTS server 上显示如下信息1Linux host_name 2.6.32-042stab116.2 #1 SMP Fri Jun 24 15:33:57 MSK 2016 x86_64 x86_64 x86_64 GNU/Linux 在输出信息中即可看到，树莓派是ARM v7l,cent OS和ubuntu是x86_64(x86_64 表示64位版本，x86表示32位)适用于64位Linux系统的node.js1$ wget https://nodejs.org/dist/latest-v6.x/node-v6.9.4-linux-x64.tar.gz 适用于32位Linux系统的node.js1$ wget https://nodejs.org/dist/latest-v6.x/node-v6.9.4-linux-x86.tar.gz 其他步骤类似。生命重在折腾]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>raspberry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统中，gets函数出错]]></title>
    <url>%2F2017%2F01%2F08%2Ferror-in-Linux-when-use-C-language%2F</url>
    <content type="text"><![CDATA[其实这是在很早之前就遇到的问题，这样一个简单的程序1234567#include&lt;stdio.h&gt;int main()&#123; char str[100]; gets(str); printf("%s\n",str);&#125; 解决办法在Linux中使用gcc编译这段代码的时候，出现如下错误12345warning: 'gets' is deprecated (declared at /usr/include/stdio.h:638) [-Wdeprecated-declarations] gets(str); ^/tmp/ccf5cnfv.o: In function `main':test.c:(.text+0x10): warning: the `gets' function is dangerous and should not be used. 最后一行说了，gets函数是危险的，不应该被使用。当初人比较二的时候，用了这样一个办法,发在了博客园。现在感觉有诸多漏洞，还是补一下比较好。求助google，在stackoverflow找到了解决办法这样做1234567#include&lt;stdio.h&gt;int main()&#123; char str[100]; fgets(str,100,stdin ); printf("%s\n",str);&#125; 使用fgets函数来代替gets函数，但是实际上这里仍然有局限性，fgets函数中的第二个参数限制了能输入的字符数目，似乎我比较二的时候，想出来的解决办法更好呢^_^ 原因说明If you have code like this:12char s[10];gets( s ); and you type in more than 10 characters when the program is run, you will overflow the buffer, causing undefined behaviour. The gets() function has no means of preventing you typing the characters and so should be avoided. Instead you should use fgets(), which allows you to limit the number of characters read, so that the buffer does not overflow.:12char s[10];fgets( s, 10, stdin ); The puts() function is perfectly safe, provided the string that you are outputting is null-terminated.不想用机翻的来给你看，将就一下 =_= 生命重在折腾]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux上安装node.js]]></title>
    <url>%2F2017%2F01%2F08%2Finstall-node-js-on-a-Linux-OS%2F</url>
    <content type="text"><![CDATA[在之前的文章中提及，使用“Hexo”，需要安装node.js,Windows上安装很方便，在其官网下载安装包之后，按照正常的步骤安装即可食用。 说明在linux中安装却成了问题，在大多数的Linux发行版中，默认源的node.js版本大都跟不上官方最新版，在我之前的文章————本站建立中，所使用的方法是hexo官网提及的办法1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 或者1$ wget -q0- https://raw.github.com/creationix/master/install.sh | sh 实际上，我在使用了这个办法之后，确实能正常安装node.js，但是，安装之后最大的问题就是终端打开时间大大变长(鄙人感觉是脚本为系统添加了某些打开终端就执行的东西)，很是不爽，所以决定不用上面的方法安装。然后，在官网下载了源码，手动编译安装。 实战我拿到的node.js版本是6.9.4，下载到源码之后，得到的是一个.tar.gz文件，我们需要解压它，然后执行一下configure1234$ wget https://nodejs.org/dist/latest-v6.x/node-v6.9.4-linux-x64.tar.gz$ tar -xvf node-v6.9.4.tar.gz$ cd node-v6.9.4/$ ./configure 这个时候屏幕上应该显示以下信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960creating ./icu_config.gypi* Using ICU in deps/icu-smallcreating ./icu_config.gypi&#123; 'target_defaults': &#123; 'cflags': [], 'default_configuration': 'Release', 'defines': [], 'include_dirs': [], 'libraries': []&#125;, 'variables': &#123; 'asan': 0, 'coverage': 'false', 'debug_devtools': 'node', 'force_dynamic_crt': 0, 'gas_version': '2.24', 'host_arch': 'x64', 'icu_data_file': 'icudt57l.dat', 'icu_data_in': '../../deps/icu-small/source/data/in/icudt57l.dat', 'icu_endianness': 'l', 'icu_gyp_path': 'tools/icu/icu-generic.gyp', 'icu_locales': 'en,root', 'icu_path': 'deps/icu-small', 'icu_small': 'true', 'icu_ver_major': '57', 'node_byteorder': 'little', 'node_enable_d8': 'false', 'node_enable_v8_vtunejit': 'false', 'node_install_npm': 'true', 'node_module_version': 48, 'node_no_browser_globals': 'false', 'node_prefix': '/usr/local', 'node_release_urlbase': '', 'node_shared': 'false', 'node_shared_cares': 'false', 'node_shared_http_parser': 'false', 'node_shared_libuv': 'false', 'node_shared_openssl': 'false', 'node_shared_zlib': 'false', 'node_tag': '', 'node_use_bundled_v8': 'true', 'node_use_dtrace': 'false', 'node_use_etw': 'false', 'node_use_lttng': 'false', 'node_use_openssl': 'true', 'node_use_perfctr': 'false', 'node_use_v8_platform': 'true', 'openssl_fips': '', 'openssl_no_asm': 0, 'shlib_suffix': 'so.48', 'target_arch': 'x64', 'uv_parent_path': '/deps/uv/', 'uv_use_dtrace': 'false', 'v8_enable_gdbjit': 0, 'v8_enable_i18n_support': 1, 'v8_inspector': 'true', 'v8_no_strict_aliasing': 1, 'v8_optimized_debug': 0, 'v8_random_seed': 0, 'v8_use_snapshot': 'true', 'want_separate_host_toolset': 0&#125;&#125;creating ./config.gypicreating ./config.mk 然后，准备编译1$ make 屏幕上会滚动编译信息，编译时间视电脑性能而定，编译结束后，输入1make install 检验是否安装成功12$ node -v$ npm -v 有返回信息则安装成功，若是提示没有此命令，则安装失败。 安装失败的解决办法编译node.js需要gcc/g++的版本为4.8以上我在ubuntu 14.04，cent OS 6上测试均成功安装。需要注意的是，cent os 可能没有默认安装g++,需要这样12$ yum update -y$ yum install gcc-c++ -y Enjoy it! node.js下载地址由于node.js官网在国外，在国内下载源码速度实在是不怎么理想，特意在百度云备份了以一下(点我下载)生命重在折腾]]></content>
      <tags>
        <tag>tecnology</tag>
        <tag>Linux</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个超乎预料的程序]]></title>
    <url>%2F2016%2F12%2F31%2Fsuch-a-program%2F</url>
    <content type="text"><![CDATA[写着写着，发现有点超乎想象，没想到写那么长时间 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328/*没想到会用那么长时间，果然是说得容易，做得难。思路是分别提取每个单项式的系数(系数可以确定改单项式的符号)、指数标准的单项式由以下部分组成[符号-/+][系数][x^][指数]当指数为0时 显示为(看起来是)n当系数为±1且指数为1时 显示为x当系数不为±1且指数为1时 显示为nx其他的为标准形式的单项式±nx^a*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//分别定义解决程序所需的七个功能的函数void Addition();void Soustraction();void Multiplication();void Division();void Euclid();void Factorization();//这个结构体，用来存储提取后的系数、指数和符号struct Array_poly&#123; int coefficient;//系数 int index;//指数 char symbol;//符号&#125;;//show_info用来显示屏幕的提示信息void show_info()&#123; printf(" + : Addition\n - : Soustraction\n * : Multiplication\n / : Division\n d : Derivation\n e : Euclid\n f : Factorization\n q : Quit\ncmd&gt; ");&#125;int main()&#123; //freopen("data.txt","r",stdin); char str; show_info(); while(scanf("%c",&amp;str)!=EOF)//读入用户所选 '+'/-/*...... &#123; switch(str) &#123; case '+' : Addition(); break; //case '-' : Soustraction(); break; //case '*' : Multiplication(); break; //case '/' : Division(); break; //case 'd' : Derivation(); break; //case 'e' : Euclid(); break; //case 'f' : Euclid; break; case 'q' : return 0; break; default : continue; &#125; show_info(); &#125; printf("\nBoom\n"); return 0;&#125;//执行将两个多项式加起来的选项。void Addition()&#123; char p1x[100]=&#123;0&#125;,p2x[100]=&#123;0&#125;;//用于存储p1(x)和p2(x)两个字符串 int i=0,j=0,tmp=0,flag=0,k=0; //int coefficient; struct Array_poly ans[20]=&#123;&#123;0,0,0&#125;&#125;,ans2[20]=&#123;&#123;0,0,0&#125;&#125;;//用于存储提取出来的系数、指数、符号; printf("p1(x) = ");//提示信息 scanf("%s",p1x); printf("p2(x) = ");//提示信息 scanf("%s",p2x); while(p1x[i])//用于提取p1(x)字符串的指数、系数、符号 &#123; if(i==0&amp;&amp;p1x[i]=='-')//若第一个字符为'-'，则将ans(结构体)的第0个位置的符号记为'-' ans[i++].symbol='-'; if(i==0&amp;&amp;(p1x[i]&gt;='0'&amp;&amp;p1x[i]&lt;='9'))//若第一个字符是一个数组，则将ans(结构体)的第0个位置的符号记为'+'，实际上，这里也留了一个bug，如果第一个字符为'+'(不标准输入) ans[i].symbol='+'; if(p1x[i]=='x'&amp;&amp;p1x[i+1]!='^')//用于处理指数为1的情况 &#123; if(tmp==0) tmp=1; //ans[j].symbol=p1x[i-1]; if(ans[j].symbol=='-') &#123; ans[j].coefficient=0-tmp; ans[j++].index=1; &#125; else &#123; ans[j].coefficient=tmp; ans[j++].index=1; &#125; i++; tmp=0; continue; &#125; if(p1x[i]=='x')//指数不为1的情况 &#123; if(tmp==0) tmp=1; ans[j].coefficient=tmp; tmp=0; if(ans[j].symbol=='-') ans[j].coefficient=0-ans[j].coefficient; i++; flag=1;//标记，这个比较重要，标记这个单项式是标准单项式 continue; &#125; if(p1x[i]&gt;='0'&amp;&amp;p1x[i]&lt;='9')//用于提取系数或者指数，并存储在临时的变量tmp中 &#123; tmp=tmp*10+p1x[i]-48; &#125; if(flag==0&amp;&amp;(p1x[i+1]==0||p1x[i+1]=='+'||p1x[i+1]=='-')&amp;&amp;p1x[i]&gt;='0'&amp;&amp;p1x[i]&lt;='9')//当单项式不标准，也就是，单项式为一个纯数字的情况 &#123; ans[j].coefficient=tmp; ans[j].index=0; if(ans[j].symbol=='-') ans[j].coefficient=0-ans[j].coefficient; //ans[++j].symbol=p1x[i]; i++; tmp=0; continue; &#125; if(p1x[i]=='+'||p1x[i]=='-')//遇到一个±号的时候，这个时候这个单项式已经读取 完毕 &#123; if(p1x[i-1]=='x')//如果这个±前面是一个'x'，那么改单项式为指数为1的单项式。 &#123; ans[j].symbol=p1x[i]; i++; continue; &#125; else //如果是标准单项式，则存储该单项式的符号和指数 &#123; ans[j].index=tmp; ans[++j].symbol=p1x[i];//这个++j好好斟酌一下 &#125; flag=0;//将flag清零，表示这个单项式已经存储完毕 tmp=0;//用于存储系数或者指数的tmp清零 &#125; i++; &#125; j++; i=flag=tmp=0;//同样是清零，防止影响p2(x)的提取 while(p2x[i]) &#123; if(i==0&amp;&amp;p2x[i]=='-') &#123; ans[j].symbol='-'; i++; &#125; if(i==0&amp;&amp;(p2x[i]&gt;='0'&amp;&amp;p2x[i]&lt;='9')) &#123; ans[j].symbol='+'; &#125; if(p2x[i]=='x'&amp;&amp;p2x[i+1]!='^') &#123; if(tmp==0) tmp=1; //ans[j].symbol=p1x[i-1]; if(ans[j].symbol=='-') &#123; ans[j].coefficient=0-tmp; ans[j++].index=1; &#125; else &#123; ans[j].coefficient=tmp; ans[j++].index=1; &#125; i++; tmp=0; continue; &#125; if(p2x[i]=='x') &#123; if(tmp==0) tmp=1; ans[j].coefficient=tmp; tmp=0; if(ans[j].symbol=='-') ans[j].coefficient=0-ans[j].coefficient; i++; flag=1; continue; &#125; if(p2x[i]&gt;='0'&amp;&amp;p2x[i]&lt;='9') &#123; tmp=tmp*10+p2x[i]-48; &#125; if(flag==0&amp;&amp;(p2x[i+1]==0||p2x[i+1]=='+'||p2x[i+1]=='-')&amp;&amp;(p2x[i]&gt;='0'&amp;&amp;p2x[i]&lt;='9')) &#123; ans[j].coefficient=tmp; ans[j].index=0; if(ans[j].symbol=='-') ans[j].coefficient=0-ans[j].coefficient; //ans[++j].symbol=p2x[i]; i++; tmp=0; continue; &#125; if(p2x[i]=='+'||p2x[i]=='-') &#123; if(p2x[i-1]=='x') &#123; ans[j].symbol=p2x[i]; i++; continue; &#125; else &#123; ans[j].index=tmp; ans[++j].symbol=p2x[i]; &#125; flag=0; tmp=0; &#125; i++; &#125; //j++; flag=1; while(flag) //此时已经将p1(x)和p2(x)的系数、指数、符号都存储于ans中了，现在将他们按照指数的大小，从小到大排序，算法为冒泡。 &#123; flag=0; for(i=1;i&lt;=j;i++) &#123; if(ans[i].index&lt;ans[i-1].index) &#123; flag=ans[i].index;//嗯，这里把flag当作一个过渡变量来用了(其实我只是懒得多定义一个过渡变量) ans[i].index=ans[i-1].index; ans[i-1].index=flag; flag=ans[i].coefficient; ans[i].coefficient=ans[i-1].coefficient; ans[i-1].coefficient=flag; flag=ans[i].symbol; ans[i].symbol=ans[i-1].symbol; ans[i-1].symbol=flag; flag=1; &#125; &#125; &#125; //将同类项合并，并存储到ans2中 ans2[0].coefficient=ans[0].coefficient; ans2[0].index=ans[0].index; ans2[0].symbol=ans[0].symbol; for(i=1;i&lt;=j;i++) &#123; if(ans[i].index==ans2[k].index) &#123; ans2[k].coefficient+=ans[i].coefficient; &#125; else &#123; ans2[++k].coefficient=ans[i].coefficient; ans2[k].index=ans[i].index; ans2[k].symbol=ans[i].symbol; &#125; &#125; printf("p1(x) + p2(x) = ");//准备输出啦 for(i=0;i&lt;=k;i++) &#123; if(ans2[i].coefficient==0)//若系数为零，则直接进行下一个循环 continue; if(ans2[i].coefficient==1)//系数为1的情况 &#123; if(tmp)//系数是正数，且不是第一次输出的话，需要输出一个'+'号，因为正数输出，不带符号 &#123; if(ans2[i].index!=0)//若系数为1且指数不为0，则输出x^ans[i].index printf("+x^%d",ans2[i].index); else printf("+1");//若系数为1且指数为0，则输出1 &#125; else//系数是正数，且是第一次输出的话，标记一下tmp，表示已经输出过了，第一次输出如果为正数，是不需要输出'+'的 &#123; if(ans2[i].index!=0) printf("x^%d",ans2[i].index); else printf("1"); tmp=1; &#125; continue; &#125; if(ans2[i].coefficient&gt;0)//系数不为0、不为1，且大于0的时候 &#123; if(tmp)//系数是正数，且不是第一次输出的话，需要输出一个'+'号，因为正数输出，不带符号'+' &#123; if(ans2[i].index!=0) printf("+%dx^%d",ans2[i].coefficient,ans2[i].index); else printf("+%d",ans2[i].coefficient); &#125; else//系数是正数，且是第一次输出的话，标记一下tmp，表示已经输出过了，第一次输出如果为正数，是不需要输出'+'的 &#123; if(ans2[i].index!=0) printf("%dx^%d",ans2[i].coefficient,ans2[i].index); else printf("%d",ans2[i].coefficient); tmp=1; &#125; &#125; else//系数小于0的情况，直接输出就好了，因为负数自己带着'-'号 &#123; printf("%dx^%d",ans2[i].coefficient,ans2[i].index); tmp=1; &#125; &#125; printf("\n");&#125; 运行示例 解析从字符串中提取系数、指数、符号思路是这样的：对于正常的单项式[±][n]x^[a](a为整数，n为正整数),遇到字符“x”的时候，表示它前面的数字是系数，遇到字符“±”时，表示它前面的数字是指数。系数或者指数用这样的办法来提取123456i=tmp=0;while(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')&#123; tmp=tmp*10+str[i]-48;//减去48的原因是我们将多项式当作字符串读入，要将字符'0'或者'1'之类的转化成相对应的整数，得减去48之后赋值给一个int类型的变量。 i++;&#125; 这样，我们就拿到系数或者指数了当遇到一个x的时候，需要将拿到的系数tmp给保存起来，那就这样做1234567891011121314if(str[i]=='x')&#123; &#123; if(tmp==0)//若tmp为0，表示x前面是一个“±”号，也就是系数为1的情况，那么tmp是不会变成1的，所以这里判断之后，将tmp变成1 tmp=1; ans[j].coefficient=tmp;//将tmp存储 tmp=0; if(ans[j].symbol=='-')//若这个单项式的符号为“-”，那么就将存储好的系数变成负数 ans[j].coefficient=0-ans[j].coefficient; i++; flag=1;//标记，这个比较重要，标记这个单项式是有指数的单项式，也就是说，标记一下这个单项式不是纯数字 continue; &#125;&#125; 当遇到一个“±”号的时候，需要将拿到的指数tmp保存，这样做12345678910111213141516if(p1x[i]=='+'||p1x[i]=='-')//遇到一个±号的时候，这个时候这个单项式已经读取 完毕&#123; if(p1x[i-1]=='x')//如果这个±前面是一个'x'，那么该单项式为指数为1的单项式。 &#123; ans[j].symbol=p1x[i]; i++; continue; &#125; else //如果是标准单项式，则存储该单项式的符号和指数 &#123; ans[j].index=tmp; ans[++j].symbol=p1x[i];//将j加一个1，准备存储下一个系数、指数、符号 &#125; flag=0;//将flag清零，表示这个单项式已经存储完毕 tmp=0;//用于存储系数或者指数的tmp清零&#125; 对于指数为1的情况，特殊对待一下12345678910111213141516171819if(p1x[i]=='x'&amp;&amp;p1x[i+1]!='^')//用于处理指数为1的情况，也就是，遇到一个“x”，但是它后面不是“^”的情况&#123; if(tmp==0) tmp=1; //ans[j].symbol=p1x[i-1]; if(ans[j].symbol=='-') &#123; ans[j].coefficient=0-tmp; ans[j++].index=1; &#125; else &#123; ans[j].coefficient=tmp; ans[j++].index=1; &#125; i++; tmp=0; continue;&#125; 对于单项式为纯数字的情况123456789101112if(flag==0&amp;&amp;(p1x[i+1]==0||p1x[i+1]=='+'||p1x[i+1]=='-')&amp;&amp;p1x[i]&gt;='0'&amp;&amp;p1x[i]&lt;='9')//当单项式不标准，也就是，单项式为一个纯数字的情况//若flag为0，且当前字符是一个数字，且这个字符后面是“±”号或者字符串末尾，则这个单项式是纯数字&#123; ans[j].coefficient=tmp; ans[j].index=0; if(ans[j].symbol=='-') ans[j].coefficient=0-ans[j].coefficient; //ans[++j].symbol=p1x[i]; i++; tmp=0; continue;&#125; 合并同类项经过一番奋战，我们终于拿到了两个字符串的系数、指数、符号了，并且把他们都存储在了ans中，合并同类项之前，先把他们按照系数，从小到大排序12345678910111213141516171819202122flag=1;while(flag) //此时已经将p1(x)和p2(x)的系数、指数、符号都存储于ans中了，现在将他们按照指数的大小，从小到大排序，算法为冒泡。&#123; flag=0; for(i=1;i&lt;=j;i++) &#123; if(ans[i].index&lt;ans[i-1].index) &#123; flag=ans[i].index;//嗯，这里把flag当作一个过渡变量来用了(其实我只是懒得多定义一个过渡变量) ans[i].index=ans[i-1].index; ans[i-1].index=flag; flag=ans[i].coefficient; ans[i].coefficient=ans[i-1].coefficient; ans[i-1].coefficient=flag; flag=ans[i].symbol; ans[i].symbol=ans[i-1].symbol; ans[i-1].symbol=flag; flag=1; &#125; &#125;&#125; 然后合并同类项(我将合并后的多项式存储到ans2中)12345678910111213141516ans2[0].coefficient=ans[0].coefficient;ans2[0].index=ans[0].index;ans2[0].symbol=ans[0].symbol;for(i=1;i&lt;=j;i++)&#123; if(ans[i].index==ans2[k].index) &#123; ans2[k].coefficient+=ans[i].coefficient; &#125; else &#123; ans2[++k].coefficient=ans[i].coefficient; ans2[k].index=ans[i].index; ans2[k].symbol=ans[i].symbol; &#125;&#125; 输出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849printf("p1(x) + p2(x) = ");//准备输出啦for(i=0;i&lt;=k;i++)&#123; if(ans2[i].coefficient==0)//若系数为零，则直接进行下一个循环 continue; if(ans2[i].coefficient==1)//系数为1的情况 &#123; if(tmp)//系数是正数，且不是第一次输出的话，需要输出一个'+'号，因为正数输出，不带符号 &#123; if(ans2[i].index!=0)//若系数为1且指数不为0，则输出x^ans2[i].index printf("+x^%d",ans2[i].index); else printf("+1");//若系数为1且指数为0，则输出1 &#125; else//系数是正数，且是第一次输出的话，标记一下tmp，表示已经输出过了，第一次输出如果为正数，是不需要输出'+'的 &#123; if(ans2[i].index!=0) printf("x^%d",ans2[i].index); else printf("1"); tmp=1; &#125; continue; &#125; if(ans2[i].coefficient&gt;0)//系数不为0、不为1，且大于0的时候 &#123; if(tmp)//系数是正数，且不是第一次输出的话，需要输出一个'+'号，因为正数输出，不带符号'+' &#123; if(ans2[i].index!=0) printf("+%dx^%d",ans2[i].coefficient,ans2[i].index); else printf("+%d",ans2[i].coefficient); &#125; else//系数是正数，且是第一次输出的话，标记一下tmp，表示已经输出过了，第一次输出如果为正数，是不需要输出'+'的 &#123; if(ans2[i].index!=0) printf("%dx^%d",ans2[i].coefficient,ans2[i].index); else printf("%d",ans2[i].coefficient); tmp=1; &#125; &#125; else//系数小于0的情况，直接输出就好了，因为负数自己带着'-'号 &#123; printf("%dx^%d",ans2[i].coefficient,ans2[i].index); tmp=1; &#125;&#125; 生命重在折腾]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从组合数讲起]]></title>
    <url>%2F2016%2F12%2F09%2FDynamic-programming%2F</url>
    <content type="text"><![CDATA[概要在做NOIP提高组day2第一题时，这个题的目标就是计算出组合数，也即题目中的系数。 实战方法一使用组合数公式可以看到，里面是三个阶乘，按照这个思路，可以这样 123456789101112131415#include&lt;iostream&gt;using namespace std;int factor(int n)&#123; if (n==0|n==1) return n; return n*factor(n-1);&#125;int main ()&#123; int n,m,ans; scanf("%d%d",&amp;n,&amp;m); ans=factor(m)/(factor(n)*factor(m-n)); printf("%d",ans);&#125; 方法二使用组合书递推公式C（M-1，N-1）+C（M-1，N）=C（M，N）下面是代码实现123456789101112131415161718192021222324#include &lt;iostream&gt;int aa[1000][1000];using namespace std;int conbinatorics(int n,int m)&#123; if(aa[n][m]) return aa[n][m]; if(m==1) &#123; return aa[n][m]=n; &#125; if(n==m) &#123; return aa[n][m]=1; &#125; return aa[n][m]=conbinatorics(n-1,m-1)+conbinatorics(n-1,m);&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; cout &lt;&lt;conbinatorics(n,m)&lt;&lt; endl; return 0;&#125; 这里使用了动态规划————记录结果再利用，本可以节省很多时间，但是在这个代码示范中体现得不明显。请看下面。 斐波那契数列F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)代码实现：12345678910111213141516#include&lt;iostream&gt;using namespace std;int F(int n)&#123; if(n==1||n==2) return 1; else return F(n-1)+F(n-2);&#125;int main ()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;F(n)&lt;&lt;endl; return 0;&#125; 示例，当n= 40时，用时0.654s， 用动态规划，代码实现如下： 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int array[1000];int F(int n)&#123; if(array[n]) return array[n]; else &#123; array[n]=F(n-1)+F(n-2); return array[n]; &#125;&#125;int main ()&#123; int n=40; array[2]=array[1]=1; cout&lt;&lt;F(n)&lt;&lt;endl; return 0;&#125; 时间大幅度减少，虽然仍然不到一秒钟，但是用时相差约46倍，已经是巨大的差别了。 原因如下：1234F(40)=F(39)+F(38);F(39)=F(38)+F(37);F(38)=F(37)+F(36);······ 仔细一看，虽然算法没错，但是F(39)和F(38)被计算了两次，如果继续往下的话，会发现有许多数倍计算了很多次，那么在第一次用到这个数的时候，就把它所对应的结果记录在array中，需要用的时候直接用就好了，节省很多运行时间。 总结动态规划————记录结果再利用生命在于折腾]]></content>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016更改]]></title>
    <url>%2F2016%2F12%2F05%2FNOIP2016%E6%9B%B4%E6%94%B9%2F</url>
    <content type="text"><![CDATA[12.07更新，全部测试数据通过。 在NOI官网拿到了NOIP2016的测试数据，顺便下载下来测试了一下之前写的代码。在实际测试中遇到第十二组数据出错的情况，这个是我更改后的代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main ()&#123; int n,m,i=0,ans=0,command_1,command_2,flag,x=0; scanf("%d%d",&amp;n,&amp;m); int pan[n]; char job[n][15]; while(i&lt;n) &#123; scanf("%d%s",&amp;pan[i],job[i]); i++; &#125; i=0; while(i&lt;m) &#123; scanf("%d%d",&amp;command_1,&amp;command_2); flag=1; if(pan[x]==command_1) &#123; flag=-1; ans+=command_2*(-1); &#125; else ans+=command_2; x=(x+command_2*flag)%n; if(x&lt;0) x=n+x; i++; &#125; ans=ans%n; if(ans&lt;0) ans=n+ans; printf("%s",job[ans]);&#125; 下面是原本的代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main ()&#123; int n,m,i=0,ans=0,command_1,command_2,flag,x=0; scanf("%d%d",&amp;n,&amp;m); int pan[n]; char job[n][10]; while(i&lt;n) &#123; scanf("%d%s",&amp;pan[i],job[i]); i++; &#125; i=0; while(i&lt;m) &#123; scanf("%d%d",&amp;command_1,&amp;command_2); flag=1; if(pan[x]==command_1) &#123; flag=-1; ans+=command_2*(-1); &#125; else ans+=command_2; x=(x+command_2*flag)%n; if(x&lt;0) x=n+x; i++; &#125; ans=ans%n; if(ans&lt;0) ans=n+ans; printf("%s",job[ans]);&#125; 把第九行job[n][10]变成了job[n][15]，解决第十二组数据的出错的问题，第十七组数据目前还未解决(有可能是数据本身是错的)。 第十二组的问题在于原本的字符数据太短，不足以储存“job”。 这次是为了说明为什么数组短了之后为什么出错。 按照数组的定义，数组实际上是一串连续的变量； 若有这样一个数组char str[4][5]; 当使用printf(“%s”,str[0]);输出二维数组，若数组内容如下 0 1 2 3 4 str[0] B D Z N \0 str[1] X I D I \0 str[2] A B C D \0 str[3] H C X . \0 输出内容自然是“BDZN”，若是二维数组内容如下 0 1 2 3 4 str[0] B D Z N H str[1] X I D I A str[2] A B C D E str[3] H C X . \0 输出内容将会是”BDZNHXIDIAABCDEHCX.”，这个与格式化输出控制符”%s”有关系，函数判断一个字符数组的结尾是以“\0”来判断的，它会输出到第一个“\0”前面的那个字符，所以二维数组如果某行被占满，使用“%s”来输出这行内容时，会连带下一行也输出。解决办法是将数组长度增加，防止该行被非”\0”的字符占满。C++的cout与这个类似。 磨磨蹭蹭，12.7更新，调整了一下，发现第十七组的数据错误所在，直接贴出代码: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main ()&#123; freopen("toy.in","r",stdin); freopen("toy.out","w",stdout); int n,m,i=0,ans=0,command_1,command_2; scanf("%d%d",&amp;n,&amp;m); int pan[n]; char job[n][15]; while(i&lt;n) &#123; scanf("%d%s",&amp;pan[i],job[i]); i++; &#125; i=0; while(i&lt;m) &#123; scanf("%d%d",&amp;command_1,&amp;command_2); command_2=command_2%n; if(pan[ans]==command_1) //顺时针走 &#123; ans-=command_2; if(ans&lt;=0) ans+=n; &#125; else //逆时针针走 &#123; ans+=command_2; if(ans&gt;=n) ans-=n; &#125; i++; &#125; printf("%s",job[ans]);&#125; 问题其实还是比较明显的，原本的代码:12345678910111213141516while(i&lt;m)&#123; scanf("%d%d",&amp;command_1,&amp;command_2); flag=1; if(pan[x]==command_1) //顺时针 &#123; flag=-1; ans+=command_2*(-1); &#125; else //逆时针 ans+=command_2; x=(x+command_2*flag)%n; if(x&lt;0) x=n+x; i++;&#125; 更改后的代码123456789101112131415161718while(i&lt;m)&#123; scanf("%d%d",&amp;command_1,&amp;command_2); command_2=command_2%n; if(pan[ans]==command_1) //顺时针走 &#123; ans-=command_2; if(ans&lt;=0) ans+=n; &#125; else //逆时针针走 &#123; ans+=command_2; if(ans&gt;=n) ans-=n; &#125; i++;&#125; 问题在于没有考虑越界问题。 生命在于折腾]]></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016]]></title>
    <url>%2F2016%2F11%2F26%2FNOIP2016%2F</url>
    <content type="text"><![CDATA[11月19和20号，NOIP2016竞赛复赛结束，抽空做了一下。 题意小南有一套可爱的玩具小人，它们有不同的职业。有一天，这些小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。如下图：这时singer 告诉小南一个谜题：“眼镜藏在我左数第 3 个玩具小人的右数第 1 个玩具小人的左数第 2 个玩具小人那里。 ”小南发现，这个谜题中玩具小人的朝向非常关键，因为朝内和朝外的玩具小人的 左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。小南一边艰难地辨认着玩具小人，一边数着：“singer 朝内，左数第 3 个是archer。”“archer 朝外，右数第 1 个是thinker。”“thinker 朝外，左数第 2 个是writer。”“所以眼镜藏在writer这里！”虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为：有 n 个玩具小人围成一圈，己知它们的职业和朝向。 现在第 1 个玩具小人告诉小 南一个包含 m 条指令的谜题，其中第 i 条指令形如“左数/右数第 $s_i$ 个玩具小人”。 你需 要输出依次数完这些指令后，到达的玩具小人的职业。 【输入格式说明】从文件 toy.in 中读入数据。 输入的第一行包含两个正整数 n, m ，表示玩具小人的个数和指令的条数。 接下来 n 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小 人的朝向和职业。其中 0 表示朝向圈内， 1 表示朝向圈外。保证不会出现其他的数。字 符串长度不超过 10 且仅由小写字母构成，字符串不为空，并且字符串两两不同。 整数 和字符串之间用一个空格隔开。 接下来 m 行，其中第 i 行包含两个整数 $a_i$, $s_i$ ，表示第 i 条指令。若 $a_i$ = 0 ，表示向 左数 $s_i$ 个人；若 $a_i$ = 1 ，表示向右数 $s_i$ 个人。保证 $a_i$ 不会出现其他的数， 1 ≤ $s_i$ &lt; n 。 【输出格式说明】输出到文件 toy.out 中。 输出一个字符串，表示从第一个读入的小人开始，依次数 完 m 条指令后到达的小人的职业。 样例数据样例数据1123456789101112131415输入数据：7 3 0 singer 0 reader 0 mengbier 1 thinker 1 archer 0 writer 1 mogician 0 3 1 1 0 2输出数据:writer 样例数据212345678910111213141516171819202122232425输入数据：10 10 1 c 0 r 0 p 1 d 1 e 1 m 1 t 1 y 1 u 0 v 1 7 1 1 1 4 0 5 0 3 0 1 1 6 1 2 0 8 0 4输出数据：y 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;struct Toy&#123; int pan; char job[10];&#125;;struct Command&#123; int pan; int cursor;&#125;;int main()&#123; int n,m,i=0,x=0,ans=0,flag; char tmp; cin&gt;&gt;n&gt;&gt;m; struct Toy toy[n]; struct Command command[m]; while(i&lt;n) &#123; scanf("%d%c%s",&amp;toy[i].pan,&amp;tmp,toy[i].job); i++; &#125; i=0; while(i&lt;m) &#123; cin&gt;&gt;command[i].pan&gt;&gt;command[i].cursor; i++; &#125; i=0; while(i&lt;m) &#123; flag=1; if(toy[x].pan==command[i].pan) &#123; flag=-1; ans=ans+command[i].cursor*(-1); &#125; else ans=ans+command[i].cursor; x=x+command[i].cursor*flag; x=x%n; if(x&lt;0) x=n+x; i++; &#125; ans=ans%n; if(ans&lt;0) ans=n+ans; cout&lt;&lt;toy[ans].job&lt;&lt;endl; return 0;&#125; 为了看起来复杂，我用了乱七八糟的东西(虽然实际上没什么大用)所以又准备了下面的代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main ()&#123; int n,m,i=0,ans=0,command_1,command_2,flag,x=0; scanf("%d%d",&amp;n,&amp;m); int pan[n]; char job[n][10]; while(i&lt;n) &#123; scanf("%d%s",&amp;pan[i],job[i]); i++; &#125; i=0; while(i&lt;m) &#123; scanf("%d%d",&amp;command_1,&amp;command_2); flag=1; if(pan[x]==command_1) &#123; flag=-1; ans+=command_2*(-1); &#125; else ans+=command_2; x=(x+command_2*flag)%n; if(x&lt;0) x=n+x; i++; &#125; ans=ans%n; if(ans&lt;0) ans=n+ans; printf("%s",job[ans]);&#125; 算法这个嘛，暴力，顺着题目意思走一遍，不过不知道最后官方的测试数据拿来会不会超时。 生命在于折腾]]></content>
      <tags>
        <tag>C++</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高速传输文件的办法]]></title>
    <url>%2F2016%2F11%2F25%2FHigh-Speed-transfer%2F</url>
    <content type="text"><![CDATA[一点点小说明有时候，需要在电脑与电脑之间传输一些文件，用U盘有时候不太方便，或者遇到U盘读不出来的奇葩情况，真是一出接一出，于是想办法。同一个局域网下的电脑对传的话，一般网速能达到上限，速度不错，按100M的路由器来看，速度一般能在10MB/s左右。 局域网传输————Dukto网上找到一个不错的软件————DuktoR6，这货速度虽然不快，我这儿测试速度3MB/s左右，不过它可用于大部分平台，windows，linux，Android，ios，windows phone，windows 10 mobile/pc，涵盖了日常能用到的大部分平台，连windows phone和windows 10 mobile都有，不得不说是一个良心软件。 使用方法是：两个终端(电脑或者手机)在同一个局域网下，打开DuktoR6，正常情况下软件会自动找到其它客户端，如上图，如果找不到的话，便点击 “IP connection” ，输入接受端的IP地址，若不知道接收端的IP地址的话，在接收端点击最下面三个图标的中间那个图标，就知道了，若是接收端同时具有多个IP地址，就得找到与发送端同一个网段得IP地址才行，用同样的办法查看发送端的IP地址，看IP地址的前三部分的相似度，在大多数情况下，普通路由器分配给终端的IP地址都形如“192.168.1.X或者192.168.0.X。 找到接收端之后，选择要发送的文件或文件夹便可以发送了。 更加高速的办法本方法适用于拷贝体积较大的文件，几G甚至几十G的文件拷贝用这种办法，时间会大大缩短。 现在的电脑大都配备了千兆网卡，理论传输速度是能超过100MB/s的，不过受限于运营商带宽或者路由器，一般网速只有几MB/s，如学校所用的翼讯，带宽为6M，最高下载持续下载速度也不到1MB/s，网卡性能浪费太多了。 两台电脑对传文件，若使用网线直接将两台电脑连接，这样带宽理论上是能达到网卡上限的。 原理说明在上面所说的DuktoR6传输办法中，需要发送端和接收端都安装软件，有时候，这个反而不方便(比如两人都没有携带可以传输的设备，U盘什么的，别说手机了，有些手机不装驱动是没办法北电脑识别的)。 这里我使用的是最常见的直接通过链接下载的方法，也就是说通过TCP/IP协议，说得简单一点，就是拿浏览器直接下载了。 详细说明安装nginx 如上面所说，想要通过浏览器直接下载对方电脑上的文件，得对方的电脑开启了web服务器，这个东西不难找，我使用的是nginx,点我下载上面的下载链接是针对windows系统的，基于debian的系统使用下面的命令安装nginx sudo apt-get install nginx 基于redhat的系统使用下面的命令安装nginx sudo yum install nginx 下面以windows下的nginx使用方法为例 开启web服务器使用命令提示符(在开始按钮上点击鼠标右键，选择命令提示符即可)，然后切换到nginx所在的文件夹，我写本文时nginx版本为1.11.6，解压下载的压缩包，所得目录结构如下 │ nginx.exe │ ├─conf │ fastcgi.conf │ fastcgi_params │ koi-utf │ koi-win │ mime.types │ nginx.conf │ scgi_params │ uwsgi_params │ win-utf │ ├─contrib │ │ geo2nginx.pl │ │ README │ │ │ ├─unicode2nginx │ │ koi-utf │ │ unicode-to-nginx.pl │ │ win-utf │ │ │ └─vim │ ├─ftdetect │ │ nginx.vim │ │ │ ├─indent │ │ nginx.vim │ │ │ └─syntax │ nginx.vim │ ├─docs │ CHANGES │ CHANGES.ru │ LICENSE │ OpenSSL.LICENSE │ PCRE.LICENCE │ README │ zlib.LICENSE │ ├─html │ 50x.html │ index.html │ ├─logs └─temp 输入命令 start nginx 看到一个黑框一闪而过，这个时候nginx已经启动了，在浏览器地址栏输入localhost，即可看到这样的画面我们同样可以在任务管理器查看进程 搭建静态文件服务器这一步做完，我们就已经成功一大半了，搭建静态文件服务器的办法是更改conf文件夹下的nginx.conf文件。不管用什么办法(我使用了记事本)，编辑nginx.conf文件，将内容更改如下1234567891011121314151617181920212223242526272829303132#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; charset gbk; server_name localhost; client_max_body_size 4G; root Directory_add; location / &#123; autoindex on; autoindex_exact_size off; autoindex_localtime on; &#125; &#125;&#125; 自行更改Directory_ add为被传输文件的目录，比如我再D盘的download文件夹下的文件是我想要传输被对方的，Directory_add就改成D:\Download此时配置文件已经修改完成，使用命令 1nginx -s reload 重载配置，使其生效，比如这里我改成F:\Minecraft，重载配置文件后，浏览器打开localhost，界面是这样的： 这个时候，只要别人能打开这台电脑的IP，就可以直接点击相应的文件下载了。 开始传输前面已经说过，原理便是搭建一个web静态文件服务器，这个时候，只要别人能连接打开服务器的电脑，便可以下载配置好的目录里面的文件了。 怎么连接呢？ 第一种办法是仍然连接同一个局域网 第二种办法便是直接用网线连接两台电脑，没错，一根网线，两头都是电脑。不过普通网线没办法使得两台电脑处于同一台局域网，要么使用交叉网线(这种网线一般用不到，所以不好找)，要么参考这个办法的方法2的第四和第五个步骤 其实，绕来绕去，就是要让两台电脑能处于同一个网段下面，不管是连接同一个路由器还是用网线直连，目的都是这个。 PS的一些东西在配置文件中，有这样一行 charset gbk; 因为我是在windows内进行的演示，不用gbk的话，遇到中文名的文件会乱码，如果是linux系统的话，需要删除这一行或者把gbk改成utf-8。 并且，nginx不能放在含中文的目录下面，Dectory_add也不能是含有中文或者空格的目录。]]></content>
      <tags>
        <tag>小窍门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Aria2c和百度网盘助手实现高速下载百度网盘资料]]></title>
    <url>%2F2016%2F10%2F20%2FAria2c%2F</url>
    <content type="text"><![CDATA[一点介绍先介绍一枚小神器————Aria2c，这是一个下载软件，支持Windows，Linux，mac os(原OS X)，不过是纯命令行操作的软件。本文附带一个让它支持图形界面的办法(其实都是从网上扣来的)，不过每次讲的都不全，不完整，本文算是一个总结。此方法共需要以下东西： BaiduExporter(一个chrome插件，用于提取出百度云的文件真正的下载地址) aria2c(下载软件)： 项目主页：https://github.com/aria2/aria2 官方文档：https://aria2.github.io/ 历史版本：https://github.com/aria2/aria2/releases/tag/release-1.28.0 aria2c-webui(非必需) 第一步自然是下载带这三个软件了，地址都在上面，可以自行下载。 Chrome浏览器导入插件打开chrome，在地址栏输入“chrome://extensions/”,勾选开发者模式，然后点击加载已解压的扩展程序(也可以将下载到的crx文件直接拖入当前chrome窗口)。选中解压的到的chrome文件夹，点击确定。 安装Aria2c下载，解压，双击“start.bat”,出现下面这个窗口就好了。 使用这个时候，使用chrome浏览器打开任意百度网盘链接点击ARIA2 RPC可以看到下载成功的提示这个时候可以在黑框里面看到下载进度。 使用webui查看下载进度不过大部分人对字符界面不敏感，所以这里准备了一个图形界面来查看下载进度,打开www.hushuangpu.xyz/aria2c-webui如果出现这个界面的话:依次点击”设置&gt;&gt;连接”，改成下图中的信息 保存连接设置即可，就能在网页查看到下载信息了 其它可能会出现的问题说明在最新版的Chrome浏览器上，对非chrome商店的插件做了比较严格的限制，每次打开Chrome浏览器百度网盘助手都会被禁用，可以通过修改组策略来解决这个问题。跳转到：Guide on Packaging and Import Baidu Exporter to Chrome也可以查看bilibili 默认会下载到D:\Downloads 软件下载地址所使用到的软件在此下载：High_Speed_download_baiduyun.rar]]></content>
      <tags>
        <tag>-technology</tag>
        <tag>wanwan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft Server]]></title>
    <url>%2F2016%2F07%2F03%2FMinecraft-server%2F</url>
    <content type="text"><![CDATA[Minecraft由java编写，运行我的世界服务器(客户端)需要在计算机安装java运行环境，然后再计算机上运行服务端，在客户端填写运行服务端的计算机的ip地址就行(如果全部是默认设置的话)PS：本文所涉及的命令操作，在windows中为命令提示符下输入，在Linux中为终端或者控制台输入。下面不再特别说明。 第一步：在计算机上安装java运行环境。计算机系统如果为windows，前往java官网下载“jre”运行环境，双击，默认安装在C盘，可以根据需要更改。没有特殊需要的话，一直点击下一步直到安装完成就行。计算机系统如果为cent OS/red hat，可以输入如下命令1yum -y list | grep *java* 来查看有哪些java包可用，安装需要的包即可。计算机系统如果为debian/ubuntu或基于它们的衍生版，输入如下命令1sudo apt-get install default-jre* 即可安装java。 第二步：运行Minecraft服务端Minecraft服务端分为官方服务端和第三方服务端，官方服务端可以在MC官网下载到。这里提供1.10版本下载地址(经过测试，把下面链接中的1.10改成其他相应版本就能下载相应版本的服务端，把1.10改成1.9.4就能下载到1.9.4的服务端) 1https://s3.amazonaws.com/Minecraft.Download/versions/1.10/minecraft_server.1.10.jar 也可以前往https://minecraft.net/zh-hans/download/server获取最新版本的官方服务端。第三方服务端这里提供一个网址——www.mcadmin.net，这个网址提供“水龙头”和“水桶”服务端下载。一般客户端只能进入同版本的服务端，跨版本的服务端为第三方制作，可以前往www.mcbbs.net了解更多信息。服务端为一个“.jar”文件，windows下使用命令行/linux下使用终端或者控制台，切换到服务端文件所在目录，输入命令1java -jar *.jar (这里*.jar是指你下载到的服务端的文件的文件名)这里还可以使用参数控制服务器所使用的内存，比如1java -Xmx768M -Xms512M -jar minecraft_server.1.10.jar “-Xmx768M”是限制服务器所使用的最大内存，”-Xms512M”是限制服务器所使用的最小内存。当出现如如下图的画面时，代表服务端开启成功(这里演示所使用的服务端为官服，版本1.10) 第三步： 联机3.1如果玩家在同一个局域网 (比如电脑连接了同一台路由器后者交换机，找到开启服务端的电脑的IP地址，在多人游戏中输入服务端的电脑的IP地址即可连接)Windows可以用ipconfig，linux卡可以使用ifconfig查找自己的IP地址。 3.2如果玩家相隔很远，这个时候就需要公网IP了。获取公网IP的办法有很多： 租用服务器，阿里云和腾讯云都有针对学生认证的优惠，阿里云认证之后为10元每月，腾讯云认证后为1元每月； 内网穿透腾讯云和阿里云去官网登录按照提示来就行，这里不再赘述。内网穿透估计大多数人都搞不定，这里指一个方向——花生壳， 到花生壳的官网查找，用内网穿透拿到公网IP，这样朋友就能和自己连接上了。 开服神器推荐——McMyAdmin由于普通开服后，管理服务器时涉及很多命令操作，许多纯白的小白还是搞不定，这里推荐一个操作简单的开服软件——McMyAdmin PS：在运行linux的计算机上运行这个软件需要安装mono，由于在windows上运行这个McMyAdmin网上已经有很多教程了，这里不再累述。我在安装mono时遇到不少麻烦，首先是cent OS自带源里面不包含mono，必须手动安装，然后百度，找了各种博客，按照叙述一步一步来，还是失败，最后在mono的wiki找到解决办法，如下 CentOS 7, Fedora 19 (and later), and derivatives(需要root权限)12345yum install yum-utilsrpm --import "http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF"yum-config-manager --add-repo http://download.mono-project.com/repo/centos/yum updateyum install mono-devel Debian, Ubuntu, and derivatives(root)1234sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EFecho "deb http://download.mono-project.com/repo/debian wheezy main" | sudo tee /etc/apt/sources.list.d/mono-xamarin.listsudo apt-get updatesudo apt-get install mono-devel 然后输入命令”mono -v”出现如下信息则表示mono安装成功 关于服务器的选择服务器系统，最好选择红帽或者Cent OS，红帽背后是企业级支持，虽然个人用不上，但是，可以用它的衍生版Cent OS，至于为什么不选择Ubuntu之类的，我在腾讯云的1core &amp; 1G RAM的VPS上，Ubuntu的表现远远不如Cent OS。]]></content>
      <tags>
        <tag>Minecraft</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本站建立]]></title>
    <url>%2F2016%2F04%2F26%2Fstart%2F</url>
    <content type="text"><![CDATA[建站分享遵循大家都默认的一个规则——建立好站点之后，分享自己建立站点的过程。 租用服务器首先我在租用了搬瓦工的VPS，VPS运行cent os 6.系统环境对于个人站点来说不是非常重要，ubuntu，debian，甚至red hat都可以，看个人习惯。 安装nginxnginx就是一个软件，它监听着计算机的80端口，当检测到有浏览器访问当前计算机的IP地址的时候（浏览器访问一台计算机默认访问80端口），nginx就会返回用户之前写好的网页给浏览器，完成了一个网站的访问过程。在linux下安装nginx还是非常简单的。debian/ubuntu通过以下命令来安装nginx：1$ sudo apt-get install nginx cent os/red hat 通过以下命令1$ sudo yum install nginx 首次安装还nginx之后它默认启动了，但是计算机重启之后，nginx不会随系统启动，可以手动启动nginx1$ sudo service nginx start 或者让nginx随系统启动1$ cat sudo service nginx start &gt;&gt; /etc/profile 注意“&gt;&gt;”是两个，如果提示权限不足，就切换到root用户，使用：1$ su root 输入root用户密码 安装hexonginx给浏览器返回网页，这个网页就得自己来弄了，nginx可不会帮你，但是不会写网页代码怎么办？用来生成网页的工具很多，这里我使用了hexo，这个是一个台湾的大学生开发的用来生成静态网页的软件，真的佩服人家。hexo依赖于node.js，首先在电脑上安装node.js，linux端可以这样1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 或者1$ wget -q0- https://raw.github.com/creationix/master/install.sh | sh 然后重启终端，输入：123$ nvm install 4$ npm install -g hexo-cli$ npm install hexo-deployer-rsync --save 完成node.js 和部署插件rsync的安装windows端可以到node.js的官网下载msi包安装后，在cmd输入：12$ npm install -g hexo-cli$ npm install hexo-deployer-rsync --save 现在可以输入：1$ hexo init blog 来新建一个名为blog的文件夹，这个文件夹的名字自己取，进入这个文件夹，输入1$ hexo s --debug 看到1215:14:02.409 INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.15:14:02.432 DEBUG Database saved 的字样后，打开浏览器，访问localhost:4000,看看能否打开一个hexo的网页,能打开的话，证明hexo已经能在电脑上运行了。然后编辑blog文件夹下的”config.yml“文件,在大约73行，”theme”后面的就是hexo生成静态网页的时候所使用的主题，本站所使用的主题是next,主题存在于blog文件夹下的them文件夹内。在约80行左右，会有”deploy:”字样，这里填写的是部署网站的时候所用的一些组件需要的参数，如果按照本博客所说来安装hexo的话，可以参照以下填写方法：123456789deploy: type: rsync host: 0.0.0.0 //这里填写服务器的IP地址 user: root //这里填写部署网站是登陆服务器所用的用户 root: /usr/share/nginx/html/ //这里是nginx默认的服务器站点目录，文末细说 port: 26487 //这里是登陆服务器所用的端口，也就是ssh所用的端口 delete: false //下面三个可以参照我的填法，也可以自己更改 verbose: true ignore_errors: false 在本地生成网页静态文件并部署到网站切换到blog文件夹内(windows可以使用cmd，linux使用终端)，输入命令1$ hexo new "blog" 然后在source的posts文件夹下面就会生成一个blog.md的文件，使用任何一个文本编辑器编辑这个文件，把想要写在博客上的东西直接编辑到这个文件内，就可以了。然后切换到blog文件夹，输入：1$ hexo g 就可以生成网页静态文件了，生成的网页静态文件在public文件夹内，然后使用：1$ hexo d 就可以将网页文件部署到服务器，打开浏览器，就能看到做好的网站了。 一些小总结先说一下nginx，nginx会向浏览器返回网站的网页文件，这些网页文件默认在“/usr/share/nginx/www/”下面，有时候不一定在“www”下，可能是“html”文件夹，我自己的服务器就是“html”。部署便是讲已经做好的网页文件上传到服务器的这个文件夹下，浏览器便能正常访问到做好的网页。 然后说一下config.yml文件的”root:”,冒号后面是nginx的工作目录，nginx安装后默认一般都是”/usr/share/nginx/XXX/“下面，hexo部署的时候，便会将网页部署岛这个文件夹下面。 PS：我尝试在windows部署网站，但是遇到一些问题，第一次是环境错误，各种百度之后，可以成功部署，但部署之后无法访问，提示“403 forbidden”，便要手动将“/usr/share/nginx/XXX/”目录下面的所有文件夹(包括子文件夹)的属性改为775，文件属性改成664，才可以访问。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>hexo</tag>
        <tag>Technology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lake Counting]]></title>
    <url>%2F2016%2F04%2F03%2FLake-Counting%2F</url>
    <content type="text"><![CDATA[Lake Couting今天看到一个挺有意思的题目，拿出来分享一下。 题目所体现的算法思想为“深度优先搜索”(实在想知道这是神马的，百度一下) 这里给出简单的解释：深度优先搜索从最开始的状态出发，遍历所有可以达到的状态。由此可以对所有的状态进行操作，或者列举出所有的状态。 题目：有一个大小为N x M 的园子，雨后积满了水。八联通的积水被认为是连接在一起的。请求出这个园子里总共有多少水洼？(八联通指的是下图中相对 w 的 * 的部分)123***www*** 数据限制：N&lt;100,m&lt;100 输入数据:123456789101110 12w........ww..www.....www....ww...ww..........ww..........w....w......w...w.w.....ww.w.w.w.....w..w.w.....w....w......ww. 答案： 3 源代码下面是代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;//C++特有的命名空间，换为C的话，要去掉这行，并且改变头文件int n,m;//定义全局变量，n为行数，m为列数；char field[101][101];void dfs(int x,int y)&#123; field[x][y]='.';//将当前位置替换为“.” //循环遍历当前位置周围的八个方向 for (int dx = -1; dx &lt; 1; dx++) &#123; for (int dy = -1; dy &lt;= 1; dy ++) &#123; int nx=x+dx,ny=y+dy;//向x方向移动dx，向y方向移动dy。 //判断(nx，ny)是不是在园子范围内，并判断是否有积水 if(0&lt;=nx&amp;&amp;nx&gt;n&amp;&amp;0&lt;=ny&amp;&amp;ny&lt;m&amp;&amp;field[nx][ny]=='w') &#123; dfs(nx,ny);//这儿是递归用法，仔细想想 &#125; &#125; &#125; return ;//这行是可以省略的，因为当前所在函数是void型。&#125;void solve()&#123; int res=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if (field[i][j]=='w') &#123; dfs(i,j);//从有水(w)的地方开始搜索 res++; &#125; &#125; &#125; printf("%d\n",res);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int i=0,j=0; for( ; i&lt;n ; i++ ) &#123; for( ; j&lt;m ; j++ ) &#123; scanf("%c",&amp;field[i][j]); &#125; &#125; solve(); return 0;&#125; 其实，在windows系统下主函数中的1234567for( ; i&lt;n ; i++ )&#123; for( ; j&lt;m ; j++ ) &#123; scanf("%c",&amp;field[i][j]); &#125;&#125; 也可以改写成1234for( ;i&lt;n ;i++)&#123; gets(field[i]);&#125; 或者1234for( ; i&lt;n ; i++)&#123; scanf("%s",field[i]);&#125; 来减少一些输入，但是要注意gets函数在linux系统下是不允许使用的(有风险)。“深度优先搜索”的信息，这种概念行性的东西,诸位还是百度吧，我说不清楚。]]></content>
      <tags>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 自定义触控板手势]]></title>
    <url>%2F2016%2F03%2F28%2Fubuntu-touchpad%2F</url>
    <content type="text"><![CDATA[描述：ubuntu的触控板手势不多，最高只支持两点触控，白白浪费了触控板这四点触控。偶然在知乎上看到有人用一个软件xSwipe 成功实现多点触控，实测可以自行调节所需手势，我在安装过程中遇到一些麻烦，这里记录下来，作为备用。 xSwipe在开源项目网站GitHub上可以找到，传送门,或访问 https://github.com/iberianpig/xSwipe PS:由于服务器在国外，国内访问可能很慢，我将所需文件备份了一份，下载地址放在文章末尾了。 官网上的说明文档是英文版，虽然推荐读者阅读原版文档，但是为了照顾英语不好的同志，我找了一篇中文博客(点我访问),安装过程这篇博客已经说得很清楚了，这里不再叙述。 下面贴出官方的说明文档： xSwipexSwipe is multitouch gesture recognizer. This script make your linux PC able to recognize swipes like a Macbook. UsageBefore running the script, you must first do some preparations. 1: Download xSwipe2:Install X11::GUITest3:Enable SHMConfig 1. Download xSwipeType below code, download xSwipe from github $ cd ~ $ wget https://github.com/iberianpig/xSwipe/archive/master.zip $ unzip master.zip 2. Install X11::GUITestTo install libx11-guitest-perl from synaptic package manager Or run the script on the terminal run as $ sudo apt-get install libx11-guitest-perl NOTE: If using Ubuntu14.04, or later Install older version synaptics driver that is compatible with xSwipe. $ sudo apt-get install -y git build-essential libevdev-dev autoconf automake libmtdev-dev xorg-dev xutils-dev libtool $ sudo apt-get remove -y xserver-xorg-input-synaptics $ git clone https://github.com/Chosko/xserver-xorg-input-synaptics.git $ cd xserver-xorg-input-synaptics $ ./autogen.sh $ ./configure --exec_prefix=/usr $ make $ sudo make install 3. Enable SHMConfigOpen /etc/X11/xorg.conf.d/50-synaptics.conf with your favorite text editor and edit it to enable SHMConfig $ sudo gedit /etc/X11/xorg.conf.d/50-synaptics.conf NOTE:You will need to create the /etc/X11/xorg.conf.d/ directory and create 50-synaptics.conf if it does’nt exist yet. $ sudo mkdir /etc/X11/xorg.conf.d/ /etc/X11/xorg.conf.d/50-synaptics.confSection “InputClass”Identifier “evdev touchpad catchall”Driver “synaptics”MatchDevicePath “/dev/input/event*”MatchIsTouchpad “on”Option “Protocol” “event”Option “SHMConfig” “on”EndSectionTo reflect SHMConfig, restart your session. That’s it for preparation. Run xSwipeTo run xSwipe, type below code on terminal. $ perl ~/xSwipe-master/xSwipe.pl Note:You should run xSwipe.pl in same directory as "eventKey.cfg" . You can use “swipe” with 3 or 4 fingers, they can call an event. Additionally, some gestures are avilable. edge-swipe : swipe with 2 fingers from outside edge(need to enable with option).long-press : hold pressure for 0.5 seconds with 3 or 4 fingers. Option-d RATE : RATE is sensitivity to swipe.Default value is 1. Shorten swipe-length by half (e.g.,$ perl xSwipe.pl -d 0.5)-m INTERVAL : INTERVAL is how often synclient monitor changes to the touchpad state. Default value is 10(ms). Set 50ms as monitoring-span. (e.g.,$ perl xSwipe.pl -m 50)-n : Natural scroll like Macbook, use “/nScroll/eventKey.cfg”.-e : Enable edge-swipe CustomizeYou can customize the settings for gestues to edit eventKey.cfg. Please check this article, “How to customize gesture”. Bindable gestures3/4/5 fingers swipe2/3/4/5 fingers long-press2/3/4 fingers edge-swipe2fingers edge-swipe: only swipe-left/right from right/left edge3fingers edge-swipe: only swipe-down from top egde Example shortcut keysgo back/forward on browser (Alt+Left, Alt+Right)open/close a tab on browser (Ctrl+t/Ctrl+w)move tabs (Ctrl+Tab, Ctrl+Shift+Tab)move workspaces (Alt+Ctrl+Lert, Alt+Ctrl+Right, Alt+Ctrl+Up, Alt+Ctrl+Down)move a window (Alt+F7)open launcher (Alt+F8)open a terminal (Ctrl+Alt+t)close a window (Alt+F4)Please let me know if you have any questions about this program. 我按照说明文档安装好所需软件之后，进行到最后一步 $ perl ~/xSwipe-master/xSwipe.pl 遇到错误提示：“Can’t locate Smart/Comments.pm in @INC (you may need to install the Smart::Comments module) (@INC contains: /etc/perl /usr/local/lib/perl/5.18.2 /usr/local/share/perl/5.18.2 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.18 /usr/share/perl/5.18 /usr/local/lib/site_perl .) at /home/jackson/xSwipe-master/xSwipe.pl line 15.” 百度无果，最后还是google给了我答案 可以访问原文地址:https://forum.teksyndicate.com/t/perl-smart-comments/86880 做法是，在终端键入下列命令: sudo cpan -i Smart::Comments 等待完成即可，不出意外的话，通过命令： $ perl ~/xSwipe-master/xSwipe.pl 就可以开启三点以上触控板手势了，可以根据需要自行更改eventKey.cfg的内容来获得自己想要的手势。 xSwipe下载：http://pan.baidu.com/s/1gesqHm7 此文章仅作参考使用，使用时请仔细阅读说明文档。 我使用的操作系统为 ubuntu 14.04 LTS]]></content>
      <tags>
        <tag>ubuntu touchpad 触控板调节</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First day]]></title>
    <url>%2F2016%2F03%2F26%2FFirst-day%2F</url>
    <content type="text"><![CDATA[今天，正式开始！2016年3月26日 于西安电子科技大学]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F03%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
